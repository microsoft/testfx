// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using Microsoft.Testing.Extensions.TestReports.Resources;
using Microsoft.Testing.Extensions.TrxReport.Abstractions.Serializers;
using Microsoft.Testing.Platform.Capabilities.TestFramework;
using Microsoft.Testing.Platform.CommandLine;
using Microsoft.Testing.Platform.Configurations;
using Microsoft.Testing.Platform.Extensions;
using Microsoft.Testing.Platform.Extensions.Messages;
using Microsoft.Testing.Platform.Extensions.OutputDevice;
using Microsoft.Testing.Platform.Extensions.TestFramework;
using Microsoft.Testing.Platform.Extensions.TestHost;
using Microsoft.Testing.Platform.Helpers;
using Microsoft.Testing.Platform.IPC.Models;
using Microsoft.Testing.Platform.Logging;
using Microsoft.Testing.Platform.Messages;
using Microsoft.Testing.Platform.OutputDevice;
using Microsoft.Testing.Platform.Services;

namespace Microsoft.Testing.Extensions.TrxReport.Abstractions;

internal sealed class TrxReportGenerator :
    IDataConsumer,
    ITestSessionLifetimeHandler,
    IDataProducer,
    IOutputDeviceDataProducer
{
    private readonly IConfiguration _configuration;
    private readonly ICommandLineOptions _commandLineOptionsService;
    private readonly ITestApplicationModuleInfo _testApplicationModuleInfo;
    private readonly IMessageBus _messageBus;
    private readonly IClock _clock;
    private readonly IEnvironment _environment;
    private readonly IOutputDevice _outputDisplay;
    private readonly ITestFramework _testFramework;
    private readonly ITestFrameworkCapabilities _testFrameworkCapabilities;
    private readonly ITestApplicationProcessExitCode _testApplicationProcessExitCode;
    private readonly TrxTestApplicationLifecycleCallbacks? _trxTestApplicationLifecycleCallbacks;
    private readonly ILogger<TrxReportGenerator> _logger;
    private readonly List<TestNodeUpdateMessage> _tests = [];
    private readonly Dictionary<IExtension, List<SessionFileArtifact>> _artifactsByExtension = [];
    private readonly bool _isEnabled;

    private DateTimeOffset? _testStartTime;
    private int _failedTestsCount;
    private int _passedTestsCount;
    private int _notExecutedTestsCount;
    private int _timeoutTestsCount;
    private bool _adapterSupportTrxCapability;

    public TrxReportGenerator(
        IConfiguration configuration,
        ICommandLineOptions commandLineOptionsService,
        ITestApplicationModuleInfo testApplicationModuleInfo,
        IMessageBus messageBus,
        IClock clock,
        IEnvironment environment,
        IOutputDevice outputDisplay,
        ITestFramework testFramework,
        ITestFrameworkCapabilities testFrameworkCapabilities,
        ITestApplicationProcessExitCode testApplicationProcessExitCode,
        // Can be null in case of server mode
        TrxTestApplicationLifecycleCallbacks? trxTestApplicationLifecycleCallbacks,
        ILogger<TrxReportGenerator> logger)
    {
        _configuration = configuration;
        _commandLineOptionsService = commandLineOptionsService;
        _testApplicationModuleInfo = testApplicationModuleInfo;
        _messageBus = messageBus;
        _clock = clock;
        _environment = environment;
        _outputDisplay = outputDisplay;
        _testFramework = testFramework;
        _testFrameworkCapabilities = testFrameworkCapabilities;
        _testApplicationProcessExitCode = testApplicationProcessExitCode;
        _trxTestApplicationLifecycleCallbacks = trxTestApplicationLifecycleCallbacks;
        _logger = logger;
        _isEnabled = commandLineOptionsService.IsOptionSet(TrxReportGeneratorCommandLine.TrxReportOptionName);
    }

    public Type[] DataTypesConsumed { get; } =
    [
        typeof(TestNodeUpdateMessage),
        typeof(SessionFileArtifact)
    ];

    public Type[] DataTypesProduced { get; } = [typeof(SessionFileArtifact)];

    /// <inheritdoc />
    public string Uid => nameof(TrxReportGenerator);

    /// <inheritdoc />
    public string Version => AppVersion.DefaultSemVer;

    /// <inheritdoc />
    public string DisplayName { get; } = ExtensionResources.TrxReportGeneratorDisplayName;

    /// <inheritdoc />
    public string Description { get; } = ExtensionResources.TrxReportGeneratorDescription;

    /// <inheritdoc />
    public Task<bool> IsEnabledAsync() => Task.FromResult(_isEnabled);

    public Task ConsumeAsync(IDataProducer dataProducer, IData value, CancellationToken cancellationToken)
    {
        if (!_isEnabled || cancellationToken.IsCancellationRequested)
        {
            return Task.CompletedTask;
        }

        try
        {
            switch (value)
            {
                case TestNodeUpdateMessage nodeChangedMessage:
                    TestNodeStateProperty? nodeState = nodeChangedMessage.TestNode.Properties.SingleOrDefault<TestNodeStateProperty>();
                    if (nodeState is null)
                    {
                        return Task.CompletedTask;
                    }

                    if (nodeState is PassedTestNodeStateProperty)
                    {
                        _tests.Add(nodeChangedMessage);
                        _passedTestsCount++;
                    }
                    else if (nodeState is TimeoutTestNodeStateProperty)
                    {
                        _tests.Add(nodeChangedMessage);
                        _timeoutTestsCount++;
                    }
                    else if (Array.IndexOf(TestNodePropertiesCategories.WellKnownTestNodeTestRunOutcomeFailedProperties, nodeState.GetType()) != -1)
                    {
                        _tests.Add(nodeChangedMessage);
                        _failedTestsCount++;
                    }
                    else if (nodeState is SkippedTestNodeStateProperty)
                    {
                        _tests.Add(nodeChangedMessage);
                        _notExecutedTestsCount++;
                    }

                    break;

                case SessionFileArtifact fileArtifact:
                    if (!_artifactsByExtension.TryGetValue(dataProducer, out List<SessionFileArtifact>? sessionFileArtifacts))
                    {
                        sessionFileArtifacts = [fileArtifact];
                        _artifactsByExtension[dataProducer] = sessionFileArtifacts;
                    }
                    else
                    {
                        sessionFileArtifacts.Add(fileArtifact);
                    }

                    break;
            }
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cancellationToken)
        {
            // Do nothing, we're stopping
        }

        return Task.CompletedTask;
    }

    public async Task OnTestSessionStartingAsync(ITestSessionContext testSessionContext)
    {
        CancellationToken cancellationToken = testSessionContext.CancellationToken;
        if (!_isEnabled || cancellationToken.IsCancellationRequested)
        {
            return;
        }

        if (_logger.IsEnabled(LogLevel.Debug))
        {
            await _logger.LogDebugAsync($"""
CrashDumpCommandLineOptions.CrashDumpOptionName: {_commandLineOptionsService.IsOptionSet(CrashDumpCommandLineOptions.CrashDumpOptionName)}
TrxReportGeneratorCommandLine.IsTrxReportEnabled: {_commandLineOptionsService.IsOptionSet(TrxReportGeneratorCommandLine.TrxReportOptionName)}
""").ConfigureAwait(false);
        }

        if (TrxModeHelpers.ShouldUseOutOfProcessTrxGeneration(_commandLineOptionsService))
        {
            ApplicationStateGuard.Ensure(_trxTestApplicationLifecycleCallbacks is not null);
            ApplicationStateGuard.Ensure(_trxTestApplicationLifecycleCallbacks.NamedPipeClient is not null);

            try
            {
                await _trxTestApplicationLifecycleCallbacks.NamedPipeClient.RequestReplyAsync<TestAdapterInformationRequest, VoidResponse>(new TestAdapterInformationRequest(_testFramework.Uid, _testFramework.Version), cancellationToken)
                    .TimeoutAfterAsync(TimeoutHelper.DefaultHangTimeSpanTimeout, cancellationToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException ex) when (ex.CancellationToken == cancellationToken)
            {
                // Do nothing, we're stopping
            }
        }

        ITrxReportCapability? trxCapability = _testFrameworkCapabilities.GetCapability<ITrxReportCapability>();
        if (_isEnabled && trxCapability is not null && trxCapability.IsSupported)
        {
            _adapterSupportTrxCapability = true;
            trxCapability.Enable();
        }

        _testStartTime = _clock.UtcNow;
    }

    public async Task OnTestSessionFinishingAsync(ITestSessionContext testSessionContext)
    {
        CancellationToken cancellationToken = testSessionContext.CancellationToken;
        if (!_isEnabled || cancellationToken.IsCancellationRequested)
        {
            return;
        }

        try
        {
            if (!_adapterSupportTrxCapability)
            {
                await _outputDisplay.DisplayAsync(this, new WarningMessageOutputDeviceData(string.Format(CultureInfo.InvariantCulture, ExtensionResources.TrxReportFrameworkDoesNotSupportTrxReportCapability, _testFramework.DisplayName, _testFramework.Uid)), testSessionContext.CancellationToken).ConfigureAwait(false);
            }

            ApplicationStateGuard.Ensure(_testStartTime is not null);

            int exitCode = _testApplicationProcessExitCode.GetProcessExitCode();
            TrxReportEngine trxReportGeneratorEngine = new(_testApplicationModuleInfo, _environment, _commandLineOptionsService, _configuration,
                _clock, [.. _tests], _failedTestsCount, _passedTestsCount, _notExecutedTestsCount, _timeoutTestsCount, _artifactsByExtension,
                _adapterSupportTrxCapability, _testFramework, _testStartTime.Value, exitCode, cancellationToken);
            (string reportFileName, string? warning) = await trxReportGeneratorEngine.GenerateReportAsync().ConfigureAwait(false);
            if (warning is not null)
            {
                await _outputDisplay.DisplayAsync(this, new WarningMessageOutputDeviceData(warning), testSessionContext.CancellationToken).ConfigureAwait(false);
            }

            // If crash dump is not enabled we run trx in-process only
            if (!TrxModeHelpers.ShouldUseOutOfProcessTrxGeneration(_commandLineOptionsService))
            {
                await _messageBus.PublishAsync(this, new SessionFileArtifact(testSessionContext.SessionUid, new FileInfo(reportFileName), ExtensionResources.TrxReportArtifactDisplayName, ExtensionResources.TrxReportArtifactDescription)).ConfigureAwait(false);
            }
            else
            {
                ApplicationStateGuard.Ensure(_trxTestApplicationLifecycleCallbacks is not null);
                ApplicationStateGuard.Ensure(_trxTestApplicationLifecycleCallbacks.NamedPipeClient is not null);
                await _trxTestApplicationLifecycleCallbacks.NamedPipeClient.RequestReplyAsync<ReportFileNameRequest, VoidResponse>(new ReportFileNameRequest(reportFileName), cancellationToken).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException ex) when (ex.CancellationToken == cancellationToken)
        {
            // Do nothing, we're stopping
        }
    }
}
