<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">

  <!-- Acknowledge users choices -->
  <PropertyGroup Condition=" $(IsTestingPlatformApplication) == 'True' ">
    <GenerateTestingPlatformConfigurationFile Condition=" '$(GenerateTestingPlatformConfigurationFile)' == '' " >True</GenerateTestingPlatformConfigurationFile>
    <GenerateTestingPlatformEntryPoint Condition=" '$(GenerateTestingPlatformEntryPoint)' == '' " >True</GenerateTestingPlatformEntryPoint>
  </PropertyGroup>

  <!-- Declare our capability to Visual Studio/Visual Studio Code -->
  <ItemGroup Condition=" '$(DisableTestingPlatformServerCapability)' != 'True' ">
    <ProjectCapability Include="TestingPlatformServer" />

    <!-- Old capability expected by VS/VSCode -->
    <ProjectCapability Include="TestContainer" />
  </ItemGroup>

  <!-- Add assembly attribute metadata for reflection usage -->
  <ItemGroup>
    <AssemblyMetadata Include="Microsoft.Testing.Platform.Application" Value="True" Condition=" '$(IsTestingPlatformApplication)' == 'True' " />
  </ItemGroup>

  <!-- Setup the task folder -->
  <PropertyGroup>
    <!-- Constants -->
    <TasksFolder>$(MSBuildThisFileDirectory)..\_MSBuildTasks\netstandard2.0\</TasksFolder>
  </PropertyGroup>

  <!--
    Configuration file generation
    ===========================

    The configuration file is generated by the GenerateTestingPlatformConfigurationFile target.
    We copy the file called testingplatformconfig.json from the project directory to the output directory.
    The file is copied only if it does not exist in the output directory or if it has changed.
    The file is copied to the output directory before the CopyFilesToOutputDirectory target is executed.
  -->

  <UsingTask TaskName="Microsoft.Testing.Platform.MSBuild.ConfigurationFileTask"
           AssemblyFile="$(TasksFolder)Microsoft.Testing.Platform.MSBuild.dll"/>

  <PropertyGroup>
    <_TestingPlatformConfigurationFileSourceFileName>testingplatformconfig.json</_TestingPlatformConfigurationFileSourceFileName>
    <_TestingPlatformConfigurationFileSourcePath>$([System.IO.Path]::Combine($(MSBuildProjectDirectory),$(_TestingPlatformConfigurationFileSourceFileName)))</_TestingPlatformConfigurationFileSourcePath>
    <_TestingPlatformConfigurationFileName>$(AssemblyName).testingplatformconfig.json</_TestingPlatformConfigurationFileName>
    <_TestingPlatformConfigurationFile>$([System.IO.Path]::Combine($(MSBuildProjectDirectory),$(OutputPath),$(_TestingPlatformConfigurationFileName)))</_TestingPlatformConfigurationFile>
  </PropertyGroup>
  <Target Name="GenerateTestingPlatformConfigurationFile" BeforeTargets="CopyFilesToOutputDirectory"
          Inputs="$(_TestingPlatformConfigurationFileSourcePath)"
          Outputs="$(_TestingPlatformConfigurationFile)"
          Condition=" '$(GenerateTestingPlatformConfigurationFile)' == 'True' And Exists('$(_TestingPlatformConfigurationFileSourcePath)') " >
    <ConfigurationFileTask
      MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
      AssemblyName="$(AssemblyName)"
      OutputPath="$(OutputPath)"
      TestingPlatformConfigurationFileSource="$(_TestingPlatformConfigurationFileSourcePath)" >
      <Output TaskParameter="FinalTestingPlatformConfigurationFile" ItemName="TestingPlatformConfigurationFile" />
    </ConfigurationFileTask>
    <ItemGroup>
      <FileWrites Include="$(_TestingPlatformConfigurationFile)" />
    </ItemGroup>
    <ItemGroup>
      <ResolvedFileToPublish Include="$(_TestingPlatformConfigurationFile)" >
        <RelativePath>$(_TestingPlatformConfigurationFileName)</RelativePath>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>


  <!--
    Inject application entry point a.k.a. Program.* file
    ===========================

    Expected extensions items shape

  <ItemGroup>
    <TestingPlatformBuilderHook Include="8E680F4D-E423-415A-9566-855439363BC0" >
      <DisplayName>MyBuilderHook</DisplayName>
      <TypeFullName>Contoso.BuilderHook</TypeFullName>
    </TestingPlatformBuilderHook>
  </ItemGroup>
  -->

  <UsingTask TaskName="Microsoft.Testing.Platform.MSBuild.TestingPlatformEntryPointTask"
           AssemblyFile="$(TasksFolder)Microsoft.Testing.Platform.MSBuild.dll"/>

  <Target Name="_GenerateTestingPlatformEntryPointFileInputCache" BeforeTargets="_GenerateTestingPlatformEntryPoint" Condition=" '$(GenerateTestingPlatformEntryPoint)' == 'True' " >
    <PropertyGroup>
      <!-- Cache file to check -->
      <_GenerateTestingPlatformEntryPointInputsCachFilePath>$(IntermediateOutputPath)$(MSBuildProjectName).gentestingplatformentrypointinputcache.cache</_GenerateTestingPlatformEntryPointInputsCachFilePath>
      <_GenerateTestingPlatformEntryPointInputsCachFilePath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GenerateTestingPlatformEntryPointInputsCachFilePath)))</_GenerateTestingPlatformEntryPointInputsCachFilePath>
    </PropertyGroup>
    <ItemGroup>
      <!-- Items to hash-->
      <_GenerateTestingPlatformEntryPointInputsCacheToHash Include="@(TestingPlatformBuilderHook)"/>
      <!-- Export the items name for the _GenerateTestingPlatformInjectEntryPoint task-->
      <GenerateTestingPlatformEntryPointInputsCacheFilePath Include="$(_GenerateTestingPlatformEntryPointInputsCachFilePath)" />
    </ItemGroup>
    <!-- Hash the extensions information -->
    <Hash ItemsToHash="@(_GenerateTestingPlatformEntryPointInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GenerateTestingPlatformEntryPointInputsCache" />
    </Hash>
    <!-- Write the hash value to the cache file -->
    <WriteLinesToFile Lines="$(_GenerateTestingPlatformEntryPointInputsCache)"
                  File="$(_GenerateTestingPlatformEntryPointInputsCachFilePath)"
                  Overwrite="True"
                  WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateTestingPlatformEntryPointInputsCachFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Generate the entry point source using the user extensions informations -->
  <PropertyGroup>
    <_TestingPlatformEntryPointSourceNameWithoutExtension>TestPlatformEntryPoint</_TestingPlatformEntryPointSourceNameWithoutExtension>
    <_TestingPlatformEntryPointSourceName Condition=" $(Language) == 'C#' " >$(_TestingPlatformEntryPointSourceNameWithoutExtension).cs</_TestingPlatformEntryPointSourceName>
    <_TestingPlatformEntryPointSourceName Condition=" $(Language) == 'VB' " >$(_TestingPlatformEntryPointSourceNameWithoutExtension).vb</_TestingPlatformEntryPointSourceName>
    <_TestingPlatformEntryPointSourceName Condition=" $(Language) == 'F#' " >$(_TestingPlatformEntryPointSourceNameWithoutExtension).fs</_TestingPlatformEntryPointSourceName>
    <_TestingPlatformEntryPointSourcePath>$([System.IO.Path]::Combine($(IntermediateOutputPath),$(_TestingPlatformEntryPointSourceName)))</_TestingPlatformEntryPointSourcePath>
    <_TestingPlatformEntryPointSourcePath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_TestingPlatformEntryPointSourcePath)))</_TestingPlatformEntryPointSourcePath>
  </PropertyGroup>
  <Target Name="_GenerateTestingPlatformEntryPoint" BeforeTargets="IncludeGenerateTestingPlatformEntryPointIntoCompilation"
          Inputs="@(GenerateTestingPlatformEntryPointInputsCacheFilePath)" Outputs="$(_TestingPlatformEntryPointSourcePath)"
          Condition=" '$(GenerateTestingPlatformEntryPoint)' == 'True' " >
    <TestingPlatformEntryPointTask TestingPlatformEntryPointSourcePath="$(_TestingPlatformEntryPointSourcePath)"
                                  Language="$(Language)"
                                  TestingPlatformBuilderHooks="@(TestingPlatformBuilderHook)"
                               >
      <Output TaskParameter="TestingPlatformEntryPointGeneratedFilePath" PropertyName ="TestingPlatformEntryPointGeneratedFilePath" />
    </TestingPlatformEntryPointTask>
    <ItemGroup>
      <FileWrites Include="$(_TestingPlatformEntryPointSourcePath)" />
    </ItemGroup>
  </Target>

  <!-- We always include the entry point also if the task _GenerateTestingPlatformInjectEntryPoint is skipped for caching reason -->
  <Target Name="IncludeGenerateTestingPlatformEntryPointIntoCompilation" BeforeTargets="CoreCompile" Condition=" '$(GenerateTestingPlatformEntryPoint)' == 'True' " >
    <ItemGroup>
      <Compile Include="$(_TestingPlatformEntryPointSourcePath)" />
    </ItemGroup>
    <!-- We need to report to the FileWrites here because is possible that we skip _GenerateTestingPlatformInjectEntryPoint and we want to correctly handle the "dotnet clean" target -->
    <ItemGroup>
      <FileWrites Include="$(_TestingPlatformEntryPointSourcePath)" />
    </ItemGroup>
  </Target>


  <!--
      Hook the testing platform
      ===========================

      Entry points targets:
        * VSTest: Overrides the SDK VSTest target for single tfm, we use the built-in multitfm workflow https://github.com/dotnet/sdk/blob/main/src/Layout/redist/MSBuildImports/Current/Microsoft.Common.CrossTargeting.targets/ImportAfter/Microsoft.TestPlatform.CrossTargeting.targets#L79
        * Test: We plug ourself to the available VSTest target for multitfm and we go directly to our target for single tfm
  -->
  <UsingTask TaskName="Microsoft.Testing.Platform.MSBuild.InvokeTestingPlatformTask"
         AssemblyFile="$(TasksFolder)Microsoft.Testing.Platform.MSBuild.dll"/>

  <PropertyGroup>
    <!-- Disable custom -t:Test target -->
    <TestingPlatformDisableCustomTestTarget Condition=" '$(TestingPlatformDisableCustomTestTarget)' == '' ">False</TestingPlatformDisableCustomTestTarget>
    <!-- Support dotnet test -->
    <TestingPlatformDotnetTestSupport Condition=" '$(TestingPlatformDotnetTestSupport)' == '' ">False</TestingPlatformDotnetTestSupport>
    <!--
        Verify if the <UseMSBuildTestInfrastructure> is available
        https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets#L6807
        https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.Test.targets
    -->
    <_MSBuildTestInfrastructureAvailable Condition="Exists('$(MSBuildExtensionsPath)\Microsoft.Common.Test.targets')" >True</_MSBuildTestInfrastructureAvailable>
  </PropertyGroup>

  <Target Name="_SetCustomVSTargetForVSTest" BeforeTargets="VSTest" Condition=" '$(TestingPlatformDotnetTestSupport)' == 'True' ">
    <PropertyGroup>
      <!-- Set our VSTest target for the multi-tfm workflow -->
      <InnerVSTestTargets Condition=" '$(TestingPlatformDotnetTestSupport)' == 'True' " >InvokeTestingPlatform</InnerVSTestTargets>
    </PropertyGroup>
  </Target>
  <!-- Override VSTest only in case of single tfm, for multitfm we rely on built-in mechanism -->
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Testing.Platform.MSBuild.VSTest.targets"
          Condition=" '$(TargetFramework)' != '' AND '$(TestingPlatformDotnetTestSupport)' == 'True' "/>

  <!-- Rely on VSTest infra -->
  <!-- We setup the InnerVSTestTargets is we're using the MSBuild infrastructure or if user didn't disble the custom test target -->
  <Target Name="_SetCustomVSTargetForTest" BeforeTargets="Test" Condition=" ( '$(UseMSBuildTestInfrastructure)' == 'True' AND '$(_MSBuildTestInfrastructureAvailable)' == 'True' ) OR '$(TestingPlatformDisableCustomTestTarget)' == 'False' " >
    <PropertyGroup>
      <InnerVSTestTargets>InvokeTestingPlatform</InnerVSTestTargets>
    </PropertyGroup>
  </Target>

  <!-- Plug with the new msbuild target
    https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets#L6807
    https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.Test.targets
  -->
  <Target Name="_MSBuildTest" AfterTargets="Test" Condition=" '$(UseMSBuildTestInfrastructure)' == 'True' AND '$(_MSBuildTestInfrastructureAvailable)' == 'True' " >
    <CallTarget Targets="_TestingPlatformTest" />
  </Target>

  <!-- Expose a test target usable by tests projects where this target is injected -->
  <Target Name="Test" Condition=" '$(UseMSBuildTestInfrastructure)' != 'True' AND '$(TestingPlatformDisableCustomTestTarget)' == 'False' " >
    <CallTarget Targets="_TestingPlatformTest" />
  </Target>

  <Target Name="_TestingPlatformTest">
    <!-- We call VSTest built-in workflow only for the multi-tfm for single tfm we need to directly call our target -->
    <CallTarget Targets="VSTest"  Condition=" '$(TargetFramework)' == '' "/>
    <!-- For single tfm we call directly our target like we're doing for single tfm and VSTest -->
    <CallTarget Targets="_BuildAndInvokeTestingPlatform"  Condition=" '$(TargetFrameworks)' == '' "/>
  </Target>

  <!-- Override VSTest target for single tfm -->
  <Target Name="_BuildAndInvokeTestingPlatform" >
    <!--
      When the project is not built, build it. dotnet/sdk will call us always with this property set to true.
      This is only needed for direct call to this target, e.g. dotnet build -t:vstest.
    -->
    <MSBuild Condition="'$(VSTestNoBuild)' != 'true'" Projects="$(MSBuildProjectFullPath)" />
    <CallTarget Targets="InvokeTestingPlatform" />
  </Target>

  <!-- Invoke the tool task -->
  <PropertyGroup>
    <!--
      The architecture below is used for log name, but it does not impact the architecture of the exe we will start.
      We are basically trying to guess what we've just built and what architecture it has.
    -->
    <_TestArchitecture>$(PlatformTarget)</_TestArchitecture>
    <!--
      DefaultAppHostRuntimeIdentifier will tell us what is the architecture of the apphost
      SDK runtime will build when not overridden. This takes TargetFramework into account so it is more accurate. This value depends on the actual architecture of the SDK, e.g. win-x64, or win-arm64.
    -->
    <_TestArchitecture Condition="('$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu') and '$(DefaultAppHostRuntimeIdentifier)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(DefaultAppHostRuntimeIdentifier), '.*-', ''))</_TestArchitecture>
    <!--
    NETCoreSdkRuntimeIdentifier is used by DefaultAppHostRuntimeIdentifier to figure out the architecture, and is defined also for .NET Framework.
    -->
    <_TestArchitecture Condition="('$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu') and '$(NETCoreSdkRuntimeIdentifier)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(DefaultAppHostRuntimeIdentifier), '.*-', ''))</_TestArchitecture>
    <!-- If everyting else fails, fallback to x64. -->
    <_TestArchitecture Condition="'$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu'">x64</_TestArchitecture>
    <TestingPlatformShowTestsFailure Condition=" '$(TestingPlatformShowTestsFailure)' == '' ">False</TestingPlatformShowTestsFailure>
    <TestingPlatformCaptureOutput Condition=" '$(TestingPlatformCaptureOutput)' == '' " >True</TestingPlatformCaptureOutput>
  </PropertyGroup>
  <Target Name="InvokeTestingPlatform" >
    <!--
      This target name is hardcoded in TerminalLogger to mean start of test workload.
      This let's terminal logger know that it should show `Testing` in the output,
      and not the additional internal details, such as target names.
    -->
    <CallTarget Targets="_TestRunStart" />
    <InvokeTestingPlatformTask TargetPath="$(TargetPath)"
                               TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                               TargetFramework="$(TargetFramework)"
                               TestArchitecture="$(_TestArchitecture)"
                               ProjectFullPath="$(MSBuildProjectFullPath)"
                               TestingPlatformShowTestsFailure="$(TestingPlatformShowTestsFailure)"
                               TestingPlatformCommandLineArguments="$(TestingPlatformCommandLineArguments)"
                               TestingPlatformCaptureOutput="$(TestingPlatformCaptureOutput)"
                               DotnetHostPath="$(DOTNET_HOST_PATH)" />
  </Target>

  <Target Name="_TestRunStart" />
</Project>
