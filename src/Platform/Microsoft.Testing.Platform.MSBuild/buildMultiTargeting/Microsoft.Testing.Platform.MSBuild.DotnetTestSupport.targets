<Project>

  <!--
      Hook the testing platform
      ===========================

      Entry points targets:
        * VSTest: Overrides the SDK VSTest target for single tfm, we use the built-in multitfm workflow https://github.com/dotnet/sdk/blob/main/src/Layout/redist/MSBuildImports/Current/Microsoft.Common.CrossTargeting.targets/ImportAfter/Microsoft.TestPlatform.CrossTargeting.targets#L79
        * Test: We plug ourself to the available VSTest target for multitfm and we go directly to our target for single tfm
  -->

  <!-- Import task -->
  <UsingTask TaskName="Microsoft.Testing.Platform.MSBuild.InvokeTestingPlatformTask"
         AssemblyFile="$(MicrosoftTestingPlatformMSBuildTaskFolder)Microsoft.Testing.Platform.MSBuild.dll"/>

  <Target Name="_SetCustomVSTargetForVSTest" BeforeTargets="VSTest">
    <PropertyGroup>
      <!-- Set our VSTest target for the multi-tfm workflow -->
      <InnerVSTestTargets>InvokeTestingPlatform</InnerVSTestTargets>
    </PropertyGroup>
  </Target>

  <!-- Override VSTest only in case of single tfm, for multitfm we rely on built-in mechanism -->
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Testing.Platform.MSBuild.VSTest.targets"
          Condition=" '$(TargetFramework)' != '' "/>

  <!-- Rely on VSTest infra -->
  <!-- We setup the InnerVSTestTargets is we're using the MSBuild infrastructure or if user didn't disble the custom test target -->
  <Target Name="_SetCustomVSTargetForTest" BeforeTargets="Test" Condition=" ( '$(UseMSBuildTestInfrastructure)' == 'true' AND '$(_MSBuildTestInfrastructureAvailable)' == 'true' ) OR '$(TestingPlatformDisableCustomTestTarget)' == 'false' " >
    <PropertyGroup>
      <InnerVSTestTargets>InvokeTestingPlatform</InnerVSTestTargets>
    </PropertyGroup>
  </Target>

  <!-- Plug with the new msbuild target
    https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets#L6807
    https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.Test.targets
  -->
  <Target Name="_MSBuildTest" AfterTargets="Test" Condition=" '$(UseMSBuildTestInfrastructure)' == 'true' AND '$(_MSBuildTestInfrastructureAvailable)' == 'true' " >
    <CallTarget Targets="_TestingPlatformTest" />
  </Target>

  <!-- The Test target is separated so that we can conditionally define it. -->
  <!-- Putting a condition on a target determines whether the target is **executed** or not -->
  <!-- We want to not define the Test target in the first place when the user sets TestingPlatformDisableCustomTestTarget to true -->
  <Import Project="Microsoft.Testing.Platform.MSBuild.CustomTestTarget.targets" Condition=" '$(TestingPlatformDisableCustomTestTarget)' == 'false'" />

  <Target Name="_TestingPlatformTest">
    <!-- We call VSTest built-in workflow only for the multi-tfm for single tfm we need to directly call our target -->
    <CallTarget Targets="VSTest"  Condition=" '$(TargetFramework)' == '' "/>
    <!-- For single tfm we call directly our target like we're doing for single tfm and VSTest -->
    <CallTarget Targets="_BuildAndInvokeTestingPlatform"  Condition=" '$(TargetFrameworks)' == '' "/>
  </Target>

  <!-- Override VSTest target for single tfm -->
  <Target Name="_BuildAndInvokeTestingPlatform" >
    <!--
      When the project is not built, build it. dotnet/sdk will call us always with this property set to true.
      This is only needed for direct call to this target, e.g. dotnet build -t:vstest.
    -->
    <MSBuild Condition="'$(VSTestNoBuild)' != 'true'" Projects="$(MSBuildProjectFullPath)" />
    <CallTarget Targets="InvokeTestingPlatform" />
  </Target>

  <!-- Invoke the tool task -->
  <PropertyGroup>
    <!--
      The architecture below is used for log name, but it does not impact the architecture of the exe we will start.
      We are basically trying to guess what we've just built and what architecture it has.
    -->
    <_TestArchitecture>$(PlatformTarget)</_TestArchitecture>
    <!--
      DefaultAppHostRuntimeIdentifier will tell us what is the architecture of the apphost
      SDK runtime will build when not overridden. This takes TargetFramework into account so it is more accurate. This value depends on the actual architecture of the SDK, e.g. win-x64, or win-arm64.
    -->
    <_TestArchitecture Condition="('$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu') and '$(DefaultAppHostRuntimeIdentifier)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(DefaultAppHostRuntimeIdentifier), '.*-', ''))</_TestArchitecture>
    <!--
    NETCoreSdkRuntimeIdentifier is used by DefaultAppHostRuntimeIdentifier to figure out the architecture, and is defined also for .NET Framework.
    -->
    <_TestArchitecture Condition="('$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu') and '$(NETCoreSdkRuntimeIdentifier)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(NETCoreSdkRuntimeIdentifier), '.*-', ''))</_TestArchitecture>
    <!-- If everyting else fails, fallback to x64. -->
    <_TestArchitecture Condition="'$(_TestArchitecture)' == '' or '$(_TestArchitecture)' == 'AnyCpu'">x64</_TestArchitecture>
    <TestingPlatformShowTestsFailure Condition=" '$(TestingPlatformShowTestsFailure)' == '' ">false</TestingPlatformShowTestsFailure>
    <TestingPlatformCaptureOutput Condition=" '$(TestingPlatformCaptureOutput)' == '' " >true</TestingPlatformCaptureOutput>
  </PropertyGroup>
  <Target Name="InvokeTestingPlatform" >
    <!--
      This target name is hardcoded in TerminalLogger to mean start of test workload.
      This let's terminal logger know that it should show `Testing` in the output,
      and not the additional internal details, such as target names.
    -->
    <!-- Passing UseAppHost, IsExecutable, TargetDir, AssemblyName, and _NativeExecutableExtensions is mostly workaround -->
    <!-- until we implement https://github.com/microsoft/testfx/issues/5091 properly -->
    <!-- For now, we construct the correct "RunCommand" via these properties for a specific scenario that's known to be broken -->
    <CallTarget Targets="_TestRunStart" />
    <InvokeTestingPlatformTask TargetPath="$(TargetPath)"
                               UseAppHost="$(UseAppHost)"
                               IsExecutable="$(_IsExecutable)"
                               TargetDir="$(TargetDir)"
                               AssemblyName="$(AssemblyName)"
                               NativeExecutableExtension="$(_NativeExecutableExtension)"
                               TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                               TargetFramework="$(TargetFramework)"
                               TestArchitecture="$(_TestArchitecture)"
                               ProjectFullPath="$(MSBuildProjectFullPath)"
                               TestingPlatformShowTestsFailure="$(TestingPlatformShowTestsFailure)"
                               TestingPlatformCommandLineArguments="$(TestingPlatformCommandLineArguments)"
                               VSTestCLIRunSettings="$(VSTestCLIRunSettings)"
                               TestingPlatformCaptureOutput="$(TestingPlatformCaptureOutput)"
                               DotnetHostPath="$(DOTNET_HOST_PATH)" />
  </Target>

  <Target Name="_TestRunStart" />

</Project>
