<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">I metodi contrassegnati con ‘[AssemblyCleanup]' devono seguire il layout seguente per essere validi:
-Non può essere dichiarato in una classe generica
- Deve essere 'public'
- Deve essere 'static'
- Non deve essere 'async void'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Non deve accettare alcun parametro o accettare un singolo parametro di tipo 'TestContext'
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-La classe deve essere contrassegnata con '[TestClass]' (o un attributo derivato)
-La classe non deve essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo AssemblyCleanup '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">Il metodo AssemblyCleanup deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">I metodi contrassegnati con ‘[AssemblyInitialize]’ devono seguire il layout seguente per essere validi:
-Non può essere dichiarato in una classe generica
- Deve essere 'public'
- Deve essere 'static'
- Non deve essere 'async void'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Deve accettare un parametro di tipo 'TestContext'
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-La classe deve essere contrassegnata con '[TestClass]' (o un attributo derivato).
-La classe non deve essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo AssemblyInitialize '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">Il metodo AssemblyInitialize deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">Preferire l'aggiunta di un'ulteriore asserzione che controlli la presenza di valori null</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">Evitare l'accesso condizionale nelle asserzioni</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">"Assert.AreEqual", "Assert.AreNotEqual", "Assert.AreSame" e "Assert.AreNotSame" prevedono che il valore previsto venga passato per primo e il valore effettivo come secondo argomento.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">Gli argomenti dell'asserzione devono essere passati nell'ordine corretto. Gli argomenti "actual" ed "expected"/"notExpected" sono stati invertiti.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">Gli argomenti dell'asserzione devono essere passati nell'ordine corretto</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesDescription">
        <source>Use 'Assert.AreEqual'/'Assert.AreNotEqual' instead of 'Assert.AreSame'/'Assert.AreNotSame' when comparing value types. Passing a value type to 'Assert.AreSame'/'Assert.AreNotSame' will be boxed (creating a new object). Because 'Assert.AreSame'/'Assert.AreNotSame' does the comparison by reference, 'Assert.AreSame' will fail when boxing happens, and 'Assert.AreNotSame' will always pass.</source>
        <target state="translated">Usare 'Assert.AreEqual'/'Assert.AreNotEqual' invece di 'Assert.AreSame'/'Assert.AreNotSame' durante il confronto dei tipi valore. Se si passa un tipo valore a 'Assert.AreSame'/'Assert.AreNotSame', verrà eseguito il boxing (creazione di un nuovo oggetto). Poiché 'Assert.AreSame'/'Assert.AreNotSame' esegue il confronto per riferimento, 'Assert.AreSame' non riuscirà quando si esegue la boxing e 'Assert.AreNotSame' passerà sempre.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesMessageFormat">
        <source>Use '{0}' instead of '{1}' when comparing value types</source>
        <target state="translated">Usa '{0}' invece di '{1}' durante il confronto dei tipi di valore</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesTitle">
        <source>Don't use 'Assert.AreSame' or 'Assert.AreNotSame' with value types</source>
        <target state="translated">Non usare 'Assert.AreSame' o 'Assert.AreNotSame' con i tipi di valore</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsExactly' or 'Assert.ThrowsExactlyAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exception.</source>
        <target state="translated">Preferire 'Assert.ThrowsExactly' o 'Assert.ThrowsExactlyAsync' a '[ExpectedException]' perché assicura che solo la chiamata prevista generi l'eccezione prevista. Le API di asserzione offrono anche maggiore flessibilità e consentono di dichiarare proprietà aggiuntive dell'eccezione.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsExactly/ThrowsExactlyAsync' over '[ExpectedException]'</source>
        <target state="translated">Preferire 'Assert.ThrowsExactly/ThrowsExactlyAsync' a '[ExpectedException]'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Evita '[ExpectedException]'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeMessageFormat">
        <source>Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</source>
        <target state="new">Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeTitle">
        <source>Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</source>
        <target state="new">Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextDescription">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas. Exceptions that are thrown in this context will be unhandled exceptions. When using VSTest under .NET Framework, they will be silently swallowed. When using Microsoft.Testing.Platform or VSTest under modern .NET, they may crash the process.</source>
        <target state="translated">Non dichiarare all'interno di metodi 'async void', funzioni locali o espressioni lambda. Le eccezioni generate in questo contesto saranno eccezioni non gestite. Quando si usa VSTest in .NET Framework, verranno eliminati automaticamente. Quando si usa Microsoft.Testing.Platform o VSTest nella versione moderna di .NET, è possibile che il processo venga arrestato in modo anomalo.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextMessageFormat">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas because they may not fail the test</source>
        <target state="translated">Non dichiarare all'interno di metodi 'async void', funzioni locali o espressioni lambda perché non possono non testare il test</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextTitle">
        <source>Do not assert inside 'async void' contexts</source>
        <target state="translated">Non dichiarare all'interno di contesti 'async void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">I metodi contrassegnati con ‘[ClassCleanup]' devono seguire il layout seguente per essere validi:
-Non può essere dichiarato in una classe generica se la modalità 'InheritanceBehavior' non è impostata
- Deve essere 'public'
- Deve essere 'static'
- Non deve essere 'async void'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Non deve accettare alcun parametro o accettare un singolo parametro di tipo 'TestContext'
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'
- È necessario specificare il parametro dell'attributo 'InheritanceBehavior.BeforeEachDerivedClass' se la classe è 'abstract'
- Non è necessario specificare il parametro dell'attributo 'InheritanceBehavior.BeforeEachDerivedClass' se la classe è 'sealed'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-Se la classe è 'sealed', deve essere contrassegnata con '[TestClass]' (o un attributo derivato)
-La classe non deve essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo ClassCleanup '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">Il metodo ClassCleanup deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">I metodi contrassegnati con ‘[ClassInitialize]’ devono seguire il layout seguente per essere validi:
-Non può essere dichiarato in una classe generica se la modalità 'InheritanceBehavior' non è impostata
- Deve essere 'public'
- Deve essere 'static'
- Non deve essere 'async void'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Deve accettare un parametro di tipo 'TestContext'
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'
- È necessario specificare il parametro dell'attributo 'InheritanceBehavior.BeforeEachDerivedClass' se la classe è 'abstract'
- Non è necessario specificare il parametro dell'attributo 'InheritanceBehavior.BeforeEachDerivedClass' se la classe è 'sealed'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-Se la classe è 'sealed', deve essere contrassegnata con '[TestClass]' (o un attributo derivato)
-La classe non deve essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo ClassInitialize '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">Il metodo ClassInitialize deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">La voce di DataRow deve avere il layout seguente per essere valido:
- deve essere impostato solo su un metodo di test;
- il numero di argomenti deve corrispondere al numero di argomenti del metodo;
- il tipo di argomento deve corrispondere al tipo di argomento del metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">Il numero di argomenti DataRow deve corrispondere al numero di parametri del metodo (argomenti del costruttore: {0}, parametri del metodo: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument types do not match method parameter types. {0}</source>
        <target state="translated">Il tipo di argomento di DataRow deve corrispondere ai tipi di parametro del metodo. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ParameterMismatch">
        <source>Parameter '{0}' expects type '{1}', but the provided value has type '{2}'</source>
        <target state="translated">Il parametro '{0}' prevede il tipo '{1}', ma il tipo del valore specificato è '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentConflictingTypes">
        <source>Found two conflicting types for generic parameter '{0}'. The conflicting types are '{1}' and '{2}'.</source>
        <target state="translated">Sono stati trovati due tipi in conflitto per il parametro generico '{0}'. I tipi in conflitto sono '{1}' e '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentNotResolved">
        <source>The type of the generic parameter '{0}' could not be inferred.</source>
        <target state="translated">Impossibile dedurre il tipo del parametro generico '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow deve essere impostato solo su un metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow deve essere valido</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">Non negare asserzioni booleane, usare l'asserzione opposta</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">Non negare asserzioni booleane</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Non archiviare TestContext in un membro statico</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Non archiviare TestContext in un membro statico</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">I membri del test di shadowing potrebbero causare problemi di test, ad esempio NRE.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' already exists in the base class</source>
        <target state="translated">Il membro “{0}” esiste già nella classe di base</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">Non usare lo shadowing</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' non ha alcun effetto in un contesto di test ed è probabile che si intendesse usare 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">Si intendeva usare 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' non ha alcun effetto sui metodi di test.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowMessageFormat">
        <source>Do not duplicate 'DataRow' attributes. This is usually a copy/paste error. The attribute indices are '{0}' and '{1}'.</source>
        <target state="translated">Non duplicare gli attributi 'DataRow'. Generalmente è un errore di copia/incolla. Gli indici degli attributi sono '{0}' e '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowTitle">
        <source>Avoid duplicated 'DataRow' entries</source>
        <target state="translated">Evitare voci 'DataRow' duplicate</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">La voce di '[DynamicData]' deve avere il layout seguente per essere valida:
- deve essere impostato solo su un metodo di test;
- il membro deve essere definito nel tipo specificato;
- il membro deve essere un metodo se si specifica DynamicDataSourceType.Method o una proprietà in caso contrario.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">La firma del membro dati '[DynamicData]' '{0}.{1}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">La firma '{0}.{1}' del metodo del nome visualizzato '[DynamicData]' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">Il membro '[DynamicData]' '{0}.{1}' deve essere un metodo</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">Impossibile trovare il membro '[DynamicData]' '{0}.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">Il membro di riferimento '[DynamicData]' '{0}.{1}' deve restituire 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;' o 'IEnumerable&lt;ValueTuple&gt;'</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">'[DynamicData]' deve essere impostato solo su un metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeField">
        <source>'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Method' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' è un metodo, quindi è consigliabile usare 'DynamicDataSourceType.AutoDetect' o 'DynamicDataSourceType.Method'. Il rilevamento automatico è l'impostazione predefinita quando non è specificata in modo esplicito ed è consigliabile</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyMethodOrField">
        <source>'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyOrMethod">
        <source>'[DynamicData]' member '{0}.{1}' is not a property nor a method. Only properties and methods are supported.</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' non è una proprietà né un metodo. Sono supportati solo metodi e proprietà.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Property' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' è una proprietà, quindi è consigliabile usare 'DynamicDataSourceType.AutoDetect' o 'DynamicDataSourceType.Property'. Il rilevamento automatico è l'impostazione predefinita quando non è specificata in modo esplicito ed è consigliata</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicData]' member '{0}.{1}' is found more than once</source>
        <target state="translated">Il membro '[DynamicData]' '{0}.{1}' è stato trovato più di una volta</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData deve essere valido</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenDescription">
        <source>When calling async methods that have overloads accepting a CancellationToken parameter, prefer using the overload with TestContext.CancellationTokenSource.Token to enable cooperative cancellation and respect test timeouts.</source>
        <target state="translated">Quando si chiamano metodi asincroni con overload che accettano un parametro CancellationToken, preferire l'uso dell'overload con TestContext.CancellationTokenSource.Token per abilitare l'annullamento cooperativo e rispettare i timeout di test.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenMessageFormat">
        <source>Consider using the overload that accepts a CancellationToken and pass 'TestContext.CancellationTokenSource.Token'</source>
        <target state="translated">Valutare la possibilità di usare l'overload che accetta un CancellationToken e a passare 'TestContext.CancellationTokenSource.Token'</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenTitle">
        <source>Flow TestContext.CancellationToken to async operations</source>
        <target state="translated">Flusso da TestContext.CancellationToken a operazioni asincrone</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidDescription">
        <source>Methods marked with '[GlobalTestInitialize]' or '[GlobalTestCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public'
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">I metodi contrassegnati con ‘[GlobalTestInitialize]’ o ‘[GlobalTestCleanup]’ devono seguire il layout seguente per essere validi:
- Non può essere dichiarato in una classe generica
- Deve essere 'public'
- Deve essere 'static'
- Non deve essere 'async void'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Deve accettare un parametro di tipo 'TestContext'
- Il tipo restituito deve essere 'void', 'Task' o 'ValueTask'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
- Il tipo deve essere una classe
- La classe deve essere 'public'
- La classe non deve essere 'static'
- La classe deve essere contrassegnata con '[TestClass]' (o un attributo derivato)
- La classe non deve essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidMessageFormat">
        <source>Global test fixture method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo di fixture di test globale '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidTitle">
        <source>GlobalTestInitialize and GlobalTestCleanup methods should have valid layout</source>
        <target state="translated">I metodi GlobalTestInitialize e GlobalTestCleanup devono avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">Usare 'Assert.Fail' invece di un'asserzione 'Assert.{0}' che ha sempre esito negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">Usare 'Assert.Fail' invece di un'asserzione che ha sempre esito negativo</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerDescription">
        <source>'DataTestMethodAttribute' is obsolete and provides no additional functionality over 'TestMethodAttribute'. Use 'TestMethodAttribute' for all test methods, including parameterized tests.</source>
        <target state="translated">'DataTestMethodAttribute' è obsoleto e non offre funzionalità aggiuntive rispetto a 'TestMethodAttribute'. Utilizzare 'TestMethodAttribute' per tutti i metodi di test, inclusi i test con parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerMessageFormat">
        <source>'DataTestMethod' is obsolete. Use 'TestMethod' instead.</source>
        <target state="translated">'DataTestMethod' è obsoleto. Utilizzare 'TestMethod' invece.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerTitle">
        <source>Prefer 'TestMethod' over 'DataTestMethod'</source>
        <target state="translated">Preferisci 'TestMethod' a 'DataTestMethod'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">Rivedere o rimuovere l'asserzione perché la relativa condizione è sempre true</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">La condizione dell’asserzione è sempre true</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Preferisci costruttori rispetto ai metodi TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Preferisci costruttori rispetto ai metodi TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Preferisci "Dispose" ai metodi TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Preferisci "Dispose" ai metodi TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Preferisci TestCleanup ai metodi "Dispose".</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Preferisci TestCleanup ai metodi "Dispose".</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Preferisci i metodi TestInitialize rispetto ai costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Preferisci i metodi TestInitialize rispetto ai costruttori</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="translated">I metodi pubblici devono essere metodi di test (contrassegnati con '[TestMethod]').</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="translated">Il metodo pubblico '{0}' deve essere un metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="translated">I metodi pubblici devono essere metodi di test</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">È consigliabile che solo le classi di test siano contrassegnate come pubbliche in un progetto di test.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">Il tipo pubblico '{0}' deve essere contrassegnato con '[TestClass]' o modificato in 'interno'</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">I tipi di pubblico dovrebbero essere classi di test</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertMessageFormat">
        <source>Use 'Assert.{0}' instead of 'StringAssert.{1}'</source>
        <target state="translated">Usa 'Assert.{0}' invece di 'StringAssert.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertTitle">
        <source>Use 'Assert' instead of 'StringAssert'</source>
        <target state="translated">Usa 'Assert' invece di 'StringAssert'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">La classe di test '{0}' deve essere valida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">La proprietà 'TestContext' deve essere valida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo di test '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">Se non si usa 'ClassCleanupBehavior.EndOfClass', '[ClassCleanup]' verrà eseguito per impostazione predefinita alla fine dell'assembly e non alla fine della classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Usare 'ClassCleanupBehavior.EndOfClass' con '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Usare 'ClassCleanupBehavior.EndOfClass' con '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">Le classi di test, classi contrassegnate con l'attributo '[TestClass]', dovrebbero rispettare il layout seguente per essere considerate valide da MSTest:
- dovrebbe essere 'pubblica' (o 'interna' se l'attributo '[assembly: DiscoverInternals]' è impostato)
- non dovrebbe essere 'statica' (a meno che contenga solo i metodi 'AssemblyInitialize' e/o 'AssemblyCleanup')
- non dovrebbe essere generica.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">Le classi di test dovrebbero avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">La classe di test deve avere almeno un metodo di test o essere 'static' con metodi contrassegnati da '[AssemblyInitialize]' e/o '[AssemblyCleanup]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">La classe di test '{0}' deve avere almeno un metodo di test o essere 'static' con metodi contrassegnati da '[AssemblyInitializate]' e/o '[AssemblyCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">La classe di test deve avere un metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">I metodi contrassegnati con ‘[TestCleanup]’ devono seguire il layout seguente per essere validi:
- Deve essere 'public'
- Non deve essere 'abstract'
- Non deve essere 'async void'
- Non deve essere 'static'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Non deve accettare alcun parametro
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-Se la classe è 'sealed', deve essere contrassegnata con '[TestClass]' (o un attributo derivato).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo TestCleanup '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">Il metodo TestCleanup deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>'TestContext' should be a non-static field or property assigned in constructor or for a property set by MSTest, it should follow the layout:
- it should be 'public' regardless of whether '[assembly: DiscoverInternals]' attribute is set or not.
- it should not be 'static'
- it should have a setter.</source>
        <target state="translated">'TestContext' deve essere una proprietà o un campo non statico assegnato nel costruttore o per un insieme di proprietà da MSTest. Deve seguire il layout:
- deve essere “pubblico” indipendentemente dal fatto che l'attributo “[assembly: DiscoverInternals]” sia impostato o meno.
- non deve essere “statico”
- deve avere un setter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">La proprietà di contesto del test deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">I metodi contrassegnati con ‘[TestInitialize]’ devono seguire il layout seguente per essere validi:
- Deve essere 'public'
- Non deve essere 'abstract'
- Non deve essere 'async void'
- Non deve essere 'static'
- Non deve essere un metodo speciale (finalizzatore, operatore...).
- Non deve essere generico
- Non deve accettare alcun parametro
- il tipo restituito deve essere 'void', 'Task' o 'ValueTask'

Anche il tipo che dichiara questi metodi deve rispettare le regole seguenti:
-Il tipo deve essere una classe
-La classe deve essere 'public' o 'internal' (se il progetto di test usa l'attributo '[DiscoverInternals]')
-La classe non deve essere 'static'
-Se la classe è 'sealed', deve essere contrassegnata con '[TestClass]' (o un attributo derivato).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">La firma del metodo TestInitialize '{0}' non è valida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">Il metodo TestInitialize deve avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should may be generic as long as type parameters can be inferred and argument types are compatible
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">I metodi di test, metodi contrassegnati con l'attributo '[TestMethod]', devono rispettare il layout seguente per essere considerati validi da MSTest:
- devono essere “public” (o “internal” se l'attributo “[assembly: DiscoverInternals]” è impostato)
- non devono essere “static”
- possono essere generici purché i parametri di tipo possano essere dedotti e i tipi di argomento siano compatibili
- non devono essere “abstract”
- il tipo restituito deve essere “void”, “Task” o “ValueTask”
- non devono essere “async void”
- non devono essere un metodo speciale (finalizzatore, operatore...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">I metodi di test dovrebbero avere un layout valido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">I metodi di test non devono essere ignorati (contrassegnati con '[Ignora]').</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">Il metodo di test '{0}' non deve essere ignorato</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">Il metodo di test non deve essere ignorato</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">Il tipo contenente '[TestMethod]' deve essere contrassegnato con '[TestClass]', altrimenti il metodo di test verrà ignorato automaticamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Type '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">Il tipo '{0}' contiene metodi di test e deve essere contrassegnato come '[TestClass]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">Il tipo contenente '[TestMethod]' deve essere contrassegnato con '[TestClass]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">I metodi di fixture di test asincroni non richiedono il suffisso 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">I metodi di test asincroni non richiedono il suffisso 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnusedParameterSuppressorJustification">
        <source>TestContext parameter is required by MSTest for AssemblyInitialize and ClassInitialize methods</source>
        <target state="translated">Il parametro TestContext è necessario a MSTest per i metodi AssemblyInitialize e ClassInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] può essere impostato solo su metodi contrassegnati con [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] può essere impostato solo su metodi contrassegnati con [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassMessageFormat">
        <source>The attribute '{0}' which derives from 'ConditionBaseAttribute' should be used only on classes marked with `TestClassAttribute`</source>
        <target state="translated">L'attributo '{0}' che deriva da 'ConditionBaseAttribute' deve essere utilizzato solo in classi contrassegnate con 'TestClassAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassTitle">
        <source>Use 'ConditionBaseAttribute' on test classes</source>
        <target state="translated">Usa 'ConditionBaseAttribute' nelle classi di test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutDescription">
        <source>Using '[Timeout]' without explicitly setting 'CooperativeCancellation = true' is discouraged. In a future version, cooperative cancellation will become the default behavior. Set 'CooperativeCancellation = true' to opt into the recommended behavior and avoid breaking changes.</source>
        <target state="translated">L'uso di "[Timeout]" senza impostare esplicitamente "CooperativeCancellation = true" è sconsigliato. In una versione futura l'annullamento cooperativo diventerà il comportamento predefinito. Impostare "CooperativeCancellation = true" per acconsentire esplicitamente al comportamento consigliato ed evitare modifiche che causano un'interruzione.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutMessageFormat">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]' to enable cooperative cancellation behavior</source>
        <target state="translated">Usare "CooperativeCancellation = true" con "[Timeout]" per abilitare il comportamento di annullamento cooperativo</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutTitle">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]'</source>
        <target state="translated">Usa "CooperativeCancellation = true" con "[Timeout]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' può essere specificato solo per la classe di test o il metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' può essere specificato solo per la classe di test o il metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsMessageFormat">
        <source>Use 'Assert.ThrowsExactly' instead of 'Assert.ThrowsException'</source>
        <target state="translated">Usare 'Assert.ThrowsExactly' invece di 'Assert.ThrowsException'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsTitle">
        <source>Use newer methods to assert exceptions</source>
        <target state="translated">Usa metodi più recenti per dichiarare le eccezioni</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">Per impostazione predefinita, MSTest esegue i test in sequenza nello stesso assemby, il che può causare gravi limitazioni delle prestazioni. È consigliabile abilitare l'attributo di assembly '[Parallelize]' per eseguire i test in parallelo, o, se l'assembly non è parallelizzabile, usare in modo esplicito l'attributo a livello di assembly '[DoNotParallelize]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Abilitare o disabilitare in modo esplicito la parallelizzazione dei test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Abilitare o disabilitare in modo esplicito la parallelizzazione dei test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsMessageFormat">
        <source>Use 'Assert.{0}' instead of 'Assert.{1}'</source>
        <target state="translated">Usa 'Assert.{0}' invece di 'Assert.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsTitle">
        <source>Use proper 'Assert' methods</source>
        <target state="translated">Usa metodi 'Assert' appropriati</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodMessageFormat">
        <source>An attribute that derives from 'RetryBaseAttribute' can be specified only on a test method</source>
        <target state="translated">È possibile specificare un attributo che deriva da ‘RetryBaseAttribute’ solo in un metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodTitle">
        <source>Use retry attribute on test method</source>
        <target state="translated">Utilizzare l'attributo di ripetizione nel metodo di test</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageTitle">
        <source>TestContext property cannot be accessed in this context</source>
        <target state="translated">Non è possibile accedere alla proprietà TestContext in questo contesto</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageMessageFormat">
        <source>TestContext property '{0}' cannot be accessed in '{1}' method</source>
        <target state="translated">Non è possibile accedere alla proprietà TestContext '{0}' nel metodo '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageDescription">
        <source>Some TestContext properties are only available during test execution and cannot be accessed in assembly initialize, class initialize, class cleanup, or assembly cleanup methods.</source>
        <target state="translated">Alcune proprietà TestContext sono disponibili solo durante l'esecuzione dei test e non è possibile accedervi nei metodi di inizializzazione degli assembly, inizializzazione delle classi, pulizia delle classi o pulizia degli assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementDescription">
        <source>Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</source>
        <target state="new">Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementMessageFormat">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementTitle">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>