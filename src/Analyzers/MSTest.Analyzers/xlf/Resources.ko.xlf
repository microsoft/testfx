<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[AssemblyCleanup]'으로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
-제네릭 클래스에서 선언할 수 없습니다.
- 'public'이어야 합니다. 
- 'static'이어야 합니다.
- 'async void'가 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 매개 변수를 사용하지 않아야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스는 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.
-클래스는 제네릭이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">AssemblyCleanup 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">AssemblyCleanup 메서드에는 올바른 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[AssemblyInitialize]'로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
-제네릭 클래스에서 선언할 수 없습니다.
- 'public'이어야 합니다. 
- 'static'이어야 합니다.
- 'async void'가 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 'TestContext' 형식의 매개 변수를 하나 사용해야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스는 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.
-클래스는 제네릭이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">AssemblyInitialize 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">AssemblyInitialize 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">null을 확인하는 추가 어설션을 추가하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">어설션에서 조건부 액세스 방지</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' 및 'Assert.AreNotSame'에는 필요한 값이 먼저 전달되고 실제 값이 두 번째 인수로 전달되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">어설션 인수는 올바른 순서로 전달되어야 합니다. 'actual' 및 'expected'/'notExpected' 인수가 바뀌었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">어설션 인수는 올바른 순서로 전달되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsException' or 'Assert.ThrowsExceptionAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exeption.</source>
        <target state="translated">예상되는 호출만 예상되는 예외를 throw하도록 보장하는 '[ExpectedException]'보다 'Assert.ThrowsException' 또는 'Assert.ThrowsExceptionAsync'를 사용하는 것이 좋습니다. 또한 Assert API는 더 많은 유연성을 제공하고 예외의 추가 속성을 어설션할 수 있도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsException/ThrowsExceptionAsync' over '[ExpectedException]'</source>
        <target state="translated">'[ExpectedException]'보다 'Assert.ThrowsException/ThrowsExceptionAsync' 권장</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">'[ExpectedException]' 사용 지양</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[ClassCleanup]'으로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
-'InheritanceBehavior' 모드가 설정되지 않은 제네릭 클래스에서 선언할 수 없습니다.
- 'public'이어야 합니다. 
- 'static'이어야 합니다.
- 'async void'가 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 매개 변수를 사용하지 않아야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.
- 클래스가 'abstract'인 경우 'InheritanceBehavior.BeforeEachDerivedClass' 특성 매개 변수를 지정해야 합니다.
- 클래스가 'sealed'인 경우 'InheritanceBehavior.BeforeEachDerivedClass' 특성 매개 변수를 지정하면 안 됩니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스가 'sealed'인 경우 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.
-클래스는 제네릭이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">ClassCleanup 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">ClassCleanup 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[ClassInitialize]'로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
-'InheritanceBehavior' 모드가 설정되지 않은 제네릭 클래스에서 선언할 수 없습니다.
- 'public'이어야 합니다. 
- 'static'이어야 합니다.
- 'async void'가 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 'TestContext' 형식의 매개 변수를 하나 사용해야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.
- 클래스가 'abstract'인 경우 'InheritanceBehavior.BeforeEachDerivedClass' 특성 매개 변수를 지정해야 합니다.
- 클래스가 'sealed'인 경우 'InheritanceBehavior.BeforeEachDerivedClass' 특성 매개 변수를 지정하면 안 됩니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스가 'sealed'인 경우 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.
-클래스는 제네릭이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">ClassInitialize 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">ClassInitialize 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">DataRow 항목이 유효하려면 다음과 같은 레이아웃이 있어야 합니다.
- 테스트 메서드에만 설정해야 합니다.
- 인수 개수가 메서드 인수 개수와 일치해야 합니다.
- 인수 형식이 메서드 인수 형식과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">DataRow 인수 개수는 메서드 매개 변수 개수(생성자 인수: {0}, 메서드 매개 변수: {1})와 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument type should match method parameter type. Mismatches occur at indices: {0}</source>
        <target state="translated">DataRow 인수 형식은 메서드 매개 변수 형식과 일치해야 합니다. 인덱스에서 불일치 발생: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow는 테스트 메서드에서만 설정해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow는 유효해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">부울 어설션을 부정하지 말고 반대 어설션을 사용하세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">부울 어설션 부정하지 마세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">TestContext를 정적 멤버에 저장하지 마세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">TestContext를 정적 멤버에 저장하지 마세요</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">테스트 멤버를 숨기면 테스트 문제(예: NRE)가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' is already exist in the base class</source>
        <target state="translated">멤버 '{0}'이(가) 기본 클래스에 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">섀도 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute'는 테스트 컨텍스트에 영향을 주지 않으며 대신 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'를 사용하려고 한 것 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'를 사용하려고 했나요?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute'는 테스트 메서드에 영향을 주지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">'DynamicData' 항목에는 다음과 같은 레이아웃이 있어야 합니다.
- 테스트 메서드에만 설정해야 합니다.
- 지정된 형식에 멤버를 정의해야 합니다.
- DynamicDataSourceType.Method가 지정된 경우 멤버가 메서드이거나, 그렇지 않으면 속성이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">'[DynamicData]' 데이터 멤버 '{0}.{1}' 서명이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">'[DynamicData]' 표시 이름 메서드 '{0}.{1}' 서명이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">'[DynamicData]' 멤버 '{0}.{1}'은(는) 메서드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">'[DynamicData]' 멤버 '{0}.{1}'을(를) 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">'[DynamicData]'이(가) '{0} 멤버를 참조했습니다.{1}'은(는) 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;' 또는 'IEnumerable&lt;ValueTuple&gt;'을 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">'[DynamicData]'는 테스트 메서드에서만 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should set 'DynamicDataSourceType.Method'</source>
        <target state="translated">'[DynamicData]' 멤버 '{0}.{1}'은(는) 메서드이므로 'DynamicDataSourceType.Method'를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should set 'DynamicDataSourceType.Property'</source>
        <target state="translated">'[DynamicData]' 멤버 '{0}.{1}'은(는) 속성이므로 'DynamicDataSourceType.Property'를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicDta]' member '{0}.{1}' is found more than once</source>
        <target state="translated">'[DynamicDta]' 멤버 '{0}.{1}'을(를) 두 번 이상 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData는 유효해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">항상 실패하는 'Assert.{0}' 어설션 대신 'Assert.Fail'을 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">항상 실패하는 어설션 대신 'Assert.Fail' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">조건이 항상 true인 것으로 알려진 어설션 검토 또는 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">어설션 조건이 항상 true임</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">TestInitialize 메서드보다 생성자 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">TestInitialize 메서드보다 생성자 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">TestCleanup 메서드보다 'Dispose' 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">TestCleanup 메서드보다 'Dispose' 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">'Dispose' 메서드보다 TestCleanup 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">'Dispose' 메서드보다 TestCleanup 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">생성자보다 TestInitialize 메서드 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">생성자보다 TestInitialize 메서드 선호</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="new">Public methods should be test methods (marked with `[TestMethod]`).</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="new">Public method '{0}' should be a test method</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="new">Public methods should be test methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">테스트 프로젝트에서 공용으로 표시된 테스트 클래스만 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">공용 형식 '{0}'은(는) '[TestClass]'로 표시하거나 'internal'로 변경해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">공용 형식은 테스트 클래스여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">테스트 클래스 '{0}'은(는) 유효해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">'TestContext' 속성은 유효해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">테스트 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">'ClassCleanupBehavior.EndOfClass'를 사용하지 않으면 '[ClassCleanup]'은 기본적으로 클래스의 끝이 아니라 어셈블리의 끝에서 실행됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">'[ClassCleanup]'과 함께 'ClassCleanupBehavior.EndOfClass' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">'[ClassCleanup]'과 함께 'ClassCleanupBehavior.EndOfClass' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">'[TestClass]' 특성으로 표시된 클래스인 테스트 클래스는 MSTest에서 유효하다고 간주하려면 다음 레이아웃을 준수해야 합니다.
- 'public'(또는 '[assembly: DiscoverInternals]' 특성이 설정된 경우 'internal')이어야 합니다.
- 'static'이 아니어야 합니다('AssemblyInitialize' 및/또는 'AssemblyCleanup' 메서드만 포함된 경우 제외).
- 제네릭이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">테스트 클래스에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="needs-review-translation">테스트 클래스에는 하나 이상의 테스트 메서드가 있거나 '[AssemblyInitialization]' 및/또는 '[AssemblyCleanup]'으로 표시된 메서드가 있는 'static'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="needs-review-translation">테스트 클래스 '{0}'에 하나 이상의 테스트 메서드가 있거나 '[AssemblyInitialization]' 및/또는 '[AssemblyCleanup]'으로 표시된 메서드가 있는 'static'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">테스트 클래스에는 테스트 메서드가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">'[TestCleanup]'으로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
- 'public'이어야 합니다. 
- 'abstract'가 아니어야 합니다.
- 'async void'가 아니어야 합니다.
- 'static'이 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 매개 변수를 사용하지 않아야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스가 'sealed'인 경우 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">TestCleanup 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">TestCleanup 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>TestContext property should follow the following layout to be valid:
- it should be a property
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be readonly.</source>
        <target state="translated">TestContext 속성은 다음 레이아웃을 따라 유효해야 합니다.
-
속성이어야 합니다.
- 'public'(혹은 '[assembly: DiscoverInternals]' 특성이 설정된 경우 'internal')이어야 합니다.
- 'static'이 아니어야 합니다.
- 읽기 전용이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">테스트 컨텍스트 속성에 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">'[TestInitialize]'로 표시된 메서드가 유효하려면 다음 레이아웃을 따라야 합니다.
- 'public'이어야 합니다. 
- 'abstract'가 아니어야 합니다.
- 'async void'가 아니어야 합니다.
- 'static'이 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 매개 변수를 사용하지 않아야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.

이러한 메서드를 선언하는 형식은 다음 규칙도 준수해야 합니다.
-형식은 클래스여야 합니다.
-클래스는 'public' 또는 'internal'이어야 합니다(테스트 프로젝트에서 '[DiscoverInternals]' 특성을 사용하는 경우).
-클래스는 'static'이 되어서는 안 됩니다.
-클래스가 'sealed'인 경우 '[TestClass]'(또는 파생 특성)로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">TestInitialize 메서드 '{0}' 시그니처가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">TestInitialize 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">'[TestMethod]' 특성으로 표시된 메서드인 테스트 메서드는 MSTest에서 유효한 것으로 간주되도록 다음 레이아웃을 준수해야 합니다.
- 'public'(혹은 '[assembly: DiscoverInternals]' 특성이 설정된 경우 'internal')이어야 합니다.
- 'static'이 아니어야 합니다.
- 제네릭이 아니어야 합니다.
- 'abstract'가 아니어야 합니다.
- 반환 형식은 'void', 'Task' 또는 'ValueTask'여야 합니다.
- 'async void'가 아니어야 합니다.
- 특수 메서드(종료자, 연산자...)가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">테스트 메서드에는 유효한 레이아웃이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">테스트 메서드는 무시하면 안 됩니다('[무시]'로 표시됨).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">테스트 메서드 '{0}'을(를) 무시하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">테스트 메서드는 무시하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type contaning '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">'[TestMethod]'를 포함하는 유형은 '[TestClass]'로 표시되어야 합니다. 그렇지 않으면 테스트 메서드가 자동으로 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Class '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">'{0}' 클래스에는 테스트 메서드가 포함되어 있으며 '[TestClass]'로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">'[TestMethod]'를 포함하는 유형은 '[TestClass]'로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">비동기 테스트 fixture 메서드에는 'Async' 접미사가 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">비동기 테스트 메서드에는 'Async' 접미사가 필요하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}]은(는) [TestMethod] 표시된 메서드에만 설정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}]은(는) [TestMethod] 표시된 메서드에만 설정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]'은(는) 테스트 클래스 또는 테스트 메서드에만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]'은(는) 테스트 클래스 또는 테스트 메서드에만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">기본적으로 MSTest는 동일한 어셈블리 내에서 테스트를 순차적으로 실행하므로 심각한 성능 제한이 발생할 수 있습니다. 어셈블리 특성 '[Parallelize]'가 병렬로 테스트를 실행하도록 설정하거나 어셈블리가 병렬화할 수 없는 것으로 알려진 경우 어셈블리 수준 특성 '[DoNotParallelize]'을(를) 명시적으로 사용하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">테스트 병렬 처리를 명시적으로 사용하거나 사용하지 않도록 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">테스트 병렬 처리를 명시적으로 사용하거나 사용하지 않도록 설정</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>