<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[AssemblyCleanup]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります:
- ジェネリック クラスで宣言することはできません
- 'public' である必要があります
- 'static' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- パラメーターを受け取らないか、'TestContext' 型の 1 つのパラメーターを受け取る必要があります
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
- クラスは '[TestClass]' (または派生属性) でマークする必要があります
- クラスをジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">AssemblyCleanup メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">AssemblyCleanup メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[AssemblyInitialize]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります: 
- ジェネリック クラスで宣言することはできません
- 'public' である必要があります
- 'static' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- 'TestContext' 型のパラメーターを 1 つ受け取る必要があります
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
- クラスは '[TestClass]' (または派生属性) でマークする必要があります
- クラスをジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">AssemblyInitialize メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">AssemblyInitialize メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">追加のアサーションによる null チェックを推奨する</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">アサーションの中で条件付きアクセスの使用を避ける</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">'Assert.AreEqual'、'Assert.AreNotEqual'、'Assert.AreSame'、および 'Assert.AreNotSame' では、必要な値が最初に渡され、実際の値が 2 番目の引数として渡される必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">アサーション引数は正しい順序で渡す必要があります。'actual' 引数と 'expected'/'notExpected' 引数がスワップされました。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">アサーション引数は正しい順序で渡す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesDescription">
        <source>Use 'Assert.AreEqual'/'Assert.AreNotEqual' instead of 'Assert.AreSame'/'Assert.AreNotSame' when comparing value types. Passing a value type to 'Assert.AreSame'/'Assert.AreNotSame' will be boxed (creating a new object). Because 'Assert.AreSame'/'Assert.AreNotSame' does the comparison by reference, 'Assert.AreSame' will fail when boxing happens, and 'Assert.AreNotSame' will always pass.</source>
        <target state="translated">値の型を比較するときは、'Assert.AreSame'/'Assert.AreNotSame' の代わりに 'Assert.AreEqual'/'Assert.AreNotEqual' を使用してください。値の型を 'Assert.AreSame'/'Assert.AreNotSame' に渡すとボックス化されます (新しいオブジェクトが作成されます)。'Assert.AreSame'/'Assert.AreNotSame' は参照による比較を行うため、ボックス化が発生すると 'Assert.AreSame' は失敗し、'Assert.AreNotSame' は常に渡されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesMessageFormat">
        <source>Use '{0}' instead of '{1}' when comparing value types</source>
        <target state="translated">値の型を比較するときに '{1}' の代わりに '{0}' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesTitle">
        <source>Don't use 'Assert.AreSame' or 'Assert.AreNotSame' with value types</source>
        <target state="translated">値型に 'Assert.AreSame' または 'Assert.AreNotSame' を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsExactly' or 'Assert.ThrowsExactlyAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exception.</source>
        <target state="translated">'[ExpectedException]' よりも 'Assert.ThrowsExactly' または 'Assert.ThrowsExactlyAsync' を優先します。これは、予期された呼び出しのみが予期された例外をスローするようにするためです。アサート API もさらに柔軟性が高く、これにより例外の追加プロパティをアサートできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsExactly/ThrowsExactlyAsync' over '[ExpectedException]'</source>
        <target state="translated">'[ExpectedException]' よりも 'Assert.ThrowsExactly/ThrowsExactlyAsync' を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">'[ExpectedException]' を回避する</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeMessageFormat">
        <source>Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</source>
        <target state="new">Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeTitle">
        <source>Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</source>
        <target state="new">Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextDescription">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas. Exceptions that are thrown in this context will be unhandled exceptions. When using VSTest under .NET Framework, they will be silently swallowed. When using Microsoft.Testing.Platform or VSTest under modern .NET, they may crash the process.</source>
        <target state="translated">'async void' メソッド、ローカル関数、またはラムダ内ではアサートしないでください。このコンテキストでスローされる例外は、ハンドルされない例外になります。.NET Frameworkで VSTest を使用すると、警告なしに飲み込まれるようになります。最新の .NET で Microsoft.Testing.Platform または VSTest を使用すると、プロセスがクラッシュする可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextMessageFormat">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas because they may not fail the test</source>
        <target state="translated">'async void' メソッド、ローカル関数、またはラムダはテストに失敗しない可能性があるため、内部でアサートしないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextTitle">
        <source>Do not assert inside 'async void' contexts</source>
        <target state="translated">'async void' コンテキスト内でアサートしないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[ClassCleanup]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります:
- 'InheritanceBehavior' モードが設定されていないと、ジェネリック クラスで宣言できません
- 'public' である必要があります
- 'static' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- パラメーターを受け取らないか、'TestContext' 型の 1 つのパラメーターを受け取る必要があります
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります
- クラスが 'abstract' である場合は 'InheritanceBehavior.BeforeEachDerivedClass' 属性パラメーターを指定する必要があります
- クラスが 'sealed' である場合は 'InheritanceBehavior.BeforeEachDerivedClass' 属性パラメーターを指定しない必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
- クラスが 'sealed' の場合は、'[TestClass]' (または派生属性) でマークする必要があります
- クラスをジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">ClassCleanup メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">ClassCleanup メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[ClassInitialize]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります:
- 'InheritanceBehavior' モードが設定されていないと、ジェネリック クラスで宣言できません
- 'public' である必要があります
- 'static' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- 'TestContext' 型のパラメーターを 1 つ受け取る必要があります
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります
- クラスが 'abstract' である場合は 'InheritanceBehavior.BeforeEachDerivedClass' 属性パラメーターーを指定する必要があります
- クラスが 'sealed' である場合は 'InheritanceBehavior.BeforeEachDerivedClass' 属性パラメーターーを指定しない必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
- クラスが 'sealed' の場合は、'[TestClass]' (または派生属性) でマークする必要があります
- クラスをジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">ClassInitialize メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">ClassInitialize メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">DataRow エントリを有効にするには、次のレイアウトが必要です。
- テスト メソッドにのみ設定する必要があります。
- 引数の数はメソッドの引数の数と一致させる必要があります。
- 引数の型は、メソッドの引数の型と一致させる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">DataRow 引数の数は、メソッド パラメーター数 (コンストラクター引数: {0}、メソッド パラメーター: {1}) と一致させる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument types do not match method parameter types. {0}</source>
        <target state="translated">DataRow 引数の型がメソッド パラメーターの型と一致しません。 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ParameterMismatch">
        <source>Parameter '{0}' expects type '{1}', but the provided value has type '{2}'</source>
        <target state="translated">パラメーター '{0}' の型は '{1}' が想定されていますが、指定された値の型は '{2}' です</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentConflictingTypes">
        <source>Found two conflicting types for generic parameter '{0}'. The conflicting types are '{1}' and '{2}'.</source>
        <target state="translated">ジェネリック パラメーター '{0}' に 2 つの競合する型が見つかりました。競合する型は '{1}' で '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentNotResolved">
        <source>The type of the generic parameter '{0}' could not be inferred.</source>
        <target state="translated">ジェネリック パラメーター '{0}' の型を推論できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow はテスト メソッドにのみ設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow は有効である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">ブール型アサーションを否定しないでください。代わりに、逆のアサーションを使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">ブール型アサーションを否定しない</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">静的メンバーに TestContext を格納しない</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">静的メンバーに TestContext を格納しない</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">シャドウ処理テスト メンバーは、テストの問題 (NRE など) を引き起こす可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' already exists in the base class</source>
        <target state="translated">メンバー '{0}' は既に基本クラスに存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">シャドウ処理を使用しない</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' はテストのコンテキストでは効果がないため、代わりに 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' を使用する必要がある可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' を使用する予定でしたか?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' はテスト メソッドに影響しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowMessageFormat">
        <source>Do not duplicate 'DataRow' attributes. This is usually a copy/paste error. The attribute indices are '{0}' and '{1}'.</source>
        <target state="translated">'DataRow' 属性を複製しないでください。これは通常、コピー/貼り付けエラーです。属性インデックスは '{0}' と '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowTitle">
        <source>Avoid duplicated 'DataRow' entries</source>
        <target state="translated">重複する 'DataRow' エントリを回避する</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">'DynamicData' エントリを有効にするには、次のレイアウトが必要です。
- テスト メソッドにのみ設定する必要があります。
- メンバーは、指定された型で定義する必要があります。
- DynamicDataSourceType.Method が指定されている場合はメンバーはメソッド、それ以外の場合はプロパティである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">'[DynamicData]' データ メンバー '{0}.{1}' の署名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">'[DynamicData]' 表示名メソッド '{0}.{1}' の署名が無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">'[DynamicData]' メンバー '{0}.{1}' はメソッドである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">'[DynamicData]' メンバー '{0}.{1}' が見つかりません</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">'[DynamicData]' の参照されるメンバー '{0}.{1}' は、'IEnumerable&lt;object[]&gt;'、'IEnumerable&lt;Tuple&gt;`、'IEnumerable&lt;ValueTuple&gt;' のいずれかを返す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">'[DynamicData]' はテスト メソッドでのみ設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeField">
        <source>'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Method' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' メンバー '{0}.{1}' はメソッドであるため、'DynamicDataSourceType.AutoDetect' または 'DynamicDataSourceType.Method' を使用する必要があります (自動検出は明示的に指定されていない場合の既定値であり、推奨されます)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyMethodOrField">
        <source>'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyOrMethod">
        <source>'[DynamicData]' member '{0}.{1}' is not a property nor a method. Only properties and methods are supported.</source>
        <target state="translated">メンバー '{0}.{1}' '[DynamicData]' プロパティでもメソッドでもありません。プロパティとメソッドのみがサポートされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Property' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' メンバー '{0}.{1}' はプロパティであるため、'DynamicDataSourceType.AutoDetect' または 'DynamicDataSourceType.Property' を使用する必要があります (自動検出は明示的に指定されていない場合の既定値であり、推奨されます)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicData]' member '{0}.{1}' is found more than once</source>
        <target state="translated">'[DynamicData]' メンバー '{0}.{1}' が複数回見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData は有効である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenDescription">
        <source>When calling async methods that have overloads accepting a CancellationToken parameter, prefer using the overload with TestContext.CancellationTokenSource.Token to enable cooperative cancellation and respect test timeouts.</source>
        <target state="translated">CancellationToken パラメーターを受け入れるオーバーロードを持つ非同期メソッドを呼び出す場合は、TestContext.CancellationTokenSource.Token でオーバーロードを使用して協調的な取り消しを有効にし、テスト タイムアウトを考慮します。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenMessageFormat">
        <source>Consider using the overload that accepts a CancellationToken and pass 'TestContext.CancellationTokenSource.Token'</source>
        <target state="translated">CancellationToken を受け取り、'TestContext.CancellationTokenSource.Token' を渡すオーバーロードの使用を検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenTitle">
        <source>Flow TestContext.CancellationToken to async operations</source>
        <target state="translated">TestContext.CancellationToken を非同期操作にフローする</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidDescription">
        <source>Methods marked with '[GlobalTestInitialize]' or '[GlobalTestCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public'
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">'[GlobalTestInitialize]' または '[GlobalTestCleanup]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります:
- ジェネリック クラスで宣言することはできません
- 'public' である必要があります
- 'static' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- 'TestContext' 型のパラメーターを 1 つ受け取る必要があります
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
-クラスは 'public' である必要があります
- クラスを 'static' にすることはできません
- クラスは '[TestClass]' (または派生属性) でマークする必要があります
- クラスをジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidMessageFormat">
        <source>Global test fixture method '{0}' signature is invalid</source>
        <target state="translated">グローバル テスト フィクスチャ メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidTitle">
        <source>GlobalTestInitialize and GlobalTestCleanup methods should have valid layout</source>
        <target state="translated">GlobalTestInitialize および GlobalTestCleanup メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">常に失敗している 'Assert.{0}' アサートの代わりに 'Assert.Fail' を使用する。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">常に失敗しているアサートの代わりに 'Assert.Fail' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerDescription">
        <source>'DataTestMethodAttribute' is obsolete and provides no additional functionality over 'TestMethodAttribute'. Use 'TestMethodAttribute' for all test methods, including parameterized tests.</source>
        <target state="translated">'DataTestMethodAttribute' は廃止されており、'TestMethodAttribute' に対して追加の機能は提供しません。パラメーター化されたテストを含むすべてのテスト メソッドには、'TestMethodAttribute' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerMessageFormat">
        <source>'DataTestMethod' is obsolete. Use 'TestMethod' instead.</source>
        <target state="translated">'DataTestMethod' は廃止されました。代わりに 'TestMethod' を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerTitle">
        <source>Prefer 'TestMethod' over 'DataTestMethod'</source>
        <target state="translated">'DataTestMethod' よりも 'TestMethod' を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">アサーションの条件が常に TRUE であることが判明しているため、アサーションを確認または削除してください</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">アサーション条件は常に TRUE です</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">TestInitialize メソッドよりもコンストラクターを優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">TestInitialize メソッドよりもコンストラクターを優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">TestCleanup メソッドよりも 'Dispose' を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">TestCleanup メソッドよりも 'Dispose' を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">'Dispose' メソッドよりも TestCleanup を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">'Dispose' メソッドよりも TestCleanup を優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">コンストラクターよりも TestInitialize メソッドを優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">コンストラクターよりも TestInitialize メソッドを優先する</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="translated">パブリック メソッドはテスト メソッドである必要があります ('[TestMethod]' でマーク)。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="translated">パブリック メソッド '{0}' はテスト メソッドである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="translated">パブリック メソッドはテスト メソッドである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">テスト プロジェクトでは、テスト クラスのみをパブリックとしてマークすることをお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">パブリック型 '{0}' は '[TestClass]' でマークするか、'internal' に変更する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">パブリック型はテスト クラスである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertMessageFormat">
        <source>Use 'Assert.{0}' instead of 'StringAssert.{1}'</source>
        <target state="translated">'StringAssert.{1}' の代わりに 'Assert.{0}' を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertTitle">
        <source>Use 'Assert' instead of 'StringAssert'</source>
        <target state="translated">'StringAssert' の代わりに 'Assert' を使用</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">テスト クラス '{0}' は有効である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">プロパティ 'TestContext' は有効である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">テスト メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">'ClassCleanupBehavior.EndOfClass' を使用しない場合、'[ClassCleanup]' は既定でアセンブリの最後に実行され、クラスの最後には実行されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">'ClassCleanupBehavior.EndOfClass' を '[ClassCleanup]' と共に使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">'ClassCleanupBehavior.EndOfClass' を '[ClassCleanup]' と共に使用してください</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">テスト クラス ('[TestClass]' 属性でマークされたクラス) は、MSTest によって有効と見なされるように、次のレイアウトを考慮する必要があります:
- 'public' である必要があります ('[assembly: DiscoverInternals]' 属性が設定されている場合は 'internal' である必要があります)
- 'static' にすることはできません ('AssemblyInitialize' メソッドおよび/または 'AssemblyCleanup' メソッドのみが含まれる場合は除きます)
- ジェネリックにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">テスト クラスには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">テスト クラスには、少なくとも 1 つのテスト メソッドがあるか、'[AssemblyInitialize]' または '[AssemblyCleanup]' によってマークされたメソッドを含む 'static' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">テスト クラス '{0}' には、少なくとも 1 つのテスト メソッドがあるか、'[AssemblyInitialize]' または '[AssemblyCleanup]' によってマークされたメソッドを含む 'static' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">テスト クラスにはテスト メソッドが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">'[TestCleanup]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります: 
- 'public' である必要があります
- 'abstract' にすることはできません
- 'async void' にすることはできません
- 'static' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- パラメーターを受け取ることができません
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
-クラスが 'sealed' の場合は、'[TestClass]' (または派生属性) でマークする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">TestCleanup メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">TestCleanup メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>'TestContext' should be a non-static field or property assigned in constructor or for a property set by MSTest, it should follow the layout:
- it should be 'public' regardless of whether '[assembly: DiscoverInternals]' attribute is set or not.
- it should not be 'static'
- it should have a setter.</source>
        <target state="translated">'TestContext' は、コンストラクターまたは MSTest によって設定されたプロパティに割り当てられた非静的フィールドまたはプロパティである必要があります。レイアウトに従う必要があります:
- '[assembly: DiscoverInternals]' 属性が設定されているかどうかに関係なく、'public' である必要があります。
- 'static' にすることはできません
- セッターが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">テスト コンテキスト プロパティには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">'[TestInitialize]' でマークされたメソッドを有効にするには、次のレイアウトに従う必要があります: 
- 'public' である必要があります
- 'abstract' にすることはできません
- 'async void' にすることはできません
- 'static' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。
- ジェネリックにすることはできません
- パラメーターを受け取ることができません
- 戻り値の型が 'void'、'Task'、または 'ValueTask' である必要があります

これらのメソッドを宣言する型も、次の規則に従う必要があります:
- 型はクラスである必要があります
- クラスは 'public' または 'internal' である必要があります (テスト プロジェクトが '[DiscoverInternals]' 属性を使用している場合)
- クラスを 'static' にすることはできません
-クラスが 'sealed' の場合は、'[TestClass]' (または派生属性) でマークする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">TestInitialize メソッド '{0}' シグネチャが無効です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">TestInitialize メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should may be generic as long as type parameters can be inferred and argument types are compatible
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">'[TestMethod]' 属性でマークされたテスト メソッドは、MSTest によって有効と見なされるように、次のレイアウトを考慮する必要があります:
- 'public' である必要があります ('[assembly: DiscoverInternals]' 属性が設定されている場合は 'internal' である必要があります)
- 'static' にすることはできません
- 型パラメーターを推論でき、引数の型が互換性がある限り、ジェネリックである必要があります
- 'abstract' にすることはできません
- 戻り値の型は 'void'、'Task'、または 'ValueTask' である必要があります
- 'async void' にすることはできません
- 特殊なメソッド (ファイナライザー、演算子...) にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">テスト メソッドには有効なレイアウトが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">テスト メソッドを無視することはできません ('[Ignore]' でマークされます)。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">テスト メソッド '{0}' を無視することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">テスト メソッドを無視することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">'[TestMethod]' を含む型は '[TestClass]' でマークする必要があります。そうしないとテスト メソッドは暗黙的に無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Type '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">型 '{0}' にはテスト メソッドが含まれており、'[TestClass]' でマークする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">'[TestMethod]' を含む型は '[TestClass]' でマークする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">非同期テスト フィクスチャには 'Async' サフィックスは不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">非同期テスト メソッドには 'Async' サフィックスは不要です</target>
        <note />
      </trans-unit>
      <trans-unit id="UnusedParameterSuppressorJustification">
        <source>TestContext parameter is required by MSTest for AssemblyInitialize and ClassInitialize methods</source>
        <target state="translated">AssemblyInitialize メソッドと ClassInitialize メソッドに対する MSTest には TestContext パラメーターが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] は、[TestMethod] でマークされたメソッドにのみ設定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] は、[TestMethod] でマークされたメソッドにのみ設定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassMessageFormat">
        <source>The attribute '{0}' which derives from 'ConditionBaseAttribute' should be used only on classes marked with `TestClassAttribute`</source>
        <target state="translated">'ConditionBaseAttribute' から派生する属性 '{0}' は、'TestClassAttribute' でマークされたクラスでのみ使用する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassTitle">
        <source>Use 'ConditionBaseAttribute' on test classes</source>
        <target state="translated">テスト クラスで 'ConditionBaseAttribute' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutDescription">
        <source>Using '[Timeout]' without explicitly setting 'CooperativeCancellation = true' is discouraged. In a future version, cooperative cancellation will become the default behavior. Set 'CooperativeCancellation = true' to opt into the recommended behavior and avoid breaking changes.</source>
        <target state="translated">'CooperativeCancellation = true' を明示的にを設定せずに '[Timeout]' を使用することは推奨されません。将来のバージョンでは、協調的キャンセルが既定の動作になります。推奨される動作をオプトインし、破壊的な変更を避けるために、'CooperativeCancellation = true' を設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutMessageFormat">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]' to enable cooperative cancellation behavior</source>
        <target state="translated">'[Timeout]' と共に 'CooperativeCancellation = true' を使用して、協調的キャンセルの動作を有効にします</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutTitle">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]'</source>
        <target state="translated">'[Timeout]' と共に 'CooperativeCancellation = true' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' は、テスト クラスまたはテスト メソッドでのみ指定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' は、テスト クラスまたはテスト メソッドでのみ指定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsMessageFormat">
        <source>Use 'Assert.ThrowsExactly' instead of 'Assert.ThrowsException'</source>
        <target state="translated">'Assert.ThrowsException' の代わりに 'Assert.ThrowsExactly' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsTitle">
        <source>Use newer methods to assert exceptions</source>
        <target state="translated">新しいメソッドを使用して例外をアサートする</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">既定では、MSTest は同じアセンブリ内でテストを順番に実行するため、重大なパフォーマンス制限が生じる可能性があります。アセンブリ属性 '[Parallelize]' を有効にして並列でテストを実行するか、アセンブリが並列化できないことがわかっている場合は、アセンブリ レベル属性 '[DoNotParallelize]' を明示的に使用することをお勧めします。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">テストの並列化を明示的に有効または無効にする</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">テストの並列化を明示的に有効または無効にする</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsMessageFormat">
        <source>Use 'Assert.{0}' instead of 'Assert.{1}'</source>
        <target state="translated">'Assert.{1}' の代わりに 'Assert.{0}' を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsTitle">
        <source>Use proper 'Assert' methods</source>
        <target state="translated">適切な 'Assert' メソッドを使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodMessageFormat">
        <source>An attribute that derives from 'RetryBaseAttribute' can be specified only on a test method</source>
        <target state="translated">'RetryBaseAttribute' から派生する属性は、テスト メソッドでのみ指定できます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodTitle">
        <source>Use retry attribute on test method</source>
        <target state="translated">テスト メソッドで retry 属性を使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageTitle">
        <source>TestContext property cannot be accessed in this context</source>
        <target state="translated">このコンテキストでは TestContext プロパティにアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageMessageFormat">
        <source>TestContext property '{0}' cannot be accessed in '{1}' method</source>
        <target state="translated">TestContext プロパティ '{0}' に '{1}' メソッドでアクセスできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageDescription">
        <source>Some TestContext properties are only available during test execution and cannot be accessed in assembly initialize, class initialize, class cleanup, or assembly cleanup methods.</source>
        <target state="translated">TestContext プロパティの一部はテストの実行中にのみ使用でき、assenbly initialize、class initialize、class cleanup、または assembly cleanup メソッドではアクセスできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementDescription">
        <source>Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</source>
        <target state="new">Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementMessageFormat">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementTitle">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>