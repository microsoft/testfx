<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with [AssemblyCleanup] should follow the following layout to be valid:
- be 'public' 
- be 'static'
- not be generic nor defined on a generic class
- not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes marquées par [AssemblyCleanup] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- être "statique"
- ne pas être générique ni défini sur une classe générique
- ne pas prendre de paramètre
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode AssemblyCleanup '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">La méthode AssemblyCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with [AssemblyInitialize] should follow the following layout to be valid:
- be 'public' 
- be 'static'
- not be generic nor be defined on a generic class
- take a single parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes marquées par [AssemblyInitialize] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- être "statique"
- ne pas être générique ni être défini sur une classe générique
- prendre un paramètre unique de type 'TestContext'
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode AssemblyInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">La méthode AssemblyInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">Préférer l’ajout d’une assertion supplémentaire qui recherche la valeur null</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">Éviter l’accès conditionnel dans les assertions</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">« Assert.AreEqual », « Assert.AreNotEqual », « Assert.AreSame » et « Assert.AreNotSame » supposent que la valeur attendue soit passée en premier et que la valeur réelle soit passée en tant que deuxième argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">Les arguments d’assertion doivent être passés dans l’ordre approprié. Les arguments « actual » et « expected »/« notExpected » ont été permutés.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">Les arguments d’assertion doivent être passés dans l’ordre approprié</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsException' or 'Assert.ThrowsExceptionAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exeption.</source>
        <target state="translated">Préférez « Assert.ThrowsException » ou « Assert.ThrowsExceptionAsync » à « [ExpectedException] », car cela assure que seul l’appel attendu lève l’exception attendue. Les API d’assertion offrent également plus de flexibilité et vous permettent de déclarer des propriétés supplémentaires de l’exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsException/ThrowsExceptionAsync' over '[ExpectedException]'</source>
        <target state="translated">Préférer « Assert.ThrowsException/ThrowsExceptionAsync » à « [ExpectedException] »</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Éviter « [ExpectedException] »</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with [ClassCleanup] should follow the following layout to be valid:
- be 'public' 
- not be 'static'
- not be generic nor defined on a generic class
- not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...)
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'.</source>
        <target state="needs-review-translation">Les méthodes marquées par [ClassCleanup] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- ne pas être 'statique'
- ne pas être générique ni défini sur une classe générique
- ne pas prendre de paramètre
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode ClassCleanup '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">La méthode ClassCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with [ClassInitialize] should follow the following layout to be valid:
- be 'public' 
- be 'static'
- not be generic nor be defined on a generic class
- take a single parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...)
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'.</source>
        <target state="needs-review-translation">Les méthodes marquées par [ClassInitialize] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- être "statique"
- ne pas être générique ni être défini sur une classe générique
- prendre un paramètre unique de type 'TestContext'
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode ClassInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">La méthode ClassInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">L’entrée DataRow doit avoir la disposition suivante pour être valide :
– ne doit être défini que sur une méthode de test;
- le nombre d’arguments doit correspondre au nombre d’arguments de la méthode ;
– le type d’arguments doit correspondre au type d’arguments de la méthode.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">Le nombre d’arguments DataRow doit correspondre au nombre de paramètres de méthode (arguments du constructeur : {0}, paramètres de méthode : {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument type should match method parameter type. Mismatches occur at indices: {0}</source>
        <target state="translated">Le type d’argument DataRow doit correspondre au type de paramètre de la méthode. Des incompatibilités se produisent aux index :{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow ne doit être défini que sur une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow doit être valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">Ne pas annuler les assertions booléennes, mais utiliser l'assertion opposée</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">Ne pas annuler les assertions booléennes</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Ne pas stocker TestContext dans un membre statique</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Ne pas stocker TestContext dans un membre statique</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">« System.ComponentModel.DescriptionAttribute » n’a aucun effet dans le contexte des tests et vous vouliez probablement utiliser « Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute » à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">Vous vouliez utiliser « Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute » ?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">« System.ComponentModel.DescriptionAttribute » n’a aucun effet sur les méthodes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">Utilisez « Assert.Fail » à la place d’une assertion « Assert.{0} » toujours en échec</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">Utilisez « Assert.Fail » à la place d’une assertion toujours en échec</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">Vérifier ou supprimer l’assertion, car sa condition est connue pour être toujours vraie</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">La condition d’assertion est toujours vraie</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Préférer les constructeurs aux méthodes TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Préférer les constructeurs aux méthodes TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Préférer « Dispose » aux méthodes TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Préférer « Dispose » aux méthodes TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Préférer TestCleanup aux méthodes « Dispose »</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Préférer TestCleanup aux méthodes « Dispose »</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Préférer les méthodes TestInitialize aux constructeurs</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Préférer les méthodes TestInitialize aux constructeurs</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="new">Public methods should be test methods (marked with `[TestMethod]`).</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="new">Public method '{0}' should be a test method</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="new">Public methods should be test methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">C’est considéré comme une bonne pratique d’avoir uniquement des classes de test marquées comme publiques dans un projet de test.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">Le type public « {0} » doit être marqué avec « [TestClass] » ou remplacé par « interne »</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">Les types publics doivent être des classes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">Sans utiliser 'ClassCleanupBehavior.EndOfClass', '[ClassCleanup]' sera exécuté par défaut à la fin de l’assemblée et non à la fin de la classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Utilisez 'ClassCleanupBehavior.EndOfClass' avec '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Utilisez 'ClassCleanupBehavior.EndOfClass' avec '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">Les classes de test, à savoir les classes marquées par l’attribut « [TestClass] », doivent respecter la disposition suivante pour être considérées comme valides par MSTest :
– Elle doit être « publique » (ou « interne » si l’attribut « [assembly : DiscoverInternals] » est défini)
– Elle ne doit pas être « statique » (sauf si elle ne contient que des méthodes « AssemblyInitialize » et/ou « AssemblyCleanup »)
– Elle ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_NotStatic">
        <source>Test class '{0}' should not be 'static'</source>
        <target state="translated">La classe de test « {0} » ne doit pas être « static »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_Public">
        <source>Test class '{0}' should be 'public'</source>
        <target state="translated">La classe de test « {0} » doit être « public »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test class '{0}' should be 'public' or 'internal'</source>
        <target state="translated">La classe de test « {0} » doit être « public » ou « internal »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">Les classes de test doivent avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">La classe de test doit avoir au moins une méthode de test ou être « statique » avec la ou les méthodes marquées par « [AssemblyInitialization] » et/ou « [AssemblyCleanup] ».</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">La classe de test « {0} » doit avoir au moins une méthode de test ou être « statique » avec des méthodes marquées par « [AssemblyInitialization] » et/ou « [AssemblyCleanup] »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">La classe de test doit avoir une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with [TestCleanup] should follow the following layout to be valid:
- be 'public' 
- not be 'static'
- not be generic or be defined on a generic class
- not be 'abstract'
- not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes marquées par [TestCleanup] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- ne pas être 'statique'
- ne pas être générique ou être défini sur une classe générique
- ne pas être 'abstract'
- ne pas prendre de paramètre
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature «{0}» de la méthode TestCleanup n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">La méthode TestCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>TestContext property should follow the following layout to be valid:
- it should be a property
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be readonly.</source>
        <target state="translated">La propriété TestContext doit suivre la disposition suivante pour être valide : 
– il doit s’agir d’une propriété
– il doit être "public" (ou "interne" si l'attribut "[assembly: DiscoverInternals]" est défini)
– ça ne devrait pas être "statique"
– il ne doit pas être en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotField">
        <source>Member 'TestContext' should be a property and not a field</source>
        <target state="translated">Le membre 'TestContext' doit être une propriété et non un champ</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotReadonly">
        <source>Property 'TestContext' should be settable</source>
        <target state="translated">La propriété 'TestContext' doit être configurable</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotStatic">
        <source>Property 'TestContext' should not be 'static'</source>
        <target state="translated">La propriété 'TestContext' ne doit pas être 'static'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_Public">
        <source>Property 'TestContext' should be 'public'</source>
        <target state="translated">La propriété 'TestContext' doit être 'public'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_PublicOrInternal">
        <source>Property 'TestContext' should be 'public' or 'internal'</source>
        <target state="translated">La propriété 'TestContext' doit être 'public' ou 'internal'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">La propriété de contexte de test doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with [TestInitialize] should follow the following layout to be valid:
- be 'public' 
- not be 'static'
- not be generic nor defined on a generic class
- not be 'abstract'
- not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- not be 'async void'
- not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes marquées par [TestInitialize] doivent respecter le schéma suivant pour être valides : 
- être « public » 
- ne pas être 'statique'
- ne pas être générique ni défini sur une classe générique
- ne pas être 'abstract'
- ne pas prendre de paramètre
- le type de retour doit être « void », « Task » ou « ValueTask »
- ne pas être "vide asynchrone"
- ne pas être une méthode particulière (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode TestInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">La méthode TestInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes de test, qui sont des méthodes marquées avec l’attribut « [TestMethod] », doivent respecter la disposition suivante pour être considérées comme valides par MSTest :
– il doit être « public » (ou « interne » si l’attribut « [assembly : DiscoverInternals] » est défini)
– le texte ne doit pas être « statique »
– il ne doit pas être générique
– il ne doit pas être « abstract »
- doit être « void » ou renvoyer « Task » ou « ValueTask »
– il ne doit pas être « async void »
- il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAbstract">
        <source>Test method '{0}' should not be 'abstract'</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être « abstract »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAsyncVoid">
        <source>Test method '{0}' should not be 'async void'</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être « async void »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotGeneric">
        <source>Test method '{0}' should not be generic</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être générique</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotStatic">
        <source>Test method '{0}' should not be 'static'</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être « static »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Ordinary">
        <source>Test method '{0}' should be an 'ordinary' method</source>
        <target state="translated">La méthode de test « {0} » doit être une méthode « ordinary »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Public">
        <source>Test method '{0}' should be 'public'</source>
        <target state="translated">La méthode de test « {0} » doit être « public »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test method '{0}' should be 'public' or 'internal'</source>
        <target state="translated">La méthode de test « {0} » doit être « public » ou « internal »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_ReturnType">
        <source>Test method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">La méthode de test « {0} » doit retourner « void », « Task » ou « Value Task »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">Les méthodes de test doivent avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">Les méthodes de test ne doivent pas être ignorées (marquées avec « [Ignorer] »).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être ignorée</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">La méthode de test doit être ignorée</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type contaning '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">Le type contenant « [TestMethod] » doit être marqué avec « [TestClass] », sans quoi la méthode de test sera ignorée silencieusement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Class '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">La classe « {0} » contient des méthodes de test et doit être marquée avec « [TestClass] »</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">Le type contenant « [TestMethod] » doit être marqué avec « [TestClass] »</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">Les méthodes de fixture de test asynchrones ne nécessitent pas le suffixe « Async »</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">Les méthodes de test asynchrones ne nécessitent pas le suffixe 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] ne peut être défini que sur les méthodes marquées avec [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] ne peut être défini que sur les méthodes marquées avec [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">Par défaut, MSTest exécute des tests dans la même assembly de façon séquentielle, ce qui peut entraîner de graves limitations de performances. Il est recommandé d’activer l’attribut d’assemblée « [Parallelize] » pour exécuter des tests en parallèle ou, si l’assemblée est connu pour ne pas être parallélisable, d’utiliser explicitement l’attribut de niveau assemblée « [DoNotParallelize] ».</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Activer ou désactiver explicitement la parallélisation des tests</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Activer ou désactiver explicitement la parallélisation des tests</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>