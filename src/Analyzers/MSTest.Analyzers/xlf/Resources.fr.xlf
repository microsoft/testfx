<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Les méthodes marquées par « [AssemblyCleanup] » doivent respecter le schéma suivant pour être valides : 
-il ne peut pas être déclarée dans une classe générique
– il doit être « public »
– il doit être « static »
– il ne doit pas être « async void »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
- il ne doit pas prendre de paramètre ou prendre un seul paramètre de type 'TestContext'
- le type de retour doit être « vide », « Task » ou « ValueTask »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être» ’static »
-La classe doit être marquée par « [TestClass] » (ou un attribut dérivé)
-la classe ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode AssemblyCleanup '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">La méthode AssemblyCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Les méthodes marquées par « [AssemblyInitialize] » doivent respecter le schéma suivant pour être valides :
-il ne peut pas être déclarée dans une classe générique
– il doit être « public »
– il doit être « static »
– il ne doit pas être « async void »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
– il doit prendre un paramètre de type « TestContext »
- le type de retour doit être « vide », « Task » ou « ValueTask »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être» ’static »
-La classe doit être marquée par « [TestClass] » (ou un attribut dérivé).
-la classe ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode AssemblyInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">La méthode AssemblyInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">Préférer l’ajout d’une assertion supplémentaire qui recherche la valeur null</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">Éviter l’accès conditionnel dans les assertions</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">« Assert.AreEqual », « Assert.AreNotEqual », « Assert.AreSame » et « Assert.AreNotSame » supposent que la valeur attendue soit passée en premier et que la valeur réelle soit passée en tant que deuxième argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">Les arguments d’assertion doivent être passés dans l’ordre approprié. Les arguments « actual » et « expected »/« notExpected » ont été permutés.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">Les arguments d’assertion doivent être passés dans l’ordre approprié</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesDescription">
        <source>Use 'Assert.AreEqual'/'Assert.AreNotEqual' instead of 'Assert.AreSame'/'Assert.AreNotSame' when comparing value types. Passing a value type to 'Assert.AreSame'/'Assert.AreNotSame' will be boxed (creating a new object). Because 'Assert.AreSame'/'Assert.AreNotSame' does the comparison by reference, 'Assert.AreSame' will fail when boxing happens, and 'Assert.AreNotSame' will always pass.</source>
        <target state="translated">Utilisez 'Assert.AreEqual'/'Assert.AreNotEqual' à la place de 'Assert.AreSame'/'Assert.AreNotSame' lors de la comparaison des types valeur. Le passage d’un type valeur à 'Assert.AreSame'/'Assert.AreNotSame' est encadré (création d’un objet). Dans la mesure où 'Assert.AreSame'/'Assert.AreNotSame' effectue la comparaison par référence, 'Assert.AreSame' échoue quand le boxing se produit et 'Assert.AreNotSame' passe toujours.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesMessageFormat">
        <source>Use '{0}' instead of '{1}' when comparing value types</source>
        <target state="translated">Utiliser '{0}' au lieu de '{1}' lors de la comparaison de types valeur</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesTitle">
        <source>Don't use 'Assert.AreSame' or 'Assert.AreNotSame' with value types</source>
        <target state="translated">N’utilisez pas 'Assert.AreSame' ou 'Assert.AreNotSame' avec des types valeur</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsExactly' or 'Assert.ThrowsExactlyAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exception.</source>
        <target state="translated">Préférez « Assert.ThrowsExactly » ou « Assert.ThrowsExactlyAsync » à « [ExpectedException] », car il garantit que seul l’appel attendu lève l’exception attendue. Les API d’assertion offrent également plus de flexibilité et vous permettent de déclarer des propriétés supplémentaires de l’exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsExactly/ThrowsExactlyAsync' over '[ExpectedException]'</source>
        <target state="translated">Préférez « Assert.ThrowsExactly/ThrowsExactlyAsync » à « [ExpectedException] »</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Éviter « [ExpectedException] »</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeMessageFormat">
        <source>Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</source>
        <target state="new">Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeTitle">
        <source>Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</source>
        <target state="new">Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextDescription">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas. Exceptions that are thrown in this context will be unhandled exceptions. When using VSTest under .NET Framework, they will be silently swallowed. When using Microsoft.Testing.Platform or VSTest under modern .NET, they may crash the process.</source>
        <target state="translated">N’effectuez pas d’assertion dans les méthodes 'async void', les fonctions locales ou les expressions lambda. Les exceptions levées dans ce contexte seront des exceptions non gérées. Lors de l’utilisation de VSTest sous .NET Framework, ils sont silencieusement coupés. Quand vous utilisez Microsoft.Testing.Platform ou VSTest sous .NET moderne, ils peuvent bloquer le processus.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextMessageFormat">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas because they may not fail the test</source>
        <target state="translated">Ne pas effectuer d’assertion dans les méthodes 'async void', les fonctions locales ou les expressions lambda, car elles ne peuvent pas faire échouer le test</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextTitle">
        <source>Do not assert inside 'async void' contexts</source>
        <target state="translated">Ne pas déclarer dans les contextes 'async void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Les méthodes marquées par « [ClassCleanup] » doivent respecter le schéma suivant pour être valides : 
-il ne peut pas être déclarée dans une classe générique si le mode ’InheritanceBehavior’ n’est pas activé
– il doit être « public »
– il doit être « static »
– il ne doit pas être « async void »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
- il ne doit pas prendre de paramètre ou prendre un seul paramètre de type 'TestContext'
- le type de retour doit être « vide », « Task » ou « ValueTask »
- « InheritanceBehavior.BeforeEachDerivedClass » doit être spécifié si la classe est « abstract »
-Le paramètre d’attribut « InheritanceBehavior.BeforeEachDerivedClass » ne doit pas être spécifié si la classe est « scellée »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être « static »
-Si la classe est « sealed », elle doit être marquée avec « [TestClass] » (ou un attribut dérivé)
-la classe ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode ClassCleanup '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">La méthode ClassCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Les méthodes marquées par « [ClassInitialize] » doivent respecter le schéma suivant pour être valides : 
-il ne peut pas être déclarée dans une classe générique si le mode ’InheritanceBehavior’ n’est pas activé.
– il doit être « public »
– il doit être « static »
– il ne doit pas être « async void »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
– il doit prendre un paramètre de type « TestContext »
- le type de retour doit être « vide », « Task » ou « ValueTask »
- « InheritanceBehavior.BeforeEachDerivedClass » doit être spécifié si la classe est « abstract »
-Le paramètre d’attribut « InheritanceBehavior.BeforeEachDerivedClass » ne doit pas être spécifié si la classe est « scellée »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être « static »
-Si la classe est « sealed », elle doit être marquée avec « [TestClass] » (ou un attribut dérivé).
-la classe ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode ClassInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">La méthode ClassInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">L’entrée DataRow doit avoir la disposition suivante pour être valide :
– ne doit être défini que sur une méthode de test;
- le nombre d’arguments doit correspondre au nombre d’arguments de la méthode ;
– le type d’arguments doit correspondre au type d’arguments de la méthode.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">Le nombre d’arguments DataRow doit correspondre au nombre de paramètres de méthode (arguments du constructeur : {0}, paramètres de méthode : {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument types do not match method parameter types. {0}</source>
        <target state="translated">Les types d’argument DataRow ne correspondent pas aux types de paramètre de la méthode. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ParameterMismatch">
        <source>Parameter '{0}' expects type '{1}', but the provided value has type '{2}'</source>
        <target state="translated">Le paramètre « {0} » attend un type « {1} », mais la valeur fournie a un type « {2} »</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentConflictingTypes">
        <source>Found two conflicting types for generic parameter '{0}'. The conflicting types are '{1}' and '{2}'.</source>
        <target state="translated">Deux types en conflit ont été trouvés pour le paramètre générique '{0}'. Les types en conflit sont '{1}' et '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentNotResolved">
        <source>The type of the generic parameter '{0}' could not be inferred.</source>
        <target state="translated">Impossible de déduire le type du paramètre générique '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow ne doit être défini que sur une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow doit être valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">Ne pas annuler les assertions booléennes, mais utiliser l'assertion opposée</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">Ne pas annuler les assertions booléennes</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Ne pas stocker TestContext dans un membre statique</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Ne pas stocker TestContext dans un membre statique</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">Le cliché instantané des membres de test peut entraîner des problèmes de test (tels que NRE).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' already exists in the base class</source>
        <target state="translated">Le membre « {0} » existe déjà dans la classe de base</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">Ne pas utiliser le cliché instantané</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">« System.ComponentModel.DescriptionAttribute » n’a aucun effet dans le contexte des tests et vous vouliez probablement utiliser « Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute » à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">Vous vouliez utiliser « Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute » ?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">« System.ComponentModel.DescriptionAttribute » n’a aucun effet sur les méthodes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowMessageFormat">
        <source>Do not duplicate 'DataRow' attributes. This is usually a copy/paste error. The attribute indices are '{0}' and '{1}'.</source>
        <target state="translated">Ne dupliquez pas les attributs 'DataRow'. Il s'agit généralement d'une erreur de copier/coller. Les indices des attributs sont '{0}' et '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowTitle">
        <source>Avoid duplicated 'DataRow' entries</source>
        <target state="translated">Évitez les entrées « DataRow » dupliquées</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">L’entrée 'DynamicData' doit avoir la disposition suivante pour être valide :
– ne doit être défini que sur une méthode de test ;
- le membre doit être défini sur le type spécifié ;
- le membre doit être une méthode si DynamicDataSourceType.Method est spécifié ou une propriété dans le cas contraire.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">Membre de données '[DynamicData]' '{0}.{1}' signature n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">'[DynamicData]' méthode de nom d’affichage '{0}.{1}' signature n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">Membre '[DynamicData]' '{0}.{1}' doit être une méthode</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">Membre '[DynamicData]' '{0}.{1}' est introuvable</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">Le membre référencé « [DynamicData] '{0}.{1}' doit renvoyer « IEnumerable&lt;object[]&gt; », « IEnumerable&lt;Tuple&gt; » ou « IEnumerable&lt;ValueTuple&gt; »</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">'[DynamicData]' ne doit être défini que sur une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeField">
        <source>'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Method' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membre ' {0}.{1}' est une méthode, vous devez donc utiliser 'DynamicDataSourceType.AutoDetect' ou 'DynamicDataSourceType.Method' (la détection automatique est la valeur par défaut quand elle n’est pas spécifiée explicitement et est recommandée)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyMethodOrField">
        <source>'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyOrMethod">
        <source>'[DynamicData]' member '{0}.{1}' is not a property nor a method. Only properties and methods are supported.</source>
        <target state="translated">'[DynamicData]' membre '{0}.{1}' n’est ni une propriété ni une méthode. Seules les propriétés et les méthodes sont prises en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Property' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membre « {0}.{1} » est une propriété, vous devez donc utiliser « DynamicDataSourceType.AutoDetect » ou « DynamicDataSourceType.Property » (la détection automatique est la valeur par défaut lorsqu’elle n’est pas spécifiée explicitement et est recommandée)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicData]' member '{0}.{1}' is found more than once</source>
        <target state="translated">'[DynamicData]' membre ' {0}.{1}' est trouvé plusieurs fois</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData doit être valide</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenDescription">
        <source>When calling async methods that have overloads accepting a CancellationToken parameter, prefer using the overload with TestContext.CancellationTokenSource.Token to enable cooperative cancellation and respect test timeouts.</source>
        <target state="translated">Lors de l’appel de méthodes asynchrones qui ont des surcharges acceptant un paramètre CancellationToken, préférez utiliser la surcharge avec TestContext.CancellationTokenSource.Token pour activer l’annulation collaborative et respecter les délais d’expiration des tests.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenMessageFormat">
        <source>Consider using the overload that accepts a CancellationToken and pass 'TestContext.CancellationTokenSource.Token'</source>
        <target state="translated">Envisagez d’utiliser la surcharge qui accepte un CancellationToken et passe « TestContext.CancellationTokenSource.Token »</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenTitle">
        <source>Flow TestContext.CancellationToken to async operations</source>
        <target state="translated">Transmettez TestContext.CancellationToken aux opérations asynchrones</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidDescription">
        <source>Methods marked with '[GlobalTestInitialize]' or '[GlobalTestCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public'
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Les méthodes marquées par « [GlobalTestInitialize] » ou « [GlobalTestCleanup] » doivent respecter le schéma suivant pour être valides :
- elle ne peut pas être déclarée dans une classe générique
– elle doit être « public »
– elle doit être « static »
– elle ne doit pas être « async void »
– il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– elle ne doit pas être générique
– il doit prendre un paramètre de type « TestContext »
- le type de retour doit être « void », « Task » ou « ValueTask »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
- le type doit être une classe
- la classe doit être « public » 
- la classe ne doit pas être « static »
- la classe doit être marquée par « [TestClass] » (ou un attribut dérivé)
- la classe ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidMessageFormat">
        <source>Global test fixture method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode « {0} » de la fixture de test globale est invalide</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidTitle">
        <source>GlobalTestInitialize and GlobalTestCleanup methods should have valid layout</source>
        <target state="translated">Les méthodes GlobalTestInitialize et GlobalTestCleanup doivent avoir une structure valide</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">Utilisez « Assert.Fail » à la place d’une assertion « Assert.{0} » toujours en échec</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">Utilisez « Assert.Fail » à la place d’une assertion toujours en échec</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerDescription">
        <source>'DataTestMethodAttribute' is obsolete and provides no additional functionality over 'TestMethodAttribute'. Use 'TestMethodAttribute' for all test methods, including parameterized tests.</source>
        <target state="translated">« DataTestMethodAttribute » est obsolète et ne fournit aucune fonctionnalité supplémentaire par rapport à « TestMethodAttribute ». Utiliser « TestMethodAttribute » pour toutes les méthodes de test, y compris les tests paramétrés.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerMessageFormat">
        <source>'DataTestMethod' is obsolete. Use 'TestMethod' instead.</source>
        <target state="translated">« DataTestMethod » est obsolète. Utilisez « TestMethod » à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerTitle">
        <source>Prefer 'TestMethod' over 'DataTestMethod'</source>
        <target state="translated">Préférer « TestMethod » à « DataTestMethod »</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">Vérifier ou supprimer l’assertion, car sa condition est connue pour être toujours vraie</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">La condition d’assertion est toujours vraie</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Préférer les constructeurs aux méthodes TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Préférer les constructeurs aux méthodes TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Préférer « Dispose » aux méthodes TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Préférer « Dispose » aux méthodes TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Préférer TestCleanup aux méthodes « Dispose »</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Préférer TestCleanup aux méthodes « Dispose »</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Préférer les méthodes TestInitialize aux constructeurs</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Préférer les méthodes TestInitialize aux constructeurs</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="translated">Les méthodes publiques doivent être des méthodes de test (indiquées par « [TestMethod] »).</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="translated">La méthode publique « {0} » doit être une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="translated">Les méthodes publiques doivent être des méthodes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">C’est considéré comme une bonne pratique d’avoir uniquement des classes de test marquées comme publiques dans un projet de test.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">Le type public « {0} » doit être marqué avec « [TestClass] » ou remplacé par « interne »</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">Les types publics doivent être des classes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertMessageFormat">
        <source>Use 'Assert.{0}' instead of 'StringAssert.{1}'</source>
        <target state="translated">Utilisez « Assert.{0} » au lieu de « StringAssert.{1} »</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertTitle">
        <source>Use 'Assert' instead of 'StringAssert'</source>
        <target state="translated">Utilisez « Assert » au lieu de « StringAssert »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">La classe de test « {0} » doit être valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">La propriété « TestContext » doit être valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">La signature « {0} » de la méthode de test n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">Sans utiliser 'ClassCleanupBehavior.EndOfClass', '[ClassCleanup]' sera exécuté par défaut à la fin de l’assemblée et non à la fin de la classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Utilisez 'ClassCleanupBehavior.EndOfClass' avec '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Utilisez 'ClassCleanupBehavior.EndOfClass' avec '[ClassCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">Les classes de test, à savoir les classes marquées par l’attribut « [TestClass] », doivent respecter la disposition suivante pour être considérées comme valides par MSTest :
– Elle doit être « publique » (ou « interne » si l’attribut « [assembly : DiscoverInternals] » est défini)
– Elle ne doit pas être « statique » (sauf si elle ne contient que des méthodes « AssemblyInitialize » et/ou « AssemblyCleanup »)
– Elle ne doit pas être générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">Les classes de test doivent avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">La classe de test doit avoir au moins une méthode de test ou être « statique » avec une ou plusieurs méthodes marquées par « [AssemblyInitialize] » et/ou « [AssemblyCleanup] ».</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">La classe de test '{0}' doit avoir au moins une méthode de test ou être « statique » avec une ou plusieurs méthodes marquées par « [AssemblyInitialize] » et/ou « [AssemblyCleanup] »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">La classe de test doit avoir une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Les méthodes marquées par « [TestCleanup] » doivent respecter le schéma suivant pour être valides :
– il doit être « public »
– il ne doit pas être « abstract »
– il ne doit pas être « async void »
– il ne devrait pas être « static »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
– il ne doit accepter aucun paramètre
- le type de retour doit être « vide », « Task » ou « ValueTask »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être» ’static »
-Si la classe est « sealed », elle doit être marquée avec « [TestClass] » (ou un attribut dérivé).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">La signature «{0}» de la méthode TestCleanup n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">La méthode TestCleanup doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>'TestContext' should be a non-static field or property assigned in constructor or for a property set by MSTest, it should follow the layout:
- it should be 'public' regardless of whether '[assembly: DiscoverInternals]' attribute is set or not.
- it should not be 'static'
- it should have a setter.</source>
        <target state="translated">« TestContext » doit être un champ ou une propriété non statique affecté dans le constructeur ou pour une propriété définie par MSTest, il doit suivre la disposition :
- il doit être « public », que l’attribut « [assembly: DiscoverInternals] » soit défini ou non.
- il ne devrait pas être « statique »
- il doit avoir un setter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">La propriété de contexte de test doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Les méthodes marquées par [TestInitialize] doivent respecter le schéma suivant pour être valides : 
– il doit être « public »
– il ne doit pas être « abstract »
– il ne doit pas être « async void »
– il ne devrait pas être « static »
– Il ne doit pas s’agir d’une méthode spéciale (finaliseur, opérateur...).
– il ne doit pas être générique
– il ne doit accepter aucun paramètre
- le type de retour doit être « vide », « Task » ou « ValueTask »

Le type déclarant ces méthodes doit également respecter les règles suivantes :
Le type doit être une classe
-La classe doit être « public » ou « internal » (si le projet de test utilise l’attribut ’[DiscoverInternals]’)
-La classe ne doit pas être» ’static »
-Si la classe est « sealed », elle doit être marquée avec « [TestClass] » (ou un attribut dérivé).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">La signature de la méthode TestInitialize '{0}' n’est pas valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">La méthode TestInitialize doit avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should may be generic as long as type parameters can be inferred and argument types are compatible
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Les méthodes de test, c’est-à-dire les méthodes marquées de l’attribut « [TestMethod] », doivent respecter la disposition suivante pour être considérées comme valides par MSTest : 
– elle doit être « publique » (ou « interne » si l’attribut « [assembly : DiscoverInternals] » est défini)
– elle ne doit pas être « statique »
– elle peut être générique tant que les paramètres de type peuvent être déduits et que les types d’arguments sont compatibles
– il ne doit pas être « abstract »
– le type de retour doit être « void », « Task » ou « ValueTask »
– elle ne doit pas être « async void »
– elle ne doit pas être une méthode spéciale (finaliseur, opérateur...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">Les méthodes de test doivent avoir une disposition valide</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">Les méthodes de test ne doivent pas être ignorées (marquées avec « [Ignorer] »).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">La méthode de test « {0} » ne doit pas être ignorée</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">La méthode de test doit être ignorée</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">Le type contenant « [TestMethod] » doit être marqué avec « [TestClass] », sans quoi la méthode de test sera ignorée silencieusement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Type '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">Le type « {0} » contient des méthodes de test et doit être marquée avec « [TestClass] »</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">Le type contenant « [TestMethod] » doit être marqué avec « [TestClass] »</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">Les méthodes de fixture de test asynchrones ne nécessitent pas le suffixe « Async »</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">Les méthodes de test asynchrones ne nécessitent pas le suffixe 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnusedParameterSuppressorJustification">
        <source>TestContext parameter is required by MSTest for AssemblyInitialize and ClassInitialize methods</source>
        <target state="translated">Le paramètre TestContext est requis par MSTest pour les méthodes AssemblyInitialize et ClassInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] ne peut être défini que sur les méthodes marquées avec [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] ne peut être défini que sur les méthodes marquées avec [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassMessageFormat">
        <source>The attribute '{0}' which derives from 'ConditionBaseAttribute' should be used only on classes marked with `TestClassAttribute`</source>
        <target state="translated">L’attribut '{0}' qui dérive de 'ConditionBaseAttribute' doit être utilisé uniquement sur les classes marquées avec 'TestClassAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassTitle">
        <source>Use 'ConditionBaseAttribute' on test classes</source>
        <target state="translated">Utiliser 'ConditionBaseAttribute' sur les classes de test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutDescription">
        <source>Using '[Timeout]' without explicitly setting 'CooperativeCancellation = true' is discouraged. In a future version, cooperative cancellation will become the default behavior. Set 'CooperativeCancellation = true' to opt into the recommended behavior and avoid breaking changes.</source>
        <target state="translated">L’utilisation de '[Timeout]' sans définir explicitement 'CooperativeCancellation = true' est déconseillée. Dans une future version, l’annulation coopérative deviendra le comportement par défaut. Définissez 'CooperativeCancellation = true' pour adopter le comportement recommandé et éviter les changements incompatibles.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutMessageFormat">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]' to enable cooperative cancellation behavior</source>
        <target state="translated">Utilisez 'CooperativeCancellation = true' avec '[Timeout]' pour activer le comportement d’annulation coopératif</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutTitle">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]'</source>
        <target state="translated">Utiliser 'CooperativeCancellation = true' avec '[Timeout]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">« [DeploymentItem] » ne peut être spécifié que sur une classe de test ou une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">« [DeploymentItem] » ne peut être spécifié que sur une classe de test ou une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsMessageFormat">
        <source>Use 'Assert.ThrowsExactly' instead of 'Assert.ThrowsException'</source>
        <target state="translated">Utiliser 'Assert.ThrowsExactly' à la place de 'Assert.ThrowsException'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsTitle">
        <source>Use newer methods to assert exceptions</source>
        <target state="translated">Utiliser des méthodes plus nouvelles pour déclarer des exceptions</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">Par défaut, MSTest exécute des tests dans la même assembly de façon séquentielle, ce qui peut entraîner de graves limitations de performances. Il est recommandé d’activer l’attribut d’assemblée « [Parallelize] » pour exécuter des tests en parallèle ou, si l’assemblée est connu pour ne pas être parallélisable, d’utiliser explicitement l’attribut de niveau assemblée « [DoNotParallelize] ».</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Activer ou désactiver explicitement la parallélisation des tests</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Activer ou désactiver explicitement la parallélisation des tests</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsMessageFormat">
        <source>Use 'Assert.{0}' instead of 'Assert.{1}'</source>
        <target state="translated">Utilisez ' Assert.{0}' au lieu de 'Assert.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsTitle">
        <source>Use proper 'Assert' methods</source>
        <target state="translated">Utiliser les méthodes 'Assert' appropriées</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodMessageFormat">
        <source>An attribute that derives from 'RetryBaseAttribute' can be specified only on a test method</source>
        <target state="translated">Vous ne pouvez spécifier un attribut dérivant de « RetryBaseAttribute » que sur une méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodTitle">
        <source>Use retry attribute on test method</source>
        <target state="translated">Utilisez l’attribut de nouvelle tentative sur la méthode de test</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageTitle">
        <source>TestContext property cannot be accessed in this context</source>
        <target state="translated">Impossible d’accéder à la propriété TestContext dans ce contexte</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageMessageFormat">
        <source>TestContext property '{0}' cannot be accessed in '{1}' method</source>
        <target state="translated">Impossible d’accéder à la propriété TestContext « {0} » dans la méthode « {1} »</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageDescription">
        <source>Some TestContext properties are only available during test execution and cannot be accessed in assembly initialize, class initialize, class cleanup, or assembly cleanup methods.</source>
        <target state="translated">Certaines propriétés TestContext sont disponibles uniquement pendant l’exécution du test et ne sont pas accessibles dans les méthodes d’initialisation d’assembly, d’initialisation de classe, de nettoyage de classe ou de nettoyage d’assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementDescription">
        <source>Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</source>
        <target state="new">Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementMessageFormat">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementTitle">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>