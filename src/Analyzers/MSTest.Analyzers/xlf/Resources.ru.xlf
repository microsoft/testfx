<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Чтобы метод, помеченный "[AssemblyCleanup]", был допустимым, он должен соответствовать следующим правилам:
– не может быть объявлен для универсального класса ("generic");
– должен быть общедоступным ("public");
– должен быть статическим ("static");
– не быть асинхронным и не возвращающим значения ("async void")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– не принимать никаких параметров;
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть статическим ("static");
– должен быть помечен как "[TestClass]" (или производный атрибут);
– не должен быть универсальным ("generic").</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода AssemblyCleanup "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">Методы AssemblyCleanup должны использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Чтобы метод, помеченный "[AssemblyInitialize]", был допустимым, он должен соответствовать следующим правилам:
– не может быть объявлен для универсального класса ("generic");
– должен быть общедоступным ("public");
– должен быть статическим ("static");
– не быть асинхронным и не возвращающим значения ("async void")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– должен принимать один параметр типа "TestContext";
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть статическим ("static");
– должен быть помечен как "[TestClass]" (или производный атрибут);
– не должен быть универсальным ("generic").</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода AssemblyInitialize "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">Методы AssemblyInitialize должны использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">Предпочитайте добавление дополнительного утверждения, проверяющего наличие значения NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">Избегайте условного доступа в утверждениях</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">"Assert.AreEqual", "Assert.AreNotEqual", "Assert.AreSame" и "Assert.AreNotSame" ожидают, что сначала будет передано ожидаемое значение, а фактическое значение будет передано в качестве второго аргумента.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">Аргументы проверочных утверждений должны передаваться в правильном порядке. Аргументы "actual" и "expected"/"notExpected" были переставлены местами.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">Аргументы проверочных утверждений должны передаваться в правильном порядке</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsException' or 'Assert.ThrowsExceptionAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exeption.</source>
        <target state="translated">Предпочитайте "Assert.ThrowsException" или "Assert.ThrowsExceptionAsync" вместо "[ExpectedException]", так как это гарантирует, что только ожидаемый вызов приводит к ожидаемому исключению. API-интерфейсы утверждения также обеспечивают дополнительную гибкость и позволяют утверждать дополнительные свойства исключения.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsException/ThrowsExceptionAsync' over '[ExpectedException]'</source>
        <target state="translated">Предпочитать "Assert.ThrowsException/ThrowsExceptionAsync" вместо "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Избегать "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Чтобы метод, помеченный "[ClassCleanup]", был допустимым, он должен соответствовать следующим правилам:
– не может быть объявлен для универсального класса, если не установлен режим InheritanceBehavior;
– должен быть общедоступным ("public");
– должен быть статическим ("static");
– не быть асинхронным и не возвращающим значения ("async void")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– не принимать никаких параметров;
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";
– если класс абстрактный, должен быть указан параметр атрибута "InheritanceBehavior.BeforeEachDerivedClass";
– если класс запечатанный, не следует указывать параметр атрибута "InheritanceBehavior.BeforeEachDerivedClass";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть объявлен как статический ("static");
– если класс запечатанный, его следует пометить как "[TestClass]" (или производный атрибут);
– не должен быть универсальным ("generic").</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода ClassCleanup "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">Методы ClassCleanup должны использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Чтобы метод, помеченный "[ClassInitialize]", был допустимым, он должен соответствовать следующим правилам:
– не может быть объявлен для универсального класса, если не установлен режим InheritanceBehavior;
– должен быть общедоступным ("public");
– должен быть статическим ("static");
– не быть асинхронным и не возвращающим значения ("async void")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– должен принимать один параметр типа "TestContext";
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";
– если класс абстрактный, должен быть указан параметр атрибута "InheritanceBehavior.BeforeEachDerivedClass";
– если класс запечатанный, не следует указывать параметр атрибута "InheritanceBehavior.BeforeEachDerivedClass";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть объявлен как статический ("static");
– если класс запечатанный, его следует пометить как "[TestClass]" (или производный атрибут);
– не должен быть универсальным ("generic").</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода ClassInitialize "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">Методы ClassInitialize должны использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">Действительная запись DataRow должна иметь следующую структуру:
– должна быть задана только для метода теста;
– количество аргументов должно совпадать с количеством аргументов метода;
– тип аргумента должен совпадать с типом аргумента метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">Количество аргументов DataRow должно соответствовать количеству параметров метода (аргументов конструктора: {0}, параметров метода: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument type should match method parameter type. Mismatches occur at indices: {0}</source>
        <target state="translated">Тип аргумента DataRow должен соответствовать типу параметра метода. Обнаружены несовпадения в следующих индексах: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">Значение DataRow следует задавать только для метода теста</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">Значение DataRow должно быть допустимым</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">Не отрицать логические утверждения, вместо этого использовать противоположное утверждение</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">Не отрицать логические утверждения</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Не хранить TestContext в статическом элементе</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Не хранить TestContext в статическом элементе</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">"System.ComponentModel.DescriptionAttribute" не действует в контексте тестов. Вероятно, вы хотели использовать "Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">Вы хотели использовать "Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute"?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">"System.ComponentModel.DescriptionAttribute" не действует на методы тестирования</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">Запись "DynamicData" должна соответствовать следующему макету, чтобы быть допустимой:
– должна быть задана только для метода теста;
– элемент должен быть определен в указанном типе;
– элемент должен быть методом, если указан DynamicDataSourceType.Method, в противном случае он должен быть свойством.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">Подпись элемента данных "[DynamicData]" "{0}.{1}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">Подпись метода отображаемого имени "[DynamicData]" "{0}.{1}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">Элемент "[DynamicData]" "{0}.{1}" должен быть методом</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">Невозможно найти элемент "[DynamicData]" "{0}.{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">Элемент "[DynamicData]" "{0}.{1}" должен возвращать "IEnumerable&lt;object[]&gt;", "IEnumerable&lt;Tuple&gt;" или "IEnumerable&lt;ValueTuple&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">"[DynamicData]" следует задавать только для метода теста</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should set 'DynamicDataSourceType.Method'</source>
        <target state="translated">Элемент "[DynamicData]" "{0}.{1}" является методом, поэтому следует задать "DynamicDataSourceType.Method"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should set 'DynamicDataSourceType.Property'</source>
        <target state="translated">Элемент "[DynamicData]" "{0}.{1}" является свойством, поэтому следует задать "DynamicDataSourceType.Property"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicDta]' member '{0}.{1}' is found more than once</source>
        <target state="translated">Элемент "[DynamicDta]" "{0}.{1}" обнаружен несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">Значение DynamicData должно быть допустимым</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">Используйте "Assert.Fail" вместо утверждения с постоянным сбоем "Assert.{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">Используйте "Assert.Fail" вместо утверждения с постоянным сбоем</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">Проверьте или удалите утверждение, так как известно, что его условие всегда истинно.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">Условие проверочного утверждения всегда истинно</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Предпочитать конструкторы методам TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Предпочитать конструкторы методам TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Предпочитать "Dispose" методам TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Предпочитать "Dispose" методам TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Предпочитать TestCleanup методам "Dispose"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Предпочитать TestCleanup методам "Dispose"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Предпочитать методы TestInitialize конструкторам</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Предпочитать методы TestInitialize конструкторам</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="new">Public methods should be test methods (marked with `[TestMethod]`).</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="new">Public method '{0}' should be a test method</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="new">Public methods should be test methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">Рекомендуется использовать только тестовые классы, помеченные как общедоступные в тестовом проекте.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">Общедоступный тип "{0}" должен быть помечен атрибутом "[TestClass]" или изменен на значение "internal"</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">Общедоступные типы должны быть тестовыми классами</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="new">Test class '{0}' should be valid</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">Подпись тестового метода "{0}" недействительна</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">Без использования "ClassCleanupBehavior.EndOfClass" "[ClassCleanup]" по умолчанию будет выполняться в конце сборки, а не в конце класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Использовать "classCleanupBehavior.EndOfClass" с "[ClassCleanup]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Использовать "classCleanupBehavior.EndOfClass" с "[ClassCleanup]"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">В тестовых классах (с атрибутом "[TestClass]") должна быть следующая структура, чтобы эти классы считались допустимыми для MSTest:
- у класса должно быть свойство "public" (или "internal", если задан атрибут "[assembly: DiscoverInternals]")
- у класс не должно быть свойства "static" (кроме случаев, когда класс содержит только методы "AssemblyInitialize" и "AssemblyCleanup")
- класс не должен быть универсальным.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">Тестовые классы должны использовать допустимую структуру</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">Тестовый класс должен содержать хотя бы один тестовый метод или быть "статическим" с методами, отмеченными "[AssemblyInitialization]" или "[AssemblyCleanup]".</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">Тестовый класс "{0}" должен содержать хотя бы один тестовый метод или быть "статическим" с методами, отмеченными "[AssemblyInitialization]" или "[AssemblyCleanup]"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">Тестовый класс должен содержать тестовый метод</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Чтобы метод, помеченный "[TestCleanup]", был допустимым, он должен соответствовать следующим правилам:
– быть общедоступным ("public")
;
– не быть абстрактным ("abstract")
;
– не быть асинхронным и не возвращающим значения ("async void")
– не быть статическим ("static")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– не принимать никаких параметров;
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть статическим ("static");
– если класс запечатанный, его следует пометить как "[TestClass]" (или производный атрибут).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода TestCleanup "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">Метод TestCleanup должен использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>TestContext property should follow the following layout to be valid:
- it should be a property
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be readonly.</source>
        <target state="translated">Свойство TestContext должно использовать следующий макет, чтобы считаться допустимым:
– должно быть свойством;
– должно быть присвоено значение "public" (или "internal", если задан атрибут "[assembly: DiscoverInternals]");
– не следует присваивать значение "static";
– не должно предназначаться только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotField">
        <source>Member 'TestContext' should be a property and not a field</source>
        <target state="translated">Элемент "TestContext" должен быть свойством, а не полем</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotReadonly">
        <source>Property 'TestContext' should be settable</source>
        <target state="translated">Свойство "TestContext" должно поддерживать настройку</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotStatic">
        <source>Property 'TestContext' should not be 'static'</source>
        <target state="translated">Свойству "TestContext" не следует присваивать значение "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_Public">
        <source>Property 'TestContext' should be 'public'</source>
        <target state="translated">Свойство "TestContext" должно иметь значение "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_PublicOrInternal">
        <source>Property 'TestContext' should be 'public' or 'internal'</source>
        <target state="translated">Свойство "TestContext" должно иметь значение "public" или "internal"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">Тестовое контекстное свойство должно использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Чтобы метод, помеченный "[TestInitialize]", был допустимым, он должен соответствовать следующим правилам:
– быть общедоступным ("public")
;
– не быть абстрактным ("abstract")
;
– не быть асинхронным и не возвращающим значения ("async void")
– не быть статическим ("static")
– не быть специальным (метод завершения, оператор…).
– не быть общим ("generic")
;
– не принимать никаких параметров;
– тип возвращаемого значения должен быть "void", "Task" или "ValueTask";

Тип, объявляющий такие методы, также должен соответствовать следующим правилам:
– должен быть классом;
– класс должен быть объявлен как "public" или "internal" (если тестовый проект использует атрибут "[DiscoverInternals]");
– не должен быть статическим ("static");
– если класс запечатанный, его следует пометить как "[TestClass]" (или производный атрибут).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">Подпись метода TestInitialize "{0}" недопустима</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">Метод TestInitialize должен использовать допустимый макет</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Методы теста (методы, помеченные атрибутом "[TestMethod]") должны соблюдать следующую структуру, чтобы считаться допустимыми в MSTest:
– должно быть присвоено значение "public" (или "internal", если задан атрибут "[assembly: DiscoverInternals]")
– не следует присваивать значение "static"
– не следует присваивать универсальное значение
– не следует присваивать значение "abstract"
- возвращаемый тип должен быть "void", "Task" или "ValueTask"
– не следует присваивать значение "async void"
– это должен быть специальный метод (метод завершения, оператор...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">Методы теста должны использовать допустимую структуру</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">Методы теста не должны игнорироваться (помечаться с помощью "[Ignore]").</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">Метод теста "{0}" не должен игнорироваться</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">Метод теста не должен игнорироваться</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type contaning '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">У типа, содержащего "[TestMethod]", должна быть пометка "[TestClass]", иначе метод тестирования будет проигнорирован без уведомления пользователя.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Class '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">Класс "{0}" тестовые методы. У этого класса должна быть пометка "[TestClass]".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">У типа, содержащего "[TestMethod]", должна быть пометка "[TestClass]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">Методы асинхронных средств тестирования не требуют суффикса "Async".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">Асинхронные методы теста не требуют суффикса Async</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] можно задать только для методов с пометкой [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] можно задать только для методов с пометкой [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">Указать "[DeploymentItem]" можно только для тестового класса или метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">Указать "[DeploymentItem]" можно только для тестового класса или метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">По умолчанию MSTest выполняет тесты в одной сборке последовательно, что может привести к серьезному ограничению производительности. Рекомендуется включить атрибут сборки "[Parallelize]", чтобы выполнять тесты параллельно, или явно использовать атрибут уровня сборки "[DoNotParallelize]", если известно, что сборка не поддерживает параллелизацию.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Явное включение или отключение параллелизации тестов</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Явное включение или отключение параллелизации тестов</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>