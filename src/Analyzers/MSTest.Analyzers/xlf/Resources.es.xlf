<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with [AssemblyCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [AssemblyCleanup] deben seguir el siguiente diseño para ser válidos:
- debería ser 'público' 
- debería estar 'estático'
- no debería ser genérico
- no debería tomar ningún parámetro
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NoParameters">
        <source>AssemblyCleanup method '{0}' should not take any parameter</source>
        <target state="translated">El método AssemblyCleanup '{0}' no debería tomar ningún parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotAGenericClass">
        <source>AssemblyCleanup method '{0}' can't be declared on a generic class</source>
        <target state="translated">El método AssemblyCleanup "{0}" no puede ser declarado en una clase genérica</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>AssemblyCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método AssemblyCleanup '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>AssemblyCleanup method '{0}' should not be generic</source>
        <target state="translated">El método AssemblyCleanup '{0}' no debería ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Ordinary">
        <source>AssemblyCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método AssemblyCleanup '{0}' debería ser un método 'normal'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Public">
        <source>AssemblyCleanup method '{0}' should be 'public'</source>
        <target state="translated">El método AssemblyCleanup '{0}' debería ser 'público'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_ReturnType">
        <source>AssemblyCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método AssemblyCleanup '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Static">
        <source>AssemblyCleanup method '{0}' should be 'static'</source>
        <target state="translated">El método AssemblyCleanup '{0}' debería ser 'estático'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">Los métodos AssemblyCleanup deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with [AssemblyInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should take one parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [AssemblyInitialize] deberían seguir el siguiente diseño para ser válidos:
- debería ser 'público' 
- debería estar 'estático'
- no debería ser genérico
- debería tomar un parámetro de tipo 'TestContext'
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotAGenericClass">
        <source>AssemblyInitialize method '{0}' can't be declared on a generic class</source>
        <target state="translated">El método AssemblyInitialize "{0}" no puede declararse en una clase genérica</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>AssemblyInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>AssemblyInitialize method '{0}' should not be generic</source>
        <target state="translated">El método AssemblyInitialize '{0}' no debería ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Ordinary">
        <source>AssemblyInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería ser un método 'ordinario'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Public">
        <source>AssemblyInitialize method '{0}' should be 'public'</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería ser 'público'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_ReturnType">
        <source>AssemblyInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_SingleContextParameter">
        <source>AssemblyInitialize method '{0}' should take a single parameter of type 'TestContext'</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería tomar un único parámetro de tipo 'TestContext'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Static">
        <source>AssemblyInitialize method '{0}' should be 'static'</source>
        <target state="translated">El método AssemblyInitialize '{0}' debería ser 'estático'</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">Los métodos AssemblyInitialize deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="new">'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="new">Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="new">Assertion arguments should be passed in the correct order</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsException' or 'Assert.ThrowsExceptionAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exeption.</source>
        <target state="translated">Preferir "Assert.ThrowsException" o "Assert.ThrowsExceptionAsync" en lugar de '[ExpectedException]' ya que garantiza que solo la llamada esperada inicia la excepción esperada. Las API de aserción también proporcionan más flexibilidad y le permiten declarar propiedades adicionales de la ejecución.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsException/ThrowsExceptionAsync' over '[ExpectedException]'</source>
        <target state="translated">Preferir "Assert.ThrowsException/ThrowsExceptionAsync" en lugar de "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Evitar '[ExpectedException]'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with [ClassCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should not 'static'
- it should not be generic
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [ClassCleanup] deben seguir el siguiente diseño para ser válidos:
- debería ser 'público' 
- no debería ser 'estático'
- no debería ser genérico
- no debería tomar ningún parámetro
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NoParameters">
        <source>ClassCleanup method '{0}' should not take any parameter</source>
        <target state="translated">El método ClassCleanup '{0}' no debería tomar ningún parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotAGenericClassUnlessInheritanceModeSet">
        <source>ClassCleanup method '{0}' can't be declared on a generic class without the `InheritanceBehavior` mode is set</source>
        <target state="translated">El método ClassCleanup "{0}" no puede ser declarado en una clase genérica sin que el modo "InheritanceBehavior" esté configurado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>ClassCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método ClassCleanup '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>ClassCleanup method '{0}' should not be generic</source>
        <target state="translated">El método ClassCleanup '{0}' no debería ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Ordinary">
        <source>ClassCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método ClassCleanup '{0}' debería ser un método 'normal'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Public">
        <source>ClassCleanup method '{0}' should be 'public'</source>
        <target state="translated">El método ClassCleanup '{0}' debería ser 'público'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_ReturnType">
        <source>ClassCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método ClassCleanup '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Static">
        <source>ClassCleanup method '{0}' should be 'static'</source>
        <target state="translated">El método ClassCleanup '{0}' debería ser 'estático'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">Los métodos ClassCleanup deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with [ClassInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should take one parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [ClassInitialize] deberían seguir el siguiente diseño para ser válidos:
- debería ser 'público' 
- debería estar 'estático'
- no debería ser genérico
- debería tomar un parámetro de tipo 'TestContext'
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotAGenericClassUnlessInheritanceModeSet">
        <source>ClassInitialize method '{0}' can't be declared on a generic class without the `InheritanceBehavior` mode is set</source>
        <target state="translated">El método ClassInitialize "{0}" no puede ser declarado en una clase genérica sin que el modo "InheritanceBehavior" esté configurado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>ClassInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método ClassInitialize '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>ClassInitialize method '{0}' should not be generic</source>
        <target state="translated">El método ClassInitialize '{0}' no debería ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Ordinary">
        <source>ClassInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método ClassInitialize '{0}' debería ser un método 'ordinario'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Public">
        <source>ClassInitialize method '{0}' should be 'public'</source>
        <target state="translated">El método ClassInitialize '{0}' debería ser 'público'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_ReturnType">
        <source>ClassInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método ClassInitialize '{0}' debería devolver 'void', 'Task' o 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_SingleContextParameter">
        <source>ClassInitialize method '{0}' should take a single parameter of type 'TestContext'</source>
        <target state="translated">El método ClassInitialize '{0}' debe tomar un único parámetro de tipo 'TestContext'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Static">
        <source>ClassInitialize method '{0}' should be 'static'</source>
        <target state="translated">El método ClassInitialize '{0}' debería ser 'estático'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">Los métodos ClassInitialize deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">La entrada DataRow debe tener el siguiente diseño para que sea válido:
: solo se debe establecer en un método de prueba;
- el recuento de argumentos debe coincidir con el recuento de argumentos del método;
: el tipo de argumento debe coincidir con el tipo de argumento de método.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">El recuento de argumentos de DataRow debe coincidir con el recuento de parámetros del método (argumentos de constructor: {0}, parámetros de método: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument type should match method parameter type. Mismatches occur at indices: {0}</source>
        <target state="translated">El tipo de argumento DataRow debe coincidir con el tipo de parámetro de método. Se producen errores de coincidencia en los índices: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow solo debe establecerse en un método de prueba</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow debe ser válido</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="new">Prefer constructors over TestInitialize methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="new">Prefer constructors over TestInitialize methods</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">Se considera una buena práctica tener solo clases de prueba marcadas como públicas en un proyecto de prueba.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">El tipo público '{0}' debe marcarse con '[TestClass]' o cambiarse a 'internal'</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">Los tipos públicos deben ser clases de prueba</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">Las clases de prueba, las clases marcadas con el atributo '[TestClass]', deben respetar el siguiente diseño para que MSTest lo considere válido:
- debe ser 'public' (o 'internal' si se establece el atributo '[assembly: DiscoverInternals]')
- no debe ser "static" (excepto si contiene solo los métodos "AssemblyInitialize" o "AssemblyCleanup")
: no debe ser genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_NotStatic">
        <source>Test class '{0}' should not be 'static'</source>
        <target state="translated">La clase de prueba '{0}' no debe ser 'static'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_Public">
        <source>Test class '{0}' should be 'public'</source>
        <target state="translated">La clase de prueba '{0}' debe ser 'public'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test class '{0}' should be 'public' or 'internal'</source>
        <target state="translated">La clase de prueba '{0}' debe ser 'public' o 'internal'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">Las clases de prueba deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">La clase de prueba debe tener al menos un método de prueba o ser 'static' con métodos marcados por '[AssemblyInitialization]' o '[AssemblyCleanup]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">La clase de prueba '{0}' debe tener al menos un método de prueba o ser 'static' con métodos marcados por '[AssemblyInitialization]' y/o '[AssemblyCleanup]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">La clase de prueba debe tener un método de prueba</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with [TestCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [TestCleanup] deberían seguir el siguiente diseño para ser válidos:
- debería ser 'public' 
- no debería ser 'static'
- no debería ser genérico
- no debería ser 'abstract'
- no debería tomar ningún parámetro
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NoParameters">
        <source>TestCleanup method '{0}' should not take any parameter</source>
        <target state="translated">El método TestCleanup "{0}" no debería tomar ningún parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotAbstract">
        <source>TestCleanup method '{0}' should not be 'abstract'</source>
        <target state="translated">El método TestCleanup "{0}" no debe ser "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>TestCleanup method '{0}' should not be 'async void'</source>
        <target state="translated">El método TestCleanup "{0}" no debe ser "async void"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>TestCleanup method '{0}' should not be generic</source>
        <target state="translated">El método TestCleanup "{0}" no debe ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotStatic">
        <source>TestCleanup method '{0}' should not be 'static'</source>
        <target state="translated">El método TestCleanup "{0}" no debe ser "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_Ordinary">
        <source>TestCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método TestCleanup "{0}" debe ser un método "normal"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_Public">
        <source>TestCleanup method '{0}' should be 'public'</source>
        <target state="translated">El método TestCleanup "{0}" debe ser "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_ReturnType">
        <source>TestCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método TestCleanup "{0}" debe devolver "void", "Task" o "ValueTask"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">El método TestCleanup debería tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>TestContext property should follow the following layout to be valid:
- it should be a property
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be readonly.</source>
        <target state="translated">La propiedad TestContext debe seguir el siguiente diseño para que sea válida:
: debe ser una propiedad
- debe ser ''public'' (o ''internal'' si se establece el atributo ''[assembly: DiscoverInternals]')
- No debe ser "static"
: no debe ser de solo lectura.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotField">
        <source>Member 'TestContext' should be a property and not a field</source>
        <target state="translated">El miembro ''TestContext'' debe ser una propiedad y no un campo</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotReadonly">
        <source>Property 'TestContext' should be settable</source>
        <target state="translated">La propiedad ''TestContext'' debe poder establecerse</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotStatic">
        <source>Property 'TestContext' should not be 'static'</source>
        <target state="translated">La propiedad ''TestContext'' no debe ser ''static''</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_Public">
        <source>Property 'TestContext' should be 'public'</source>
        <target state="translated">La propiedad ''TestContext'' debe ser ''public''</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_PublicOrInternal">
        <source>Property 'TestContext' should be 'public' or 'internal'</source>
        <target state="translated">La propiedad ''TestContext'' debe ser ''public'' o ''internal'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">La propiedad de contexto de prueba debe tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with [TestInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos marcados con [TestInitialize] deberían seguir el siguiente diseño para ser válidos:
- debería ser 'public' 
- no debería ser 'static'
- no debería ser genérico
- no debería ser 'abstract'
- no debería tomar ningún parámetro
- el tipo de valor devuelto debería ser 'void', 'Task' o 'ValueTask'
- no debería ser 'async void'
- no debería ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NoParameters">
        <source>TestInitialize method '{0}' should not take any parameter</source>
        <target state="translated">El método TestInitialize "{0}" no debería tomar ningún parámetro</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotAbstract">
        <source>TestInitialize method '{0}' should not be 'abstract'</source>
        <target state="translated">El método TestInitialize "{0}" no debe ser "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>TestInitialize method  '{0}' should not be 'async void'</source>
        <target state="translated">El método TestInitialize "{0}" no debe ser "async void"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>TestInitialize method '{0}' should not be generic</source>
        <target state="translated">El método TestInitialize "{0}" no debe ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotStatic">
        <source>TestInitialize method '{0}' should not be 'static'</source>
        <target state="translated">El método TestInitialize "{0}" no debe ser "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_Ordinary">
        <source>TestInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método TestInitialize "{0}" debe ser un método "normal"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_Public">
        <source>TestInitialize method '{0}' should be 'public'</source>
        <target state="translated">El método TestInitialize "{0}" debe ser "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_ReturnType">
        <source>TestInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método TestInitialize "{0}" debe devolver "void", "Task" o "ValueTask"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">El método TestInitialize debería tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Los métodos de prueba, los métodos marcados con el atributo '[TestMethod]', deben respetar el siguiente diseño para que MSTest lo considere válido:
- debe ser 'public' (o 'internal' si se establece el atributo '[assembly: DiscoverInternals]')
- no debe ser 'static'
- no debe ser genérico
: no debe ser 'abstract'
- el tipo de valor devuelto debe ser 'void', 'Task' o 'ValueTask'
- no debe ser 'async void'
- no debe ser un método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAbstract">
        <source>Test method '{0}' should not be 'abstract'</source>
        <target state="translated">El método de prueba '{0}' no debe ser 'abstract'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAsyncVoid">
        <source>Test method '{0}' should not be 'async void'</source>
        <target state="translated">El método de prueba '{0}' no debe ser 'async void'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotGeneric">
        <source>Test method '{0}' should not be generic</source>
        <target state="translated">El método de prueba '{0}' no debe ser genérico</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotStatic">
        <source>Test method '{0}' should not be 'static'</source>
        <target state="translated">El método de prueba '{0}' no debe ser 'static'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Ordinary">
        <source>Test method '{0}' should be an 'ordinary' method</source>
        <target state="translated">El método de prueba '{0}' debe ser un método 'normal'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Public">
        <source>Test method '{0}' should be 'public'</source>
        <target state="translated">El método de prueba '{0}' debe ser 'public'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test method '{0}' should be 'public' or 'internal'</source>
        <target state="translated">El método de prueba '{0}' debe ser 'public' o 'internal'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_ReturnType">
        <source>Test method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">El método de prueba "{0}" debe devolver "void", "Task" o "ValueTask"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">Los métodos de prueba deben tener un diseño válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">Los métodos de prueba no deberían ignorarse (marcarse con '[Ignorar]').</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">El método de prueba '{0}' no debería ignorarse</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">El método de prueba no debería ignorarse</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] solo se puede establecer en métodos marcados con [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] solo se puede establecer en métodos marcados con [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">De forma predeterminada, MSTest ejecuta pruebas en el mismo ensamblado secuencialmente, lo que puede provocar limitaciones de rendimiento graves. Se recomienda habilitar el atributo de ensamblado ''[Parallelize]'' o, si se sabe que el ensamblado no se puede paralelizar, usar explícitamente el atributo de nivel de ensamblado ''[DoNotParallelize]''.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Habilitar o deshabilitar explícitamente la paralelización de pruebas</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Habilitar o deshabilitar explícitamente la paralelización de pruebas</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>