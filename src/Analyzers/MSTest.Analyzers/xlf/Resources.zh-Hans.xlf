<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with [AssemblyCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [AssemblyCleanup] 的方法应遵循以下布局才有效：
- 它应为“public”
- 它应为“static”
- 它不应是泛型的
- 它不应采用任何参数
- 返回类型应为“void”、“Task”或“ValueTask”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NoParameters">
        <source>AssemblyCleanup method '{0}' should not take any parameter</source>
        <target state="translated">AssemblyCleanup 方法“{0}”不应采用任何参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotAGenericClass">
        <source>AssemblyCleanup method '{0}' can't be declared on a generic class</source>
        <target state="translated">不能在泛型类上声明 AssemblyCleanup 方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>AssemblyCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">AssemblyCleanup 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>AssemblyCleanup method '{0}' should not be generic</source>
        <target state="translated">AssemblyCleanup 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Ordinary">
        <source>AssemblyCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">AssemblyCleanup 方法“{0}”应为“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Public">
        <source>AssemblyCleanup method '{0}' should be 'public'</source>
        <target state="translated">AssemblyCleanup 方法“{0}”应是“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_ReturnType">
        <source>AssemblyCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">AssemblyCleanup 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat_Static">
        <source>AssemblyCleanup method '{0}' should be 'static'</source>
        <target state="translated">AssemblyCleanup 方法“{0}”不应是“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">AssemblyCleanup 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with [AssemblyInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should take one parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [AssemblyInitialize] 的方法应遵循以下布局才有效：
- 它应为“public”
- 它应为“static”
- 它不应是泛型的
- 它应采用“TestContext”类型的一个参数
- 返回类型应为“void”、“Task”或“ValueTask”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotAGenericClass">
        <source>AssemblyInitialize method '{0}' can't be declared on a generic class</source>
        <target state="translated">不能在泛型类上声明 AssemblyInitialize 方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>AssemblyInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">AssemblyInitialize 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>AssemblyInitialize method '{0}' should not be generic</source>
        <target state="translated">AssemblyInitialize 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Ordinary">
        <source>AssemblyInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">AssemblyInitialize 方法“{0}”应为“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Public">
        <source>AssemblyInitialize method '{0}' should be 'public'</source>
        <target state="translated">AssemblyInitialize 方法“{0}”不应是“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_ReturnType">
        <source>AssemblyInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">AssemblyInitialize 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_SingleContextParameter">
        <source>AssemblyInitialize method '{0}' should take a single parameter of type 'TestContext'</source>
        <target state="translated">AssemblyInitialize 方法“{0}”应采用类型为“TestContext”的单个参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat_Static">
        <source>AssemblyInitialize method '{0}' should be 'static'</source>
        <target state="translated">AssemblyInitialize 方法“{0}”不应是“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">AssemblyInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Assert methods should not contain conditional access. First assert for null and then do the other assertion.</source>
        <target state="new">Assert methods should not contain conditional access. First assert for null and then do the other assertion.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Assertion arguments should avoid conditional access</source>
        <target state="new">Assertion arguments should avoid conditional access</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">“Assert.AreEqual”、“Assert.AreNotEqual”、“Assert.AreSame” 和 “Assert.AreNotSame” 要求先传递预期值，然后将实际值作为第二个参数传递。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">应按正确的顺序传递断言参数。已交换 “actual” 和 “expected”/“notExpected” 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">应按正确的顺序传递断言参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsException' or 'Assert.ThrowsExceptionAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exeption.</source>
        <target state="translated">首选 "Assert.ThrowsException" 或 "Assert.ThrowsExceptionAsync" 而不是 "[ExpectedException]"，因为它确保只有预期调用才会引发预期异常。断言 API 还提供更多的灵活性，并允许你断言异常的额外属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsException/ThrowsExceptionAsync' over '[ExpectedException]'</source>
        <target state="translated">首选 "Assert.ThrowsException/ThrowsExceptionAsync" 而不是 "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">避免 "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with [ClassCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should not 'static'
- it should not be generic
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [ClassCleanup] 的方法应遵循以下布局才有效：
- 它应为“public”
- 它不应为“static”
- 它不应是泛型的
- 它不应采用任何参数
- 返回类型应为“void”、“Task”或“ValueTask”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NoParameters">
        <source>ClassCleanup method '{0}' should not take any parameter</source>
        <target state="translated">ClassCleanup 方法“{0}”不应采用任何参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotAGenericClassUnlessInheritanceModeSet">
        <source>ClassCleanup method '{0}' can't be declared on a generic class without the `InheritanceBehavior` mode is set</source>
        <target state="translated">如果未设置 `InheritanceBehavior` 模式，则无法在泛型类上声明 ClassCleanup 方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>ClassCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">ClassCleanup 方法“{0}”应返回“void”、“Task” 或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>ClassCleanup method '{0}' should not be generic</source>
        <target state="translated">ClassCleanup 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Ordinary">
        <source>ClassCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">ClassCleanup 方法“{0}”应为一种“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Public">
        <source>ClassCleanup method '{0}' should be 'public'</source>
        <target state="translated">ClassCleanup 方法“{0}”应为“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_ReturnType">
        <source>ClassCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">ClassCleanup 方法“{0}”应返回“void”、“Task” 或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat_Static">
        <source>ClassCleanup method '{0}' should be 'static'</source>
        <target state="translated">ClassCleanup 方法“{0}”应为“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">ClassCleanup 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with [ClassInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should be 'static'
- it should not be generic
- it should take one parameter of type 'TestContext'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [ClassInitialize] 的方法应遵循以下布局才有效：
- 它应为“public”
- 它应为“static”
- 它不应是泛型的
- 它应采用“TestContext”类型的一个参数
- 返回类型应为“void”、“Task”或“ValueTask”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotAGenericClassUnlessInheritanceModeSet">
        <source>ClassInitialize method '{0}' can't be declared on a generic class without the `InheritanceBehavior` mode is set</source>
        <target state="translated">如果未设置 `InheritanceBehavior` 模式，则无法在泛型类上声明 ClassInitialize 方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>ClassInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">ClassInitialize 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>ClassInitialize method '{0}' should not be generic</source>
        <target state="translated">ClassInitialize 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Ordinary">
        <source>ClassInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">ClassInitialize 方法“{0}”应为“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Public">
        <source>ClassInitialize method '{0}' should be 'public'</source>
        <target state="translated">ClassInitialize 方法“{0}”不应是“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_ReturnType">
        <source>ClassInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">ClassInitialize 方法“{0}”应返回“void”、“Task”或“ValueTask”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_SingleContextParameter">
        <source>ClassInitialize method '{0}' should take a single parameter of type 'TestContext'</source>
        <target state="translated">ClassInitialize 方法“{0}”应采用类型为“TestContext”的单个参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat_Static">
        <source>ClassInitialize method '{0}' should be 'static'</source>
        <target state="translated">ClassInitialize 方法“{0}”不应是“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">ClassInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">DataRow 条目应具有以下布局才能有效:
- 应仅在测试方法上进行设置；
- 参数计数应与方法参数计数匹配；
- 参数类型应与方法参数类型匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">DataRow 参数计数应与方法参数计数匹配(构造函数参数: {0}，方法参数: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument type should match method parameter type. Mismatches occur at indices: {0}</source>
        <target state="translated">DataRow 参数类型应与方法参数类型匹配。索引处出现不匹配: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow 应仅在测试方法上进行设置</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow 应有效</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">不要对布尔断言求反，而是使用相反的断言</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">不要对布尔断言求反</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">不要将 TestContext 存储在静态成员中</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">不要将 TestContext 存储在静态成员中</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">使用 “Assert.Fail” 而不是始终失败的 “Assert.{0}” 断言</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">使用 “Assert.Fail” 而不是始终失败的断言</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">首选构造函数而不是 TestInitialize 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">首选构造函数而不是 TestInitialize 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">首选 “Dispose” 而不是 TestCleanup 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">首选 “Dispose” 而不是 TestCleanup 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">首选 TestCleanup 而不是 “Dispose” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">首选 TestCleanup 而不是 “Dispose” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">首选 TestInitialize 方法而不是构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">首选 TestInitialize 方法而不是构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">在测试项目中仅将测试类标记为“公开”是一种不错的做法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">公共类型“{0}”应标记为“[TestClass]”或更改为“internal”</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">公共类型应为测试类</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">测试类(标记有“[TestClass]”属性的类)应遵循以下布局，才能被 MSTest 视为有效:
- 它应为 "public" (如果设置了“[assembly: DiscoverInternals]”属性，则应为 "internal")
- 它不应为 "static" (除非它只包含 "AssemblyInitialize" 和/或 "AssemblyCleanup" 方法)
- 它不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_NotStatic">
        <source>Test class '{0}' should not be 'static'</source>
        <target state="translated">测试类“{0}”不应为“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_Public">
        <source>Test class '{0}' should be 'public'</source>
        <target state="translated">测试类“{0}”应为“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test class '{0}' should be 'public' or 'internal'</source>
        <target state="translated">测试类“{0}”应为“public”或“internal”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">测试类应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">测试类应至少有一个测试方法，或者应为 "static" 且方法带有 "[AssemblyInitialization]" 和/或 "[AssemblyInitialization]"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialization]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">测试类“{0}”应至少有一个测试方法，或者应为 "static" 且方法带有 "[AssemblyInitialization]" 和/或 "[AssemblyInitialization]"。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">测试类应具有测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with [TestCleanup] should follow the following layout to be valid:
- it should be 'public' 
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [TestCleanup] 的方法应遵循以下布局才有效:
- 它应为 "public"
- 它不应为 "static"
- 它不应是泛型的
- 它不应为 "abstract"
- 它不应采用任何参数
- 返回类型应为 "void"、"Task" 或 "ValueTask"
- 它不应为 "async void"
- 它不应是特殊方法(终结器、运算符...)。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NoParameters">
        <source>TestCleanup method '{0}' should not take any parameter</source>
        <target state="translated">TestCleanup 方法“{0}”不应采用任何参数</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotAbstract">
        <source>TestCleanup method '{0}' should not be 'abstract'</source>
        <target state="translated">TestCleanup 方法“{0}”不应为 "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotAsyncVoid">
        <source>TestCleanup method '{0}' should not be 'async void'</source>
        <target state="translated">TestCleanup 方法“{0}”不应为 "async void"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotGeneric">
        <source>TestCleanup method '{0}' should not be generic</source>
        <target state="translated">TestCleanup 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_NotStatic">
        <source>TestCleanup method '{0}' should not be 'static'</source>
        <target state="translated">TestCleanup 方法“{0}”不应为 "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_Ordinary">
        <source>TestCleanup method '{0}' should be an 'ordinary' method</source>
        <target state="translated">TestCleanup 方法“{0}”应为一种“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_Public">
        <source>TestCleanup method '{0}' should be 'public'</source>
        <target state="translated">TestCleanup 方法“{0}”应为 "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat_ReturnType">
        <source>TestCleanup method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">TestCleanup 方法“{0}”应返回 "void"、"Task" 或 "ValueTask"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">TestCleanup 方法应该具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>TestContext property should follow the following layout to be valid:
- it should be a property
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be readonly.</source>
        <target state="translated">TestContext 属性应遵循以下布局才能生效：
- 它应该是属性
- 它应为“public”(如果设置了“[assembly: DiscoverInternals]”属性，则应为“internal”)
- 它不应为“static”
- 它不应为只读。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotField">
        <source>Member 'TestContext' should be a property and not a field</source>
        <target state="translated">成员“TestContext”应为属性而不是字段</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotReadonly">
        <source>Property 'TestContext' should be settable</source>
        <target state="translated">属性“TestContext”应可设置</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_NotStatic">
        <source>Property 'TestContext' should not be 'static'</source>
        <target state="translated">属性“TestContext”不应为“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_Public">
        <source>Property 'TestContext' should be 'public'</source>
        <target state="translated">属性“TestContext”应为“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat_PublicOrInternal">
        <source>Property 'TestContext' should be 'public' or 'internal'</source>
        <target state="translated">属性“TestContext”应为“public”或“internal”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">测试上下文属性应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with [TestInitialize] should follow the following layout to be valid:
- it should be 'public' 
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- it should not take any parameter
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">标记有 [TestInitialize] 的方法应遵循以下布局才有效:
- 它应为 "public"
- 它不应为 "static"
- 它不应是泛型的
- 它不应为 "abstract"
- 它不应采用任何参数
- 返回类型应为 "void"、"Task" 或 "ValueTask"
- 它不应为 "async void"
- 它不应是特殊方法(终结器、运算符...)。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NoParameters">
        <source>TestInitialize method '{0}' should not take any parameter</source>
        <target state="translated">TestInitialize 方法“{0}”不应采用任何参数</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotAbstract">
        <source>TestInitialize method '{0}' should not be 'abstract'</source>
        <target state="translated">TestInitialize 方法“{0}”不应为 "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotAsyncVoid">
        <source>TestInitialize method  '{0}' should not be 'async void'</source>
        <target state="translated">TestInitialize 方法“{0}”不应为 "async void"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotGeneric">
        <source>TestInitialize method '{0}' should not be generic</source>
        <target state="translated">TestInitialize 方法“{0}”不应是泛型的</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_NotStatic">
        <source>TestInitialize method '{0}' should not be 'static'</source>
        <target state="translated">TestInitialize 方法“{0}”不应为 "static"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_Ordinary">
        <source>TestInitialize method '{0}' should be an 'ordinary' method</source>
        <target state="translated">TestInitialize 方法“{0}”应为一种“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_Public">
        <source>TestInitialize method '{0}' should be 'public'</source>
        <target state="translated">TestInitialize 方法“{0}”应为 "public"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat_ReturnType">
        <source>TestInitialize method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">TestInitialize 方法“{0}”应返回 "void"、"Task" 或 "ValueTask"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">TestInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should not be generic
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">测试方法 (标记有“[TestMethod]”属性的方法) 应遵循以下布局，以供 MSTest 将其视为有效:
- 它应该是“public” (如果设置了“[assembly: DiscoverInternals]”属性，则应该是“internal”)
- 它不应为“static”
- 它不应是泛型的
- 它不应为“abstract”
- 返回类型应为“void”、“Task”或“ValueTask”
- 它不应为“async void”
- 它不应是特殊方法 (运算符、运算符...)。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAbstract">
        <source>Test method '{0}' should not be 'abstract'</source>
        <target state="translated">测试方法“{0}”不应为“abstract”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotAsyncVoid">
        <source>Test method '{0}' should not be 'async void'</source>
        <target state="translated">测试方法“{0}”不应为“async void”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotGeneric">
        <source>Test method '{0}' should not be generic</source>
        <target state="translated">测试方法“{0}”不应是泛型</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_NotStatic">
        <source>Test method '{0}' should not be 'static'</source>
        <target state="translated">测试方法“{0}”不应为“static”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Ordinary">
        <source>Test method '{0}' should be an 'ordinary' method</source>
        <target state="translated">测试方法“{0}”应为一种“普通”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_Public">
        <source>Test method '{0}' should be 'public'</source>
        <target state="translated">测试方法“{0}”应为“public”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_PublicOrInternal">
        <source>Test method '{0}' should be 'public' or 'internal'</source>
        <target state="translated">测试方法“{0}”应为“public”或“internal”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat_ReturnType">
        <source>Test method '{0}' should return 'void', 'Task' or 'ValueTask'</source>
        <target state="translated">测试方法 '{0}' 应返回 'void'、'Task' 或 'ValueTask'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">测试方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">不应忽略测试方法(标记有 "[Ignore]")。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">不应忽略测试方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">不应忽略测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">只能对标记了 [TestMethod] 的方法设置 [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">只能对标记了 [TestMethod] 的方法设置 [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">默认情况下，MSTest 将按顺序在同一程序集中运行测试，这可能会导致严重的性能限制。建议启用程序集属性“[Parallelize]”以并行运行测试，或者如果已知程序集不可并行，则显式使用程序集级别属性“DoNotParallelize”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">显式启用或禁用测试并行化</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">显式启用或禁用测试并行化</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>