<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">标记有“[AssemblyCleanup]”的方法应遵循以下布局才会有效:
-不能在泛型类上声明它
- 它应为“public”
- 它应为“static”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。
- 它不应是泛型的
-它不应采用任何参数，或采用类型为“TestContext”的单个参数
- 返回类型应为“void”、“Task”或“ValueTask”

声明这些方法的类型还应遵循以下规则：
-类型应为类
-类应为“public”或“internal”（如果测试项目正在使用“[DiscoverInternals]”属性）
-类不应为“static”
-应使用“[TestClass]”（或派生属性）标记类
-类不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">AssemblyCleanup 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">AssemblyCleanup 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">标记有“[AssemblyInitialize]”的方法应遵循以下布局才会有效:
-不能在泛型类上声明它
- 它应为“public”
- 它应为“static”
- 它不应为“async void”
- 它不应是特殊方法(终结器、运算符...)。
- 它不应是泛型的
- 它应采用“TestContext”类型的一个参数
- 返回类型应为“void”、“Task”或“ValueTask”

声明这些方法的类型还应遵循以下规则:
-类型应为类
-类应为“public”或“internal”(如果测试项目正在使用“[DiscoverInternals]”属性)
-类不应为“static”
-应使用“[TestClass]”(或派生属性)标记类
-类不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">AssemblyInitialize 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">AssemblyInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">首选添加检查 null 的其他断言</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">避免断言中的条件访问</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">“Assert.AreEqual”、“Assert.AreNotEqual”、“Assert.AreSame” 和 “Assert.AreNotSame” 要求先传递预期值，然后将实际值作为第二个参数传递。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">应按正确的顺序传递断言参数。已交换 “actual” 和 “expected”/“notExpected” 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">应按正确的顺序传递断言参数</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesDescription">
        <source>Use 'Assert.AreEqual'/'Assert.AreNotEqual' instead of 'Assert.AreSame'/'Assert.AreNotSame' when comparing value types. Passing a value type to 'Assert.AreSame'/'Assert.AreNotSame' will be boxed (creating a new object). Because 'Assert.AreSame'/'Assert.AreNotSame' does the comparison by reference, 'Assert.AreSame' will fail when boxing happens, and 'Assert.AreNotSame' will always pass.</source>
        <target state="translated">比较值类型时，请使用 “Assert.AreEqual”/“Assert.AreNotEqual” 而不是 “Assert.AreSame”/“Assert.AreNotSame”。将值类型传递给 “Assert.AreSame”/“Assert.AreNotSame”将装箱 (创建新的对象)。由于 'Assert.AreSame'/'Assert.AreNotSame' 按引用进行比较，所以当装箱发生时，“Assert.AreSame” 将失败，并且 “Assert.AreNotSame” 将始终通过。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesMessageFormat">
        <source>Use '{0}' instead of '{1}' when comparing value types</source>
        <target state="translated">比较值类型时使用 '{0}' 而不是 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesTitle">
        <source>Don't use 'Assert.AreSame' or 'Assert.AreNotSame' with value types</source>
        <target state="translated">不要将 “Assert.AreSame” 或 “Assert.AreNotSame” 与值类型一起使用</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsExactly' or 'Assert.ThrowsExactlyAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exception.</source>
        <target state="translated">首选“Assert.ThrowsExactly”或“Assert.ThrowsExactlyAsync”，而不是“[ExpectedException]”，因为它确保只有预期调用才会引发预期异常。断言 API 还提供更多的灵活性，并允许你断言异常的额外属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsExactly/ThrowsExactlyAsync' over '[ExpectedException]'</source>
        <target state="translated">首先“Assert.ThrowsExactly/ThrowsExactlyAsync”而不是“[ExpectedException]”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">避免 "[ExpectedException]"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeMessageFormat">
        <source>Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</source>
        <target state="new">Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeTitle">
        <source>Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</source>
        <target state="new">Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextDescription">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas. Exceptions that are thrown in this context will be unhandled exceptions. When using VSTest under .NET Framework, they will be silently swallowed. When using Microsoft.Testing.Platform or VSTest under modern .NET, they may crash the process.</source>
        <target state="translated">不要在 “async void” 方法、本地函数或 lambdas 内断言。在此上下文中引发的异常将是未经处理的异常。在.NET Framework下使用 VSTest 时，将无提示地接受这些测试。在现代 .NET 下使用 Microsoft.Testing.Platform 或 VSTest 时，它们可能会导致进程崩溃。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextMessageFormat">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas because they may not fail the test</source>
        <target state="translated">不要在 “async void” 方法、本地函数或 lambda 中断言，因为它们可能不会使测试失败</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextTitle">
        <source>Do not assert inside 'async void' contexts</source>
        <target state="translated">不要在 “async void” 上下文中断言</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">标记有“[ClassCleanup]”的方法应遵循以下布局才会有效:
-如果未设置“InheritanceBehavior”模式，则不能在泛型类上声明它
- 它应为“public”
- 它应为“static”
- 它不应为“async void”
- 它不应是特殊方法（终结器、运算符...）。
- 它不应是泛型的
-它不应采用任何参数，或采用类型为“TestContext”的单个参数
- 返回类型应为“void”、“Task”或“ValueTask”
- "InheritanceBehavior.BeforeEachDerivedClass" 属性参数应在类为 "abstract" 时指定
- "InheritanceBehavior.BeforeEachDerivedClass" 属性参数不应在类为 "sealed" 时指定

声明这些方法的类型还应遵循以下规则：
-类型应为类
-类应为“public”或“internal”（如果测试项目正在使用“[DiscoverInternals]”属性）
-类不应为“static”
-如果类为“sealed”，应使用“[TestClass]”（或派生属性）标记该类
-类不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">ClassCleanup 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">ClassCleanup 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">标记有“[ClassInitialize]”的方法应遵循以下布局才会有效:
-如果未设置“InheritanceBehavior”模式，则不能在泛型类上声明它
- 它应为“public”
- 它应为“static”
- 它不应为“async void”
- 它不应是特殊方法(终结器、运算符...)。
- 它不应是泛型的
- 它应采用“TestContext”类型的一个参数
- 返回类型应为“void”、“Task”或“ValueTask”
- "InheritanceBehavior.BeforeEachDerivedClass" 属性参数应在类为 "abstract" 时指定
- "InheritanceBehavior.BeforeEachDerivedClass" 属性参数不应在类为 "sealed" 时指定

声明这些方法的类型还应遵循以下规则:
-类型应为类
-类应为“public”或“internal”(如果测试项目正在使用“[DiscoverInternals]”属性)
-类不应为“static”
-如果类为“sealed”，则应使用“[TestClass]”(或派生属性)标记该类
-类不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">ClassInitialize 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">ClassInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">DataRow 条目应具有以下布局才能有效:
- 应仅在测试方法上进行设置；
- 参数计数应与方法参数计数匹配；
- 参数类型应与方法参数类型匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">DataRow 参数计数应与方法参数计数匹配(构造函数参数: {0}，方法参数: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument types do not match method parameter types. {0}</source>
        <target state="translated">DataRow 参数类型与方法参数类型不匹配。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ParameterMismatch">
        <source>Parameter '{0}' expects type '{1}', but the provided value has type '{2}'</source>
        <target state="translated">参数 ‘{0}’ 需要类型 ‘{1}’，但提供的值类型为 ‘{2}’</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentConflictingTypes">
        <source>Found two conflicting types for generic parameter '{0}'. The conflicting types are '{1}' and '{2}'.</source>
        <target state="translated">发现泛型参数 '{0}' 的两个冲突类型。冲突类型 '{1}' 和 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentNotResolved">
        <source>The type of the generic parameter '{0}' could not be inferred.</source>
        <target state="translated">无法推断 '{0}' 泛型参数的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow 应仅在测试方法上进行设置</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow 应有效</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">不要对布尔断言求反，而是使用相反的断言</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">不要对布尔断言求反</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">不要将 TestContext 存储在静态成员中</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">不要将 TestContext 存储在静态成员中</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">对测试成员进行影子处理可能会导致测试问题(如 NRE)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' already exists in the base class</source>
        <target state="translated">基类中已存在成员“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">不使用影子处理</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">“System.ComponentModel.DescriptionAttribute” 在测试上下文中无效，你可能想要改用 “Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute”。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">是否打算使用 “Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute”?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">“System.ComponentModel.DescriptionAttribute” 对测试方法没有影响</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowMessageFormat">
        <source>Do not duplicate 'DataRow' attributes. This is usually a copy/paste error. The attribute indices are '{0}' and '{1}'.</source>
        <target state="translated">不要复制 'DataRow' 属性。这通常是复制/粘贴错误。属性索引为“{0}”和“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowTitle">
        <source>Avoid duplicated 'DataRow' entries</source>
        <target state="translated">避免重复的 'DataRow' 条目</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">"DynamicData" 条目应具有以下布局才能有效:
- 应仅对测试方法设置；
- 应对指定的类型定义成员；
- 如果指定了 DynamicDataSourceType.Method，则成员应为方法，否则应为属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">"[DynamicData]" 数据成员 "{0}.{1}" 签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">"[DynamicData]" 显示名称方法 "{0}.{1}" 签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">"[DynamicData]" 成员 "{0}.{1}" 应为方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">找不到 "[DynamicData]" 成员 "{0}.{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">"[DynamicData]" 引用的成员 "{0}.{1}" 应返回 "IEnumerable&lt;object[]&gt;"、"IEnumerable&lt;Tuple&gt;" 或 "IEnumerable&lt;ValueTuple&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">应仅对测试方法设置 "[DynamicData]"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeField">
        <source>'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Method' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' 成员 “{0}.{1}” 是一个方法，因此应使用 “DynamicDataSourceType.AutoDetect” 或 “DynamicDataSourceType.Method”，(未显式指定时，自动检测为默认值，建议)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyMethodOrField">
        <source>'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyOrMethod">
        <source>'[DynamicData]' member '{0}.{1}' is not a property nor a method. Only properties and methods are supported.</source>
        <target state="translated">'[DynamicData]' 成员 “{0}.{1}” 既不是属性也不是方法。仅支持属性和方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Property' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' 成员 “{0}.{1}” 是属性，因此应使用 “DynamicDataSourceType.AutoDetect” 或 “DynamicDataSourceType.Property”，(自动检测在未显式指定时为默认值，建议)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicData]' member '{0}.{1}' is found more than once</source>
        <target state="translated">多次找到 "[DynamicData]" 成员“{0}.{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData 应有效</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenDescription">
        <source>When calling async methods that have overloads accepting a CancellationToken parameter, prefer using the overload with TestContext.CancellationTokenSource.Token to enable cooperative cancellation and respect test timeouts.</source>
        <target state="translated">在调用包含接受 CancellationToken 参数的重载的异步方法时，建议使用 TestContext.CancellationTokenSource.Token 的重载，以启用协作取消并遵守测试超时。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenMessageFormat">
        <source>Consider using the overload that accepts a CancellationToken and pass 'TestContext.CancellationTokenSource.Token'</source>
        <target state="translated">请考虑使用接受 CancellationToken 的重载，并传递 'TestContext.CancellationTokenSource.Token'</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenTitle">
        <source>Flow TestContext.CancellationToken to async operations</source>
        <target state="translated">将 TestContext.CancellationToken 传递给异步操作</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidDescription">
        <source>Methods marked with '[GlobalTestInitialize]' or '[GlobalTestCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public'
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">标记有 "[GlobalTestInitialize]" 或 "[GlobalTestCleanup]" 的方法应遵循以下布局才会有效:
- 不能在泛型类上声明它
- 它应为 "public"
- 它应为 "static"
- 它不应为 "async void"
- 它不应是特殊方法(终结器、运算符...)。
- 它不应是泛型的
- 它应采用 "TestContext" 类型的一个参数
- 返回类型应为 "void"、"Task" 或 "ValueTask"

声明这些方法的类型还应遵循以下规则:
- 类型应为类
- 类应该为 "public"
- 类不应为 "static"
- 应使用 "[TestClass]"（或派生属性）标记类
- 类不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidMessageFormat">
        <source>Global test fixture method '{0}' signature is invalid</source>
        <target state="translated">全局测试固定例程方法 "{0}" 签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidTitle">
        <source>GlobalTestInitialize and GlobalTestCleanup methods should have valid layout</source>
        <target state="translated">GlobalTestInitialize 和 GlobalTestCleanup 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">使用 “Assert.Fail” 而不是始终失败的 “Assert.{0}” 断言</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">使用 “Assert.Fail” 而不是始终失败的断言</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerDescription">
        <source>'DataTestMethodAttribute' is obsolete and provides no additional functionality over 'TestMethodAttribute'. Use 'TestMethodAttribute' for all test methods, including parameterized tests.</source>
        <target state="translated">'DataTestMethodAttribute' 已过时，并且不再提供 'TestMethodAttribute' 之外的其他功能。对所有测试方法(包括参数化测试)使用 'TestMethodAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerMessageFormat">
        <source>'DataTestMethod' is obsolete. Use 'TestMethod' instead.</source>
        <target state="translated">'DataTestMethod' 已过时。请改用 'TestMethod'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerTitle">
        <source>Prefer 'TestMethod' over 'DataTestMethod'</source>
        <target state="translated">首选 'TestMethod' 而不是 'DataTestMethod'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">查看或移除断言，因为已知其条件始终为 true</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">断言条件始终为 true</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">首选构造函数而不是 TestInitialize 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">首选构造函数而不是 TestInitialize 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">首选 “Dispose” 而不是 TestCleanup 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">首选 “Dispose” 而不是 TestCleanup 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">首选 TestCleanup 而不是 “Dispose” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">首选 TestCleanup 而不是 “Dispose” 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">首选 TestInitialize 方法而不是构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">首选 TestInitialize 方法而不是构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="translated">公共方法应为测试方法(标记为 `[TestMethod]`)。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="translated">公共方法“{0}”应为测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="translated">公共方法应为测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">在测试项目中仅将测试类标记为“公开”是一种不错的做法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">公共类型“{0}”应标记为“[TestClass]”或更改为“internal”</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">公共类型应为测试类</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertMessageFormat">
        <source>Use 'Assert.{0}' instead of 'StringAssert.{1}'</source>
        <target state="translated">使用 'Assert.{0}' 而不是 'StringAssert.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertTitle">
        <source>Use 'Assert' instead of 'StringAssert'</source>
        <target state="translated">使用 'Assert' 而不是 'StringAssert'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">测试类“{0}”应该有效</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">属性 "TestContext" 应该有效</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">测试方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">如果不使用 "ClassCleanupBehavior.EndOfClass"，"[ClassCleanup]" 将默认在程序集末尾运行，而不是在类的末尾运行。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">将 "ClassCleanupBehavior.EndOfClass" 与 "[ClassCleanup]" 配合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">将 "ClassCleanupBehavior.EndOfClass" 与 "[ClassCleanup]" 配合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">测试类(标记有“[TestClass]”属性的类)应遵循以下布局，才能被 MSTest 视为有效:
- 它应为 "public" (如果设置了“[assembly: DiscoverInternals]”属性，则应为 "internal")
- 它不应为 "static" (除非它只包含 "AssemblyInitialize" 和/或 "AssemblyCleanup" 方法)
- 它不应是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">测试类应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">测试类应至少有一个测试方法，或者应为 "static" 且方法由 "[AssemblyInitialize]" 和/或 "[AssemblyCleanup]" 标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">测试类 "{0}" 应至少有一个测试方法，或者应为 "static" 且方法由 "[AssemblyInitialize]" 和/或 "[AssemblyCleanup]" 标记</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">测试类应具有测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">标记有“[TestCleanup]”的方法应遵循以下布局才会有效:
- 它应为“public”
- 它不应为“abstract”
- 它不应为“async void”
- 它不应为“static”
- 它不应是特殊方法(终结器、运算符...)。
- 它不应是泛型的
- 它不应采用任何参数
- 返回类型应为“void”、“Task”或“ValueTask”

声明这些方法的类型还应遵循以下规则:
-类型应为类
-类应为“public”或“internal”(如果测试项目正在使用“[DiscoverInternals]”属性)
-类不应为“static”
-如果类为“sealed”，则应使用“[TestClass]”(或派生属性)标记该类。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">TestCleanup 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">TestCleanup 方法应该具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>'TestContext' should be a non-static field or property assigned in constructor or for a property set by MSTest, it should follow the layout:
- it should be 'public' regardless of whether '[assembly: DiscoverInternals]' attribute is set or not.
- it should not be 'static'
- it should have a setter.</source>
        <target state="translated">"TestContext" 应该是构造函数中分配的非静态字段或属性，或者对于 MSTest 设置的属性，它应遵循以下布局:
- 无论是否设置 "[assembly: DiscoverInternals]" 属性，它都应为 "public"。
- 它不应为 "static"
- 它应具有一个资源库。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">测试上下文属性应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">标记有“[TestInitialize]”的方法应遵循以下布局才会有效:
- 它应为“public”
- 它不应为“abstract”
- 它不应为“async void”
- 它不应为“static”
- 它不应是特殊方法(终结器、运算符...)。
- 它不应是泛型的
- 它不应采用任何参数
- 返回类型应为“void”、“Task”或“ValueTask”

声明这些方法的类型还应遵循以下规则:
-类型应为类
-类应为“public”或“internal”(如果测试项目正在使用“[DiscoverInternals]”属性)
-类不应为“static”
-如果类为“sealed”，则应使用“[TestClass]”(或派生属性)标记该类。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">TestInitialize 方法“{0}”签名无效</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">TestInitialize 方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should may be generic as long as type parameters can be inferred and argument types are compatible
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">测试方法(标记有 "[TestMethod]" 属性的方法)应遵循以下布局，以便 MSTest 将其视为有效:
- 它应该是 "public" (如果设置了 "[assembly: DiscoverInternals]" 属性，则应该是 "internal")
- 它不应为 "static"
- 只要可以推断类型参数并且参数类型兼容，它就应该是泛型
- 它不应为 "abstract"
- 返回类型应为 "void”、"Task" 或 "ValueTask"
- 它不应为 "async void"
- 它不应是特殊方法(终结器、运算符...)。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">测试方法应具有有效的布局</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">不应忽略测试方法(标记有 "[Ignore]")。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">不应忽略测试方法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">不应忽略测试方法</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">应使用 "[TestClass]" 标记包含 "[TestMethod]" 的类型，否则将以静默方式忽略该测试方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Type '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">类型 "{0}" 包含测试方法，应使用 "[TestClass]" 进行标记</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">应使用“[TestClass]”标记包含“[TestMethod]”的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">异步测试固定例程方法不需要 "Async" 后缀</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">异步测试方法不需要 "Async" 后缀</target>
        <note />
      </trans-unit>
      <trans-unit id="UnusedParameterSuppressorJustification">
        <source>TestContext parameter is required by MSTest for AssemblyInitialize and ClassInitialize methods</source>
        <target state="translated">AssemblyInitialize 和 ClassInitialize 方法的 MSTest 需要 TestContext 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">只能对标记了 [TestMethod] 的方法设置 [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">只能对标记了 [TestMethod] 的方法设置 [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassMessageFormat">
        <source>The attribute '{0}' which derives from 'ConditionBaseAttribute' should be used only on classes marked with `TestClassAttribute`</source>
        <target state="translated">派生自 “ConditionBaseAttribute” 的属性 '{0}' 只能在标记为 “TestClassAttribute” 的类上使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassTitle">
        <source>Use 'ConditionBaseAttribute' on test classes</source>
        <target state="translated">对测试类使用 “ConditionBaseAttribute”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutDescription">
        <source>Using '[Timeout]' without explicitly setting 'CooperativeCancellation = true' is discouraged. In a future version, cooperative cancellation will become the default behavior. Set 'CooperativeCancellation = true' to opt into the recommended behavior and avoid breaking changes.</source>
        <target state="translated">不建议在不显式设置 'CooperativeCancellation = true' 的情况下使用 '[Timeout]'。在将来的版本中，协作取消将成为默认行为。设置 'CooperativeCancellation = true' 以选择加入建议的行为，并避免中断性变更。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutMessageFormat">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]' to enable cooperative cancellation behavior</source>
        <target state="translated">将 'CooperativeCancellation = true' 与 '[Timeout]' 配合使用以启用协作取消行为</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutTitle">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]'</source>
        <target state="translated">将 'CooperativeCancellation = true' 与 '[Timeout]' 配合使用</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">只能对测试类或测试方法指定 "[DeploymentItem]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">只能对测试类或测试方法指定 "[DeploymentItem]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsMessageFormat">
        <source>Use 'Assert.ThrowsExactly' instead of 'Assert.ThrowsException'</source>
        <target state="translated">使用 “Assert.ThrowsExactly” 而不是 “Assert.ThrowsException”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsTitle">
        <source>Use newer methods to assert exceptions</source>
        <target state="translated">使用较新的方法断言异常</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">默认情况下，MSTest 将按顺序在同一程序集中运行测试，这可能会导致严重的性能限制。建议启用程序集属性“[Parallelize]”以并行运行测试，或者如果已知程序集不可并行，则显式使用程序集级别属性“DoNotParallelize”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">显式启用或禁用测试并行化</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">显式启用或禁用测试并行化</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsMessageFormat">
        <source>Use 'Assert.{0}' instead of 'Assert.{1}'</source>
        <target state="translated">使用“Assert.{0}”而不是“Assert.{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsTitle">
        <source>Use proper 'Assert' methods</source>
        <target state="translated">使用正确的“断言”方法</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodMessageFormat">
        <source>An attribute that derives from 'RetryBaseAttribute' can be specified only on a test method</source>
        <target state="translated">只能在测试方法上指定派生自 ‘RetryBaseAttribute’ 的属性</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodTitle">
        <source>Use retry attribute on test method</source>
        <target state="translated">对测试方法使用重试属性</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageTitle">
        <source>TestContext property cannot be accessed in this context</source>
        <target state="translated">无法在此上下文中访问 TestContext 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageMessageFormat">
        <source>TestContext property '{0}' cannot be accessed in '{1}' method</source>
        <target state="translated">无法在 ‘{1}’ 方法中访问 TestContext 属性 ‘{0}’</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageDescription">
        <source>Some TestContext properties are only available during test execution and cannot be accessed in assembly initialize, class initialize, class cleanup, or assembly cleanup methods.</source>
        <target state="translated">一些 TestContext 属性仅在测试执行期间可用，并且无法在程序集初始化、类初始化、类清理或程序集清理方法中访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementDescription">
        <source>Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</source>
        <target state="new">Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementMessageFormat">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementTitle">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>