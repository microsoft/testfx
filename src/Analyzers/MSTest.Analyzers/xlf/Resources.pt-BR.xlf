<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../Resources.resx">
    <body>
      <trans-unit id="AssemblyCleanupShouldBeValidDescription">
        <source>Methods marked with '[AssemblyCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Os métodos marcados com '[AssemblyCleanup]' devem seguir o seguinte layout para serem válidos:
-não pode ser declarado em uma classe genérica
-deve ser 'public'
-deve ser 'static'
-não deve ser 'async void'
-não deve ser um método especial (finalizador, operador...).
-ele não deve ser genérico
-ele não deve ter nenhum parâmetro ou usar um único parâmetro do tipo 'TestContext'
-o tipo de retorno deve ser 'void', 'Task' ou 'ValueTask'

O tipo declarando esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser 'public' ou 'internal' (se o projeto de teste estiver usando o '[DiscoverInternals]' atributo)
-A classe não deve ser 'static'
-A classe deve ser marcada com '[TestClass]' (ou um atributo derivado)
-a classe não deve ser genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidMessageFormat">
        <source>AssemblyCleanup method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método AssemblyCleanup "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyCleanupShouldBeValidTitle">
        <source>AssemblyCleanup methods should have valid layout</source>
        <target state="translated">Os métodos AssemblyCleanup devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidDescription">
        <source>Methods marked with '[AssemblyInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Os métodos marcados com “[AssemblyInitialize]” devem seguir o seguinte layout para serem válidos:
-não podem ser declarados em uma classe genérica
-devem ser "públicos"
-devem ser "estáticos"
-não devem ser "nulos assíncronos"
-não devem ser um método especial (finalizador, operador...).
-não devem ser genéricos
-devem usar um parâmetro do tipo “TestContext”
-o tipo de retorno deve ser “nulo”, “Tarefa” ou “ValueTask”

O tipo que declara esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser “público” ou '”interno” (se o projeto de teste estiver usando o atributo “[DiscoverInternals]”)
-A classe não deve ser “estático”
-A classe deve ser marcada com “[TestClass]” (ou um atributo derivado)
-a classe não deve ser genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidMessageFormat">
        <source>AssemblyInitialize method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método AssemblyInitialize "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyInitializeShouldBeValidTitle">
        <source>AssemblyInitialize methods should have valid layout</source>
        <target state="translated">Os métodos AssemblyInitialize devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessMessageFormat">
        <source>Prefer adding an additional assertion that checks for null</source>
        <target state="translated">Preferir adicionar uma declaração adicional que verifica se existe um nulo</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldAvoidConditionalAccessTitle">
        <source>Avoid conditional access in assertions</source>
        <target state="translated">Evitar o acesso condicional nas declarações</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderDescription">
        <source>'Assert.AreEqual', 'Assert.AreNotEqual', 'Assert.AreSame' and 'Assert.AreNotSame' expects the expected value to be passed first and the actual value to be passed as second argument.</source>
        <target state="translated">"Assert.AreEqual", "Assert.AreNotEqual", "Assert.AreSame" e "Assert.AreNotSame" esperam que o valor esperado seja passado primeiro e o valor real seja passado como o segundo argumento.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderMessageFormat">
        <source>Assertion arguments should be passed in the correct order. 'actual' and 'expected'/'notExpected' arguments have been swapped.</source>
        <target state="translated">Os argumentos de asserção devem ser passados na ordem correta. Os argumentos "actual" e "expected"/"notExpected" foram trocados.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionArgsShouldBePassedInCorrectOrderTitle">
        <source>Assertion arguments should be passed in the correct order</source>
        <target state="translated">Os argumentos de asserção devem ser passados na ordem correta</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesDescription">
        <source>Use 'Assert.AreEqual'/'Assert.AreNotEqual' instead of 'Assert.AreSame'/'Assert.AreNotSame' when comparing value types. Passing a value type to 'Assert.AreSame'/'Assert.AreNotSame' will be boxed (creating a new object). Because 'Assert.AreSame'/'Assert.AreNotSame' does the comparison by reference, 'Assert.AreSame' will fail when boxing happens, and 'Assert.AreNotSame' will always pass.</source>
        <target state="translated">Use 'Assert.AreEqual'/'Assert.AreNotEqual' em vez de 'Assert.AreSame'/'Assert.AreNotSame' ao comparar tipos de valor. Passar um tipo de valor para 'Assert.AreSame'/'Assert.AreNotSame' será em caixa (criando um novo objeto). Como 'Assert.AreSame'/'Assert.AreNotSame' faz a comparação por referência, 'Assert.AreSame' falhará quando ocorrer boxing e 'Assert.AreNotSame' sempre será aprovado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesMessageFormat">
        <source>Use '{0}' instead of '{1}' when comparing value types</source>
        <target state="translated">Usar '{0}' em vez de '{1}' ao comparar tipos de valor</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAssertAreSameWithValueTypesTitle">
        <source>Don't use 'Assert.AreSame' or 'Assert.AreNotSame' with value types</source>
        <target state="translated">Não use 'Assert.AreSame' ou 'Assert.AreNotSame' com tipos de valor</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeDescription">
        <source>Prefer 'Assert.ThrowsExactly' or 'Assert.ThrowsExactlyAsync' over '[ExpectedException]' as it ensures that only the expected call throws the expected exception. The assert APIs also provide more flexibility and allow you to assert extra properties of the exception.</source>
        <target state="translated">Prefira 'Assert.ThrowsExactly' ou 'Assert.ThrowsExactlyAsync' em vez de '[ExpectedException]', pois isso garante que apenas a chamada esperada lance a exceção esperada. As APIs de assert também oferecem mais flexibilidade e permitem que você afirme propriedades adicionais da exceção.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeMessageFormat">
        <source>Prefer 'Assert.ThrowsExactly/ThrowsExactlyAsync' over '[ExpectedException]'</source>
        <target state="translated">Prefira 'Assert.ThrowsExactly/ThrowsExactlyAsync' em vez de '[ExpectedException]'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExpectedExceptionAttributeTitle">
        <source>Avoid '[ExpectedException]'</source>
        <target state="translated">Evitar '[ExpectedException]'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeMessageFormat">
        <source>Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</source>
        <target state="new">Remove the 'DynamicDataSourceType' argument to use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExplicitDynamicDataSourceTypeTitle">
        <source>Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</source>
        <target state="new">Avoid passing an explicit 'DynamicDataSourceType' and use the default auto detect behavior</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextDescription">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas. Exceptions that are thrown in this context will be unhandled exceptions. When using VSTest under .NET Framework, they will be silently swallowed. When using Microsoft.Testing.Platform or VSTest under modern .NET, they may crash the process.</source>
        <target state="translated">Não asserção dentro de métodos 'async void', funções locais ou lambdas. Exceções lançadas neste contexto serão exceções sem tratamento. Ao usar VSTest sob .NET Framework, eles serão silenciosamente ignoradas. Ao usar Microsoft.Testing.Platform ou VSTest em .NET moderno, o processo pode falhar.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextMessageFormat">
        <source>Do not assert inside 'async void' methods, local functions, or lambdas because they may not fail the test</source>
        <target state="translated">Não declarar dentro de métodos 'async void', funções locais ou lambdas porque eles podem não falhar no teste</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingAssertsInAsyncVoidContextTitle">
        <source>Do not assert inside 'async void' contexts</source>
        <target state="translated">Não declarar dentro de contextos 'async void'</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidDescription">
        <source>Methods marked with '[ClassCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should either not take any parameter, or take a single parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Os métodos marcados com '[ClassCleanup]' devem seguir o seguinte layout para serem válidos:
-não pode ser declarado em uma classe genérica sem que o modo 'InheritanceBehavior' esteja definido
-deve ser 'public'
-deve ser 'static'
-não deve ser 'async void'
-não deve ser um método especial (finalizador, operador...).
-ele não deve ser genérico
-ele não deve ter nenhum parâmetro ou usar um único parâmetro do tipo 'TestContext'
-o tipo de retorno deve ser 'void', 'Task' ou 'ValueTask'
O parâmetro de atributo -'InheritanceBehavior.BeforeEachDerivedClass' deve ser especificado se a classe for 'abstract'
O parâmetro de atributo -'InheritanceBehavior.BeforeEachDerivedClass' não deve ser especificado se a classe for 'sealed'

O tipo declarando esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser 'public' ou 'internal' (se o projeto de teste estiver usando o '[DiscoverInternals]' atributo)
-A classe não deve ser 'static'
-Se a classe for 'sealed', ela deverá ser marcada com '[TestClass]' (ou um atributo derivado)
-a classe não deve ser genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidMessageFormat">
        <source>ClassCleanup method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método ClassCleanup "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassCleanupShouldBeValidTitle">
        <source>ClassCleanup methods should have valid layout</source>
        <target state="translated">Os métodos ClassCleanup devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidDescription">
        <source>Methods marked with '[ClassInitialize]' should follow the following layout to be valid:
-it can't be declared on a generic class without the 'InheritanceBehavior' mode is set
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should be specified if the class is 'abstract'
-'InheritanceBehavior.BeforeEachDerivedClass' attribute parameter should not be specified if the class is 'sealed'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Os métodos marcados com “[ClassInitialize]” devem seguir o seguinte layout para serem válidos:
-não podem ser declarados em uma classe genérica sem que o modo “InheritanceBehavior” esteja definido
-devem ser "públicos"
-devem ser "estáticos"
-não devem ser "nulos assíncronos"
-não devem ser um método especial (finalizador, operador...).
-não devem ser genéricos
-devem usar um parâmetro do tipo “TestContext”
-o tipo de retorno deve ser “nulo”, “Tarefa” ou “ValueTask”
-"InheritanceBehavior.BeforeEachDerivedClass" deve ser especificado se a classe for "abstrato"
-'InheritanceBehavior.BeforeEachDerivedClass' não deverá ser especificado se a classe for “selado”

O tipo que declara esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser “público” ou '”interno” (se o projeto de teste estiver usando o atributo “[DiscoverInternals]”)
-A classe não deve ser “estático”
-Se a classe for “selado”, ela deverá ser marcada com “[TestClass]” (ou um atributo derivado)
-a classe não deve ser genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidMessageFormat">
        <source>ClassInitialize method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método ClassInitialize "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="ClassInitializeShouldBeValidTitle">
        <source>ClassInitialize methods should have valid layout</source>
        <target state="translated">Os métodos ClassInitialize devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidDescription">
        <source>DataRow entry should have the following layout to be valid:
- should only be set on a test method;
- argument count should match method argument count;
- argument type should match method argument type.</source>
        <target state="translated">A entrada DataRow deve ter o seguinte layout para ser válida:
- só deve ser definido em um método de teste;
- a contagem de argumentos deve corresponder à contagem de argumentos do método;
- o tipo de argumento deve corresponder ao tipo de argumento do método.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentCountMismatch">
        <source>DataRow argument count should match method parameter count (constructor arguments: {0}, method parameters: {1})</source>
        <target state="translated">A contagem de argumentos DataRow deve corresponder à contagem de parâmetros do método (argumentos do construtor: {0}, parâmetros do método: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ArgumentTypeMismatch">
        <source>DataRow argument types do not match method parameter types. {0}</source>
        <target state="translated">Os tipos de argumento do DataRow não correspondem aos tipos de parâmetro do método. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_ParameterMismatch">
        <source>Parameter '{0}' expects type '{1}', but the provided value has type '{2}'</source>
        <target state="translated">O parâmetro "{0}" espera o tipo "{1}", mas o valor fornecido tem o tipo "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentConflictingTypes">
        <source>Found two conflicting types for generic parameter '{0}'. The conflicting types are '{1}' and '{2}'.</source>
        <target state="translated">Foram encontrados dois tipos conflitativos para parâmetro genérico '{0}'. Os tipos conflitativos são '{1}' e '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_GenericTypeArgumentNotResolved">
        <source>The type of the generic parameter '{0}' could not be inferred.</source>
        <target state="translated">Não foi possível inferir o tipo '{0}' parâmetro genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidMessageFormat_OnTestMethod">
        <source>DataRow should only be set on a test method</source>
        <target state="translated">DataRow só deve ser definido em um método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="DataRowShouldBeValidTitle">
        <source>DataRow should be valid</source>
        <target state="translated">DataRow deve ser válido</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionMessageFormat">
        <source>Do not negate boolean assertions, instead use the opposite assertion</source>
        <target state="translated">Não negue asserções boolianas; em vez disso, use a asserção oposta</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotNegateBooleanAssertionTitle">
        <source>Do not negate boolean assertions</source>
        <target state="translated">Não negue asserções booleanas</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerMessageFormat">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Não armazene TestContext em um membro estático</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreStaticTestContextAnalyzerTitle">
        <source>Do not store TestContext in a static member</source>
        <target state="translated">Não armazene TestContext em um membro estático</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingDescription">
        <source>Shadowing test members could cause testing issues (such as NRE).</source>
        <target state="translated">Membros de teste de sombreamento podem causar problemas de teste (como NRE).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingMessageFormat">
        <source>Member '{0}' already exists in the base class</source>
        <target state="translated">O membro "{0}" já existe na classe base</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseShadowingTitle">
        <source>Do not use shadowing</source>
        <target state="translated">Não usar sombreamento</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeDescription">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect in the context of tests and you likely wanted to use 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute' instead.</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' não tem efeito no contexto de testes e você provavelmente quis usar 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeMessageFormat">
        <source>Did you mean to be using 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</source>
        <target state="translated">Você pretendia usar 'Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute'?</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSystemDescriptionAttributeTitle">
        <source>'System.ComponentModel.DescriptionAttribute' has no effect on test methods</source>
        <target state="translated">'System.ComponentModel.DescriptionAttribute' não tem efeito sobre métodos de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowMessageFormat">
        <source>Do not duplicate 'DataRow' attributes. This is usually a copy/paste error. The attribute indices are '{0}' and '{1}'.</source>
        <target state="translated">Não duplique os atributos 'DataRow'. Normalmente, isso é um erro de copiar/colar. Os índices de atributo são '{0}' e '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateDataRowTitle">
        <source>Avoid duplicated 'DataRow' entries</source>
        <target state="translated">Evite entradas duplicadas 'DataRow'</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidDescription">
        <source>'DynamicData' entry should have the following layout to be valid:
- should only be set on a test method;
- member should be defined on the type specified;
- member should be a method if DynamicDataSourceType.Method is specified or a property otherwise.</source>
        <target state="translated">A entrada de "DynamicData" deve ter o seguinte layout para ser válida:
- só deve ser definido em um método de teste;
– o membro deve ser definido no tipo especificado;
– o membro deve ser um método se DynamicDataSourceType.Method for especificado ou uma propriedade de outra forma.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DataMemberSignature">
        <source>'[DynamicData]' data member '{0}.{1}' signature is invalid</source>
        <target state="translated">A assinatura do membro de dados "{0}.{1}" de "[DynamicData]" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_DisplayMethodSignature">
        <source>'[DynamicData]' display name method '{0}.{1}' signature is invalid</source>
        <target state="translated">A assinatura do método de nome de exibição "{0}.{1}" de "[DynamicData]" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberMethod">
        <source>'[DynamicData]' member '{0}.{1}' should be a method</source>
        <target state="translated">O membro "{0}.{1}" de "[DynamicData]" deve ser um método</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberNotFound">
        <source>'[DynamicData]' member '{0}.{1}' cannot be found</source>
        <target state="translated">O membro "{0}.{1}" de "[DynamicData]" não pode ser encontrado</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_MemberType">
        <source>'[DynamicData]' referenced member '{0}.{1}' should return 'IEnumerable&lt;object[]&gt;', 'IEnumerable&lt;Tuple&gt;` or 'IEnumerable&lt;ValueTuple&gt;'</source>
        <target state="translated">O membro referenciado "{0}.{1}" de "[DynamicData]" deve retornar "IEnumerable&lt;object[]&gt;", "IEnumerable&lt;Tuple&gt;" ou "IEnumerable&lt;ValueTuple&gt;"</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_OnTestMethod">
        <source>'[DynamicData]' should only be set on a test method</source>
        <target state="translated">"[DynamicData]" só deve ser definido em um método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeField">
        <source>'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is a field so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Field' (auto detect is the default when not specified explicitly, and is recommended)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeMethod">
        <source>'[DynamicData]' member '{0}.{1}' is a method so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Method' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' é um método, portanto, você deve usar 'DynamicDataSourceType.AutoDetect' ou 'DynamicDataSourceType.Method' (detectar automaticamente é o padrão quando não especificado explicitamente e é recomendado)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyMethodOrField">
        <source>'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</source>
        <target state="new">'[DynamicData]' member '{0}.{1}' is not a property, method, or field. Only properties, methods, and fields are supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeNotPropertyOrMethod">
        <source>'[DynamicData]' member '{0}.{1}' is not a property nor a method. Only properties and methods are supported.</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' não é uma propriedade nem um método. Somente propriedades e métodos têm suporte.</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_SourceTypeProperty">
        <source>'[DynamicData]' member '{0}.{1}' is a property so you should use 'DynamicDataSourceType.AutoDetect' or 'DynamicDataSourceType.Property' (auto detect is the default when not specified explicitly, and is recommended)</source>
        <target state="translated">'[DynamicData]' membro '{0}.{1}' é uma propriedade, portanto, você deve usar 'DynamicDataSourceType.AutoDetect' ou 'DynamicDataSourceType.Property' (detectar automaticamente é o padrão quando não especificado explicitamente e é recomendado)</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidMessageFormat_TooManyMembers">
        <source>'[DynamicData]' member '{0}.{1}' is found more than once</source>
        <target state="translated">O membro '[DynamicData]' '{0}.{1}' foi encontrado mais de uma vez</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataShouldBeValidTitle">
        <source>DynamicData should be valid</source>
        <target state="translated">DynamicData deve ser válido</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenDescription">
        <source>When calling async methods that have overloads accepting a CancellationToken parameter, prefer using the overload with TestContext.CancellationTokenSource.Token to enable cooperative cancellation and respect test timeouts.</source>
        <target state="translated">Ao chamar métodos assíncronos que tenham sobrecargas que aceitam um parâmetro CancellationToken, prefira usar a sobrecarga com TestContext.CancellationTokenSource.Token para habilitar o cancelamento cooperativo e respeitar os tempos limite do teste.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenMessageFormat">
        <source>Consider using the overload that accepts a CancellationToken and pass 'TestContext.CancellationTokenSource.Token'</source>
        <target state="translated">Considere usar a sobrecarga que aceita um CancellationToken e passar "TestContext.CancellationTokenSource.Token"</target>
        <note />
      </trans-unit>
      <trans-unit id="FlowTestContextCancellationTokenTitle">
        <source>Flow TestContext.CancellationToken to async operations</source>
        <target state="translated">Fluxo TestContext.CancellationToken para operações assíncronas</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidDescription">
        <source>Methods marked with '[GlobalTestInitialize]' or '[GlobalTestCleanup]' should follow the following layout to be valid:
-it can't be declared on a generic class
-it should be 'public'
-it should be 'static'
-it should not be 'async void'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should take one parameter of type 'TestContext'
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public'
-The class shouldn't be 'static'
-The class should be marked with '[TestClass]' (or a derived attribute)
-the class should not be generic.</source>
        <target state="translated">Os métodos marcados com "[GlobalTestInitialize]" ou "[GlobalTestCleanup]" devem seguir o seguinte layout para serem válidos:
-não podem ser declarados em uma classe genérica
-devem ser "públicos"
-devem ser "estáticos"
-não devem ser "nulos assíncronos"
-não devem ser um método especial (finalizador, operador...).
-não devem ser genéricos
-devem usar um parâmetro do tipo “TestContext”
-o tipo de retorno deve ser “nulo”, “Tarefa” ou “ValueTask”

O tipo que declara esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser "público"
-A classe não deve ser “estático”
-A classe deve ser marcada com “[TestClass]” (ou um atributo derivado)
-a classe não deve ser genérica.</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidMessageFormat">
        <source>Global test fixture method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método de acessório de teste global "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="GlobalTestFixtureShouldBeValidTitle">
        <source>GlobalTestInitialize and GlobalTestCleanup methods should have valid layout</source>
        <target state="translated">Os métodos GlobalTestInitialize e GlobalTestCleanup devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsMessageFormat">
        <source>Use 'Assert.Fail' instead of an always-failing 'Assert.{0}' assert</source>
        <target state="translated">Use "Assert.Fail" em vez de uma asserção "Assert.{0}" sempre com falha</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferAssertFailOverAlwaysFalseConditionsTitle">
        <source>Use 'Assert.Fail' instead of an always-failing assert</source>
        <target state="translated">Usar "Assert.Fail" em vez de uma asserção sempre com falha</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerDescription">
        <source>'DataTestMethodAttribute' is obsolete and provides no additional functionality over 'TestMethodAttribute'. Use 'TestMethodAttribute' for all test methods, including parameterized tests.</source>
        <target state="translated">'DataTestMethodAttribute' está obsoleto e não oferece funcionalidade adicional em relação a 'TestMethodAttribute'. Use 'TestMethodAttribute' para todos os métodos de teste, inclusive testes parametrizados.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerMessageFormat">
        <source>'DataTestMethod' is obsolete. Use 'TestMethod' instead.</source>
        <target state="translated">'DataTestMethod' está obsoleto. Use 'TestMethod' em vez disso.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestMethodOverDataTestMethodAnalyzerTitle">
        <source>Prefer 'TestMethod' over 'DataTestMethod'</source>
        <target state="translated">Prefira 'TestMethod' a 'DataTestMethod'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerMessageFormat">
        <source>Review or remove the assertion as its condition is known to be always true</source>
        <target state="translated">Examine ou remova a asserção, pois a sua condição é conhecida por ser sempre verdadeira</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewAlwaysTrueAssertConditionAnalyzerTitle">
        <source>Assertion condition is always true</source>
        <target state="translated">A condição de asserção é sempre verdadeira</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeMessageFormat">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Preferir construtores em vez de métodos TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferConstructorOverTestInitializeTitle">
        <source>Prefer constructors over TestInitialize methods</source>
        <target state="translated">Preferir construtores em vez de métodos TestInitialize</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupMessageFormat">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Preferir métodos "Dispose" em vez de TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferDisposeOverTestCleanupTitle">
        <source>Prefer 'Dispose' over TestCleanup methods</source>
        <target state="translated">Preferir métodos "Dispose" em vez de TestCleanup</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeMessageFormat">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Preferir métodos TestCleanup em vez de "Dispose"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestCleanupOverDisposeTitle">
        <source>Prefer TestCleanup over 'Dispose' methods</source>
        <target state="translated">Preferir métodos TestCleanup em vez de "Dispose"</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorMessageFormat">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Preferir métodos TestInitialize em vez de construtores</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferTestInitializeOverConstructorTitle">
        <source>Prefer TestInitialize methods over constructors</source>
        <target state="translated">Preferir métodos TestInitialize em vez de construtores</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerDescription">
        <source>Public methods should be test methods (marked with `[TestMethod]`).</source>
        <target state="translated">Os métodos públicos devem ser métodos de teste (marcados com `[TestMethod]`).</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerFormat">
        <source>Public method '{0}' should be a test method</source>
        <target state="translated">O método público '{0}' deve ser um método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicMethodShouldBeTestMethodAnalyzerTitle">
        <source>Public methods should be test methods</source>
        <target state="translated">Os métodos públicos devem ser métodos de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassDescription">
        <source>It's considered a good practice to have only test classes marked public in a test project.</source>
        <target state="translated">É considerado uma boa prática ter somente classes de teste marcadas como públicas em um projeto de teste.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassMessageFormat">
        <source>Public type '{0}' should be marked with '[TestClass]' or changed to 'internal'</source>
        <target state="translated">O tipo público ''{0}'' deve ser marcado com ''[TestClass]'' ou alterado para 'interno'</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicTypeShouldBeTestClassTitle">
        <source>Public types should be test classes</source>
        <target state="translated">Os tipos públicos devem ser classes de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertMessageFormat">
        <source>Use 'Assert.{0}' instead of 'StringAssert.{1}'</source>
        <target state="translated">Use "Assert.{0}" em vez de "StringAssert.{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="StringAssertToAssertTitle">
        <source>Use 'Assert' instead of 'StringAssert'</source>
        <target state="translated">Usar "Assert" em vez de "StringAssert"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidMessageFormat">
        <source>Test class '{0}' should be valid</source>
        <target state="translated">A classe de teste ''{0}'' deve ser válida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidMessageFormat">
        <source>Property 'TestContext' should be valid</source>
        <target state="translated">A propriedade ''TestContext'' deve ser válida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidMessageFormat">
        <source>Test method '{0}' signature is invalid</source>
        <target state="translated">A assinatura "{0}" do método de teste é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassDescription">
        <source>Without using  'ClassCleanupBehavior.EndOfClass', the '[ClassCleanup]' will by default be run at the end of the assembly and not at the end of the class.</source>
        <target state="translated">Sem usar o "ClassCleanupBehavior.EndOfClass", o "[ClassCleanup]" será executado, por padrão, no final do assembly e não no final da classe.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassMessageFormat">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Use "ClassCleanupBehavior.EndOfClass" com o "[ClassCleanup]"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseClassCleanupBehaviorEndOfClassTitle">
        <source>Use 'ClassCleanupBehavior.EndOfClass' with the '[ClassCleanup]'</source>
        <target state="translated">Use "ClassCleanupBehavior.EndOfClass" com o "[ClassCleanup]"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidDescription">
        <source>Test classes, classes marked with the '[TestClass]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static' (except if it contains only 'AssemblyInitialize' and/or 'AssemblyCleanup' methods)
- it should not be generic.</source>
        <target state="translated">Classes de teste, classes marcadas com o atributo ''[TestClass]'', devem respeitar o layout a seguir para serem consideradas válidas pelo MSTest:
- deve ser "público" (ou "interno" se o atributo "[assembly: DiscoverInternals]" estiver definido) 
- não deve ser ''estático'' (exceto se contiver apenas os métodos ''AssemblyInitialize'' e/ou ''AssemblyCleanup'')
- não deve ser genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldBeValidTitle">
        <source>Test classes should have valid layout</source>
        <target state="translated">As classes de teste devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodDescription">
        <source>Test class should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'.</source>
        <target state="translated">A classe de teste deve ter pelo menos um método de teste ou ser 'estática' com métodos marcados por '[AssemblyInitialize]' e/ou '[AssemblyCleanup]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodMessageFormat">
        <source>Test class '{0}' should have at least one test method or be 'static' with method(s) marked by '[AssemblyInitialize]' and/or '[AssemblyCleanup]'</source>
        <target state="translated">A classe de teste '{0}' deve ter pelo menos um método de teste ou ser 'estática' com métodos marcados por '[AssemblyInitialize]' e/ou '[AssemblyCleanup]'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestClassShouldHaveTestMethodTitle">
        <source>Test class should have test method</source>
        <target state="translated">A classe de teste deve ter um método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidDescription">
        <source>Methods marked with '[TestCleanup]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Os métodos marcados com “[TestCleanup]” devem seguir o seguinte layout para serem válidos:
-devem ser "públicos"
-não devem ser “abstratos”
-não devem ser "nulos assíncronos"
-não devem ser "estáticos"
-não devem ser um método especial (finalizador, operador...).
-não devem ser genéricos
-não devem usar nenhum parâmetro
-o tipo de retorno deve ser “nulo”, “Tarefa” ou “ValueTask”

O tipo que declara esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser “público” ou '”interno” (se o projeto de teste estiver usando o atributo “[DiscoverInternals]”)
-A classe não deve ser “estático”
-Se a classe for “selado”, ela deverá ser marcada com “[TestClass]” (ou um atributo derivado).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidMessageFormat">
        <source>TestCleanup method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método TestCleanup "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestCleanupShouldBeValidTitle">
        <source>TestCleanup method should have valid layout</source>
        <target state="translated">O método TestCleanup deve ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidDescription">
        <source>'TestContext' should be a non-static field or property assigned in constructor or for a property set by MSTest, it should follow the layout:
- it should be 'public' regardless of whether '[assembly: DiscoverInternals]' attribute is set or not.
- it should not be 'static'
- it should have a setter.</source>
        <target state="translated">'TestContext' deve ser um campo ou propriedade não estática atribuída no construtor ou, para uma propriedade definida pelo MSTest, deve seguir o layout:
- deve ser 'public' independentemente de o atributo '[assembly: DiscoverInternals]' estar definido ou não.
- não deve ser 'static'
- deve ter um setter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextShouldBeValidTitle">
        <source>Test context property should have valid layout</source>
        <target state="translated">A propriedade de contexto de teste deve ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidDescription">
        <source>Methods marked with '[TestInitialize]' should follow the following layout to be valid:
-it should be 'public'
-it should not be 'abstract'
-it should not be 'async void'
-it should not be 'static'
-it should not be a special method (finalizer, operator...).
-it should not be generic
-it should not take any parameter
-return type should be 'void', 'Task' or 'ValueTask'

The type declaring these methods should also respect the following rules:
-The type should be a class
-The class should be 'public' or 'internal' (if the test project is using the '[DiscoverInternals]' attribute)
-The class shouldn't be 'static'
-If the class is 'sealed', it should be marked with '[TestClass]' (or a derived attribute).</source>
        <target state="translated">Os métodos marcados com '[TestInitialize]' devem seguir o seguinte layout para serem válidos:
-devem ser "públicos"
-não devem ser “abstratos”
-não devem ser "nulos assíncronos"
-não devem ser "estáticos"
-não devem ser um método especial (finalizador, operador...).
-não devem ser genéricos
-não devem usar nenhum parâmetro
-o tipo de retorno deve ser “nulo”, “Tarefa” ou “ValueTask”

O tipo que declara esses métodos também deve respeitar as seguintes regras:
-O tipo deve ser uma classe
-A classe deve ser “público” ou '”interno” (se o projeto de teste estiver usando o atributo “[DiscoverInternals]”)
-A classe não deve ser “estático”
-Se a classe for “selado”, ela deverá ser marcada com “[TestClass]” (ou um atributo derivado).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidMessageFormat">
        <source>TestInitialize method '{0}' signature is invalid</source>
        <target state="translated">A assinatura do método TestInitialize "{0}" é inválida</target>
        <note />
      </trans-unit>
      <trans-unit id="TestInitializeShouldBeValidTitle">
        <source>TestInitialize method should have valid layout</source>
        <target state="translated">O método de TestInitialize deve ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidDescription">
        <source>Test methods, methods marked with the '[TestMethod]' attribute, should respect the following layout to be considered valid by MSTest:
- it should be 'public' (or 'internal' if '[assembly: DiscoverInternals]' attribute is set)
- it should not be 'static'
- it should may be generic as long as type parameters can be inferred and argument types are compatible
- it should not be 'abstract'
- return type should be 'void', 'Task' or 'ValueTask'
- it should not be 'async void'
- it should not be a special method (finalizer, operator...).</source>
        <target state="translated">Os métodos de teste, métodos marcados com o atributo '[TestMethod]', devem respeitar o seguinte layout para que sejam considerados válidos pelo MSTest:
- deve ser "público" (ou "interno" se o atributo "[assembly: DiscoverInternals]" estiver definido)
- não pode ser ''estático''
- ele deve ser genérico, desde que os parâmetros de tipo possam ser inferidos e os tipos de argumentos sejam compatíveis
- não pode ser ''abstrato''
- o tipo de retorno deve ser 'nulo', 'Tarefa' ou 'ValueTask'
- não pode ser ''nulo assíncrono''
— não deve ser um método especial (finalizador, operador...).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldBeValidTitle">
        <source>Test methods should have valid layout</source>
        <target state="translated">Os métodos de teste devem ter um layout válido</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerDescription">
        <source>Test methods should not be ignored (marked with '[Ignore]').</source>
        <target state="translated">Os métodos de teste não devem ser ignorados (marcados com "[Ignorar]").</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerFormat">
        <source>Test method '{0}' should not be ignored</source>
        <target state="translated">O método de teste "{0}" não deve ser ignorado</target>
        <note />
      </trans-unit>
      <trans-unit id="TestMethodShouldNotBeIgnoredAnalyzerTitle">
        <source>Test method should not be ignored</source>
        <target state="translated">O método de teste não deve ser ignorado</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassDescription">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]', otherwise the test method will be silently ignored.</source>
        <target state="translated">O tipo que contém '[TestMethod]' deve ser marcado com '[TestClass]', caso contrário, o método de teste será ignorado sem aviso.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassMessageFormat">
        <source>Type '{0}' contains test methods and should be marked with '[TestClass]'</source>
        <target state="translated">O tipo '{0}' contém métodos de teste e deve ser marcado com '[TestClass]'</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeContainingTestMethodShouldBeATestClassTitle">
        <source>Type containing '[TestMethod]' should be marked with '[TestClass]'</source>
        <target state="translated">O tipo contendo '[TestMethod]' deve ser marcado com '[TestClass]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestFixtureMethodSuppressorJustification">
        <source>Asynchronous test fixture methods do not require the 'Async' suffix</source>
        <target state="translated">Os métodos de acessório de teste assíncronos não exigem o sufixo "Async"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAsyncSuffixTestMethodSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">Os métodos de teste assíncronos não exigem o sufixo 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnusedParameterSuppressorJustification">
        <source>TestContext parameter is required by MSTest for AssemblyInitialize and ClassInitialize methods</source>
        <target state="translated">O parâmetro TestContext é obrigatório para métodos AssemblyInitialize e ClassInitialize do MSTest</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerMessageFormat">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] só pode ser definido em métodos marcados com [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAttributeOnTestMethodAnalyzerTitle">
        <source>[{0}] can only be set on methods marked with [TestMethod]</source>
        <target state="translated">[{0}] só pode ser definido em métodos marcados com [TestMethod]</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassMessageFormat">
        <source>The attribute '{0}' which derives from 'ConditionBaseAttribute' should be used only on classes marked with `TestClassAttribute`</source>
        <target state="translated">O atributo '{0}' derivado de 'ConditionBaseAttribute' deve ser usado somente em classes marcadas com 'TestClassAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseConditionBaseWithTestClassTitle">
        <source>Use 'ConditionBaseAttribute' on test classes</source>
        <target state="translated">Usar 'ConditionBaseAttribute' em classes de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutDescription">
        <source>Using '[Timeout]' without explicitly setting 'CooperativeCancellation = true' is discouraged. In a future version, cooperative cancellation will become the default behavior. Set 'CooperativeCancellation = true' to opt into the recommended behavior and avoid breaking changes.</source>
        <target state="translated">Usar '\[Timeout]' sem definir explicitamente 'CooperativeCancellation = true' não é recomendado. Em uma versão futura, o cancelamento cooperativo se tornará o comportamento padrão. Defina 'CooperativeCancellation = true' para optar pelo comportamento recomendado e evitar quebras.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutMessageFormat">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]' to enable cooperative cancellation behavior</source>
        <target state="translated">Use 'CooperativeCancellation = true' com '\[Timeout]' para habilitar o comportamento de cancelamento cooperativo</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCooperativeCancellationForTimeoutTitle">
        <source>Use 'CooperativeCancellation = true' with '[Timeout]'</source>
        <target state="translated">Use 'CooperativeCancellation = true' com '\[Timeout]'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassMessageFormat">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' pode ser especificado apenas na classe de teste ou método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDeploymentItemWithTestMethodOrTestClassTitle">
        <source>'[DeploymentItem]' can be specified only on test class or test method</source>
        <target state="translated">'[DeploymentItem]' pode ser especificado apenas na classe de teste ou método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsMessageFormat">
        <source>Use 'Assert.ThrowsExactly' instead of 'Assert.ThrowsException'</source>
        <target state="translated">Usar 'Assert.ThrowsExactly' em vez de 'Assert.ThrowsException'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNewerAssertThrowsTitle">
        <source>Use newer methods to assert exceptions</source>
        <target state="translated">Usar métodos mais recentes para declarar exceções</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerDescription">
        <source>By default, MSTest runs tests within the same assembly sequentially, which can lead to severe performance limitations. It is recommended to enable assembly attribute '[Parallelize]' to run tests in parallel, or if the assembly is known to not be parallelizable, to use explicitly the assembly level attribute '[DoNotParallelize]'.</source>
        <target state="translated">Por padrão, o MSTest executa testes no mesmo assembly sequencialmente, o que pode levar a limitações graves de desempenho. É recomendável habilitar o atributo de assembly ''[Parallelize]'' para executar testes em paralelo ou se o assembly for conhecido por não ser paralelizável, para usar explicitamente o atributo de nível de assembly ''[DoNotParallelize]''.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerMessageFormat">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Habilitar ou desabilitar explicitamente a paralelização de testes</target>
        <note />
      </trans-unit>
      <trans-unit id="UseParallelizeAttributeAnalyzerTitle">
        <source>Explicitly enable or disable tests parallelization</source>
        <target state="translated">Habilitar ou desabilitar explicitamente a paralelização de testes</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsMessageFormat">
        <source>Use 'Assert.{0}' instead of 'Assert.{1}'</source>
        <target state="translated">Usar 'Assert.{0}' em vez de 'Assert.{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseProperAssertMethodsTitle">
        <source>Use proper 'Assert' methods</source>
        <target state="translated">Usar métodos 'Assert' adequados</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodMessageFormat">
        <source>An attribute that derives from 'RetryBaseAttribute' can be specified only on a test method</source>
        <target state="translated">Um atributo derivado de “RetryBaseAttribute” só pode ser especificado em um método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRetryWithTestMethodTitle">
        <source>Use retry attribute on test method</source>
        <target state="translated">Usar o atributo de repetição no método de teste</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageTitle">
        <source>TestContext property cannot be accessed in this context</source>
        <target state="translated">A propriedade TestContext não pode ser acessada neste contexto</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageMessageFormat">
        <source>TestContext property '{0}' cannot be accessed in '{1}' method</source>
        <target state="translated">A propriedade "{0}" de TestContext não pode ser acessada no método "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="TestContextPropertyUsageDescription">
        <source>Some TestContext properties are only available during test execution and cannot be accessed in assembly initialize, class initialize, class cleanup, or assembly cleanup methods.</source>
        <target state="translated">Algumas propriedades TestContext só estão disponíveis durante a execução do teste e não podem ser acessadas em métodos de inicialização de assembly, inicialização de classe, limpeza de classe ou limpeza de assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementDescription">
        <source>Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</source>
        <target state="new">Assert.Throws methods should contain only a single statement or expression. Multiple statements can be misleading - if the first statement throws, subsequent statements are never executed; if it doesn't throw, it should be moved outside the Assert.Throws.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementMessageFormat">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertThrowsShouldContainSingleStatementTitle">
        <source>Assert.Throws should contain only a single statement/expression</source>
        <target state="new">Assert.Throws should contain only a single statement/expression</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>