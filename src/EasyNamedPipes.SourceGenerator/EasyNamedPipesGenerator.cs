using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace EasyNamedPipes.SourceGenerator;

/// <summary>
/// Incremental source generator that generates serializers for types marked with the PipeSerializableMessage attribute.
/// </summary>
[Generator(LanguageNames.CSharp)]
internal sealed class EasyNamedPipesGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Represents metadata for a pipe-serializable message type.
    /// </summary>
    /// <param name="GroupName">The group name that categorizes related messages.</param>
    /// <param name="MessageId">The unique identifier for the message within its group.</param>
    /// <param name="MessageTypeName">The simple name of the message type.</param>
    /// <param name="MessageTypeFullyQualifiedName">The fully qualified name of the message type.</param>
    /// <param name="Properties">The collection of properties that will be serialized.</param>
    private sealed record PipeMessageInfo(
        string GroupName,
        int MessageId,
        string MessageTypeName,
        string MessageTypeFullyQualifiedName,
        // TODO: Use EquatableArray.
        ImmutableArray<PipePropertyInfo> Properties);

    /// <summary>
    /// Represents metadata for a property of a pipe-serializable message.
    /// </summary>
    /// <param name="PropertyName">The name of the property.</param>
    /// <param name="PropertyId">The unique identifier for the property within the message.</param>
    /// <param name="PropertyRequired">Indicates whether the property is required during deserialization.</param>
    /// <param name="PropertyType">The type name of the property.</param>
    /// <param name="IsArray">Indicates whether the property is an array type.</param>
    /// <param name="IsCustomPipeSerializable">Indicates whether the property type is a custom pipe-serializable message.</param>
    private sealed record PipePropertyInfo(
        string PropertyName,
        ushort PropertyId,
        bool PropertyRequired,
        string PropertyType,
        bool IsArray,
        bool IsCustomPipeSerializable);

    /// <summary>
    /// Initializes the incremental generator by registering output callbacks.
    /// </summary>
    /// <param name="context">The initialization context for the generator.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            EmitAttributes(context);
            EmitBaseTypes(context);
        });

        IncrementalValuesProvider<PipeMessageInfo?> pipeMessageInfos = context.SyntaxProvider.ForAttributeWithMetadataName(
            "EasyNamedPipes.PipeSerializableMessageAttribute",
            predicate: (_, _) => true,
            transform: Transform);

        context.RegisterSourceOutput(pipeMessageInfos, AddSerializerSource);
        context.RegisterSourceOutput(pipeMessageInfos.Collect(), AddGroupsSource);
    }

    /// <summary>
    /// Generates extension methods for registering all serializers in each message group.
    /// </summary>
    /// <param name="context">The source production context.</param>
    /// <param name="array">The collection of all pipe message metadata.</param>
    private static void AddGroupsSource(SourceProductionContext context, ImmutableArray<PipeMessageInfo?> array)
    {
        foreach (IGrouping<string?, PipeMessageInfo?>? group in array.GroupBy(m => m?.GroupName))
        {
            if (group.Key is not { } groupName)
            {
                continue;
            }

            var builder = new StringBuilder($$"""
                // <auto-generated />

                namespace EasyNamedPipes.GeneratedSerializers.{{groupName}};

                [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                internal static class {{groupName}}SerializersExtensions
                {
                    public static void Register{{groupName}}Serializers(this global::EasyNamedPipes.NamedPipeBase namedPipeBase)
                    {

                """);
            foreach (PipeMessageInfo? message in group)
            {
                string serializerFullyQualifiedName = $"global::EasyNamedPipes.GeneratedSerializers.{groupName}.{message!.MessageTypeName}Serializer";
                builder.AppendLine($"        namedPipeBase.RegisterSerializer({serializerFullyQualifiedName}.Instance, typeof({serializerFullyQualifiedName}));");
            }

            builder.AppendLine("""
                    }
                }
                """);

            context.AddSource($"EasyNamedPipes.GeneratedSerizlier.{groupName}.Group.g.cs", builder.ToString());
        }
    }

    /// <summary>
    /// Generates a serializer implementation for a specific message type.
    /// </summary>
    /// <param name="context">The source production context.</param>
    /// <param name="messageInfo">The metadata for the message type to generate a serializer for.</param>
    private static void AddSerializerSource(SourceProductionContext context, PipeMessageInfo? messageInfo)
    {
        if (messageInfo is null)
        {
            return;
        }

        // NOTE:
        // Analyzers needed:
        // 1. Ensure that message IDs are unique.
        // 2. Ensure that property IDs within the same message are unique.
        // 3. Ensure that property types are supported.
        //     Supported types are: primitives types, other pipe-serializable messages, one dimensional arrays of primitive types, and one dimensional arrays of pipe-serializable messages.
        // 4. Ensure the type has a valid constructor for generation.
        // 5. Ensure all properties have Id attribute.
        var builder = new StringBuilder();
        builder.AppendLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes.GeneratedSerializers.{{messageInfo.GroupName}};

            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class {{messageInfo.MessageTypeName}}Serializer : global::EasyNamedPipes.BaseSerializer, global::EasyNamedPipes.INamedPipeSerializer
            {
                public static global::EasyNamedPipes.GeneratedSerializers.{{messageInfo.GroupName}}.{{messageInfo.MessageTypeName}}Serializer Instance { get; } = new global::EasyNamedPipes.GeneratedSerializers.{{messageInfo.GroupName}}.{{messageInfo.MessageTypeName}}Serializer();

                public int Id => {{messageInfo.MessageId}};

                public object Deserialize(global::System.IO.Stream stream)
                {
                    ushort fieldCount = ReadUShort(stream);
            """);

        foreach (PipePropertyInfo property in messageInfo.Properties)
        {
            // Declare variables for each property.
            builder.AppendLine($$"""
                        {{property.PropertyType}}{{(property.IsArray ? "[]" : string.Empty)}}? {{property.PropertyName}} = null;
                """);
        }

        builder.AppendLine("""
                    for (int i = 0; i < fieldCount; i++)
                    {
                        ushort fieldId = ReadUShort(stream);
                        int fieldSize = ReadInt(stream);

                        switch (fieldId)
                        {
            """);

        foreach (PipePropertyInfo property in messageInfo.Properties)
        {
            string readCall = property.PropertyType switch
            {
                "string" => "ReadStringValue(stream, fieldSize)",
                "byte" => "ReadByte(stream)",
                "bool" => "ReadBool(stream)",
                "int" => "ReadInt(stream)",
                "long" => "ReadLong(stream)",
                _ => property.IsCustomPipeSerializable ? $"global::EasyNamedPipes.GeneratedSerializers.{messageInfo.GroupName}.{property.PropertyType}Serializer.Instance.Deserialize(stream)" : throw new NotSupportedException(),
            };

            if (property.IsArray)
            {
                builder.AppendLine($$"""
                                case {{property.PropertyId}}:
                                    int {{property.PropertyName}}Length = ReadInt(stream);
                                    {{property.PropertyName}} = new {{property.PropertyType}}[{{property.PropertyName}}Length];
                                    for (int j = 0; j < {{property.PropertyName}}Length; j++)
                                    {
                                        {{property.PropertyName}}[j] = {{readCall}};
                                    }

                                    break;
                """);
            }
            else
            {
                builder.AppendLine($$"""
                                case {{property.PropertyId}}:
                                    {{property.PropertyName}} = {{readCall}};
                                    break;
                """);
            }
        }

        builder.Append($$"""
                            default:
                                // If we don't recognize the field id, skip the payload corresponding to that field.
                                SetPosition(stream, stream.Position + fieldSize);
                                break;
                        }
                    }

                    return new global::{{messageInfo.MessageTypeFullyQualifiedName}}(
            """);

        for (int i = 0; i < messageInfo.Properties.Length; i++)
        {
            // This assumes the type is a record, where the constructor parameters match the property names.
            builder.Append($"{messageInfo.Properties[i].PropertyName}: {messageInfo.Properties[i].PropertyName}");
            if (i < messageInfo.Properties.Length - 1)
            {
                builder.Append(", ");
            }
        }

        builder.AppendLine("""
                    );
                        }

                    """);

        builder.AppendLine($$"""
                public void Serialize(object objectToSerialize, global::System.IO.Stream stream)
                {
                    global::System.Diagnostics.Debug.Assert(stream.CanSeek, "We expect a seekable stream.");

                    var message = (global::{{messageInfo.MessageTypeFullyQualifiedName}})objectToSerialize;

                    WriteUShort(stream, GetFieldCount(message));
            """);

        foreach (PipePropertyInfo property in messageInfo.Properties)
        {
            string writeCall = property.IsCustomPipeSerializable
                ? $"global::EasyNamedPipes.GeneratedSerializers.{messageInfo.GroupName}.{property.PropertyType}Serializer.Instance.Serialize(message.{property.PropertyName}, stream)"
                : $"WriteField(stream, {property.PropertyId}, message.{property.PropertyName});";

            if (property.IsArray)
            {
                builder.AppendLine($$"""
                            if (ShouldSerializeField(message.{{property.PropertyName}}))
                            {
                                WriteUShort(stream, {{property.PropertyId}});

                                // We will reserve an int (4 bytes)
                                // so that we fill the size later, once we write the payload
                                WriteInt(stream, 0);

                                long before = stream.Position;
                                WriteInt(stream, message.{{property.PropertyName}}.Length);
                                for (int k = 0; k < message.{{property.PropertyName}}.Length; k++)
                                {
                                     {{writeCall}}
                                }
                            }
                    """);
            }
            else
            {
                builder.AppendLine($"        {writeCall}");
            }
        }

        builder.AppendLine($$"""
                }

                private static ushort GetFieldCount(global::{{messageInfo.MessageTypeFullyQualifiedName}} message)
                {
                    ushort count = 0;
            """);

        foreach (PipePropertyInfo property in messageInfo.Properties)
        {
            if (property.IsArray)
            {
                builder.AppendLine($"       if (message.{property.PropertyName} is not null && message.{property.PropertyName}.Length != 0) count++;");
            }
            else
            {
                builder.AppendLine($"       if (message.{property.PropertyName} is not null) count++;");
            }
        }

        builder.AppendLine("""
                    return count;
                }
            }
            """);

        context.AddSource(
            $"EasyNamedPipes.{messageInfo.GroupName}.{messageInfo.MessageTypeName}Serializer.g.cs",
            SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Transforms syntax node attributes into pipe message metadata.
    /// </summary>
    /// <param name="context">The generator attribute syntax context.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The pipe message metadata, or null if the node cannot be transformed.</returns>
    private static PipeMessageInfo? Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.TargetSymbol is not INamedTypeSymbol { TypeKind: TypeKind.Class } attributedSymbol ||
            context.Attributes.Length != 1)
        {
            return null;
        }

        ImmutableArray<TypedConstant> attributeConstructorArguments = context.Attributes[0].ConstructorArguments;
        if (attributeConstructorArguments is not [{ Value: string messageGroupName }, { Value: int messageId }])
        {
            return null;
        }

        var propertyInfos = new List<PipePropertyInfo>();

        foreach (ISymbol member in attributedSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
            {
                continue;
            }

            ushort? propertyId = null;
            bool propertyRequired = false;

            foreach (AttributeData propertyAttribute in property.GetAttributes())
            {
                if (propertyAttribute.AttributeClass is not { } attributeClass ||
                    attributeClass.ContainingSymbol is not INamespaceSymbol { Name: "EasyNamedPipes", ContainingSymbol: INamespaceSymbol { IsGlobalNamespace: true } })
                {
                    continue;
                }

                if (attributeClass.Name == "PipePropertyIdAttribute")
                {
                    propertyId = propertyAttribute.ConstructorArguments[0].Value as ushort?;
                }
                else if (attributeClass.Name == "PipePropertyRequiredAttribute")
                {
                    propertyRequired = true;
                }
            }

            if (propertyId is null)
            {
                continue;
            }

            ITypeSymbol propertyType = property.Type;
            bool isArray = false;
            if (propertyType is IArrayTypeSymbol arrayType)
            {
                isArray = true;
                propertyType = arrayType.ElementType;
            }

            bool isPrimitiveSerializable = IsPrimitiveSerializable(propertyType);
            bool isCustomPipeSerializable = !isPrimitiveSerializable && IsCustomPipeSerializableType(propertyType);

            if (!isPrimitiveSerializable && !isCustomPipeSerializable)
            {
                return null;
            }

            // We only serialize/deserialize nullable types. Either it must be a reference type, or a nullable value type.
            // This is because the protocol we use has everything as "optional" by default.
            // Note that for arrays, propertyType is already the type of the individual elements.
            if (!propertyType.IsReferenceType && propertyType.OriginalDefinition.SpecialType != SpecialType.System_Nullable_T)
            {
                return null;
            }

            propertyInfos.Add(new PipePropertyInfo(
                property.Name,
                propertyId.Value,
                propertyRequired,
                propertyType.WithNullableAnnotation(NullableAnnotation.NotAnnotated).ToString(),
                isArray,
                isCustomPipeSerializable));
        }

        return new PipeMessageInfo(
            messageGroupName,
            messageId,
            attributedSymbol.Name,
            attributedSymbol.ToString(),
            propertyInfos.ToImmutableArray());
    }

    /// <summary>
    /// Determines whether a type is a primitive type that can be serialized.
    /// </summary>
    /// <param name="propertyType">The type to check.</param>
    /// <returns>True if the type is a primitive serializable type; otherwise, false.</returns>
    private static bool IsPrimitiveSerializable(ITypeSymbol propertyType)
        => propertyType.SpecialType is
            SpecialType.System_String or
            SpecialType.System_Byte or
            SpecialType.System_Boolean or
            SpecialType.System_Int32 or
            SpecialType.System_Int64;

    /// <summary>
    /// Determines whether a type is a custom pipe-serializable message type.
    /// </summary>
    /// <param name="typeSymbol">The type to check.</param>
    /// <returns>True if the type is marked with PipeSerializableMessageAttribute; otherwise, false.</returns>
    private static bool IsCustomPipeSerializableType(ITypeSymbol typeSymbol)
        => typeSymbol is INamedTypeSymbol namedTypeSymbol &&
            namedTypeSymbol.GetAttributes().Any(attr =>
                attr.AttributeClass is { Name: "PipeSerializableMessageAttribute" } &&
                attr.AttributeClass.ContainingSymbol is INamespaceSymbol { Name: "EasyNamedPipes", ContainingSymbol: INamespaceSymbol { IsGlobalNamespace: true } });

    private static void EmitAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        // Emit EmbeddedAttribute first
        context.AddSource("EmbeddedAttribute.g.cs", SourceText.From(
            """
            // <auto-generated/>
            namespace Microsoft.CodeAnalysis
            {
                internal sealed partial class EmbeddedAttribute : global::System.Attribute
                {
                }
            }
            """, Encoding.UTF8));

        context.AddSource("PipeSerializableMessageAttribute.g.cs", SourceText.From(
            """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Attribute to mark a class as a serializable message with pipe protocol.
            /// When applied to a class, the needed serializer will be generated for you at compile time.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class PipeSerializableMessageAttribute : global::System.Attribute
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="PipeSerializableMessageAttribute"/> class.
                /// </summary>
                /// <param name="messageGroupName">The group name of the message. This is used to group messages together.</param>
                /// <param name="messageId">The unique id of the message within the group.</param>
                public PipeSerializableMessageAttribute(string messageGroupName, int messageId)
                {
                    MessageGroupName = messageGroupName;
                    MessageId = messageId;
                }

                /// <summary>
                /// Gets the group name of the message.
                /// </summary>
                public string MessageGroupName { get; }

                /// <summary>
                /// Gets the unique id of the message within the group.
                /// </summary>
                public int MessageId { get; }
            }

            /// <summary>
            /// Attribute to mark a property of a serializable message as a required property.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class PipePropertyRequiredAttribute : global::System.Attribute
            {
            }

            /// <summary>
            /// Attribute to define the unique id of a property within a serializable message.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class PipePropertyIdAttribute : global::System.Attribute
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="PipePropertyIdAttribute"/> class.
                /// </summary>
                /// <param name="id">The unique id of the property within the message.</param>
                public PipePropertyIdAttribute(ushort id)
                {
                    Id = id;
                }

                /// <summary>
                /// Gets the unique id of the property within the message.
                /// </summary>
                public ushort Id { get; }
            }
            """, Encoding.UTF8));
    }

    private static void EmitBaseTypes(IncrementalGeneratorPostInitializationContext context)
    {
        // Emit INamedPipeSerializer
        context.AddSource("INamedPipeSerializer.g.cs", SourceText.From(
            """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Interface to be implemented by all message serializers.
            /// </summary>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal interface INamedPipeSerializer
            {
                /// <summary>
                /// The id of the serializer.
                /// </summary>
                int Id { get; }

                /// <summary>
                /// Serializes the given object to the given stream.
                /// </summary>
                /// <param name="objectToSerialize">The object to serialize.</param>
                /// <param name="stream">The stream to write the object to.</param>
                void Serialize(object objectToSerialize, global::System.IO.Stream stream);

                /// <summary>
                /// Deserializes an object from the given stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The deserialized object.</returns>
                object Deserialize(global::System.IO.Stream stream);
            }
            """, Encoding.UTF8));

        // Emit UnknownMessage
        context.AddSource("UnknownMessage.g.cs", SourceText.From(
            """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Represents an unknown message type that was encountered during deserialization.
            /// This is used when a message with an unregistered serializer ID is received.
            /// </summary>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class UnknownMessage
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="UnknownMessage"/> class.
                /// </summary>
                /// <param name="id">The identifier of the unknown message.</param>
                public UnknownMessage(int id)
                {
                    Id = id;
                }

                /// <summary>
                /// Gets the identifier of the unknown message.
                /// </summary>
                public int Id { get; }
            }
            """, Encoding.UTF8));

        // Emit UnknownMessageSerializer
        context.AddSource("UnknownMessageSerializer.g.cs", SourceText.From(
            """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Serializer for unknown message types. This is used when a message with an unregistered serializer ID is encountered.
            /// </summary>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal sealed class UnknownMessageSerializer : INamedPipeSerializer
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="UnknownMessageSerializer"/> class.
                /// </summary>
                /// <param name="id">The identifier of the unknown message type.</param>
                public UnknownMessageSerializer(int id)
                {
                    Id = id;
                }

                /// <inheritdoc/>
                public int Id { get; }

                /// <inheritdoc/>
                public object Deserialize(global::System.IO.Stream stream)
                    => new UnknownMessage(Id);

                /// <inheritdoc/>
                /// <exception cref="global::System.NotSupportedException">This method is not supported for unknown message types.</exception>
                public void Serialize(object objectToSerialize, global::System.IO.Stream stream)
                    => throw new global::System.NotSupportedException();
            }
            """, Encoding.UTF8));

        // Emit NamedPipeBase (continued in next part due to size)
        EmitNamedPipeBase(context);

        // Emit BaseSerializer
        EmitBaseSerializer(context);
    }

    private static void EmitNamedPipeBase(IncrementalGeneratorPostInitializationContext context)
        => context.AddSource("NamedPipeBase.g.cs", SourceText.From(
            """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Base class for named pipe communication, providing serializer registration and retrieval functionality.
            /// </summary>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal abstract class NamedPipeBase
            {
                private readonly global::System.Collections.Generic.Dictionary<global::System.Type, INamedPipeSerializer> _typeSerializer = new();
                private readonly global::System.Collections.Generic.Dictionary<int, INamedPipeSerializer> _idSerializer = new();

                /// <summary>
                /// Registers a serializer for a specific message type.
                /// </summary>
                /// <param name="namedPipeSerializer">The serializer to register.</param>
                /// <param name="type">The message type that this serializer handles.</param>
                public void RegisterSerializer(INamedPipeSerializer namedPipeSerializer, global::System.Type type)
                {
                    _typeSerializer.Add(type, namedPipeSerializer);
                    _idSerializer.Add(namedPipeSerializer.Id, namedPipeSerializer);
                }

                /// <summary>
                /// Gets a serializer by its identifier.
                /// </summary>
                /// <param name="id">The identifier of the serializer to retrieve.</param>
                /// <param name="skipUnknownMessages">If true, returns an UnknownMessageSerializer for unregistered IDs instead of throwing an exception.</param>
                /// <returns>The serializer associated with the specified identifier.</returns>
                /// <exception cref="global::System.ArgumentException">Thrown when no serializer is registered with the specified ID and skipUnknownMessages is false.</exception>
                protected INamedPipeSerializer GetSerializer(int id, bool skipUnknownMessages = false)
                    => _idSerializer.TryGetValue(id, out INamedPipeSerializer? serializer)
                        ? serializer
                        : skipUnknownMessages
                            ? new UnknownMessageSerializer(id)
                            : throw new global::System.ArgumentException($"No serializer registered with ID '{id}'");

                /// <summary>
                /// Gets a serializer for a specific message type.
                /// </summary>
                /// <param name="type">The message type to get the serializer for.</param>
                /// <returns>The serializer associated with the specified type.</returns>
                /// <exception cref="global::System.ArgumentException">Thrown when no serializer is registered for the specified type.</exception>
                protected INamedPipeSerializer GetSerializer(global::System.Type type)
                    => _typeSerializer.TryGetValue(type, out INamedPipeSerializer? serializer)
                        ? serializer
                        : throw new global::System.ArgumentException($"No serializer registered with type '{type}'");
            }
            """, Encoding.UTF8));

    private static void EmitBaseSerializer(IncrementalGeneratorPostInitializationContext context)
        // Due to the large size, I'll emit this in one go with the complete implementation
        => context.AddSource("BaseSerializer.g.cs", SourceText.From(GetBaseSerializerSource(), Encoding.UTF8));

    private static string GetBaseSerializerSource()
        => """
            // <auto-generated/>

            #nullable enable

            namespace EasyNamedPipes;

            /// <summary>
            /// Provides base serialization and deserialization functionality for named pipe communication.
            /// Contains helper methods for reading and writing various data types to and from streams.
            /// </summary>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            internal abstract class BaseSerializer
            {
            #if NETCOREAPP
                /// <summary>
                /// Reads a string from the stream. The string is prefixed with its length as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The string read from the stream.</returns>
                protected static string ReadString(global::System.IO.Stream stream)
                {
                    global::System.Span<byte> len = stackalloc byte[sizeof(int)];
                    stream.ReadExactly(len);
                    int stringLen = global::System.BitConverter.ToInt32(len);
                    byte[] bytes = global::System.Buffers.ArrayPool<byte>.Shared.Rent(stringLen);
                    try
                    {
                        stream.ReadExactly(bytes, 0, stringLen);
                        return global::System.Text.Encoding.UTF8.GetString(bytes, 0, stringLen);
                    }
                    finally
                    {
                        global::System.Buffers.ArrayPool<byte>.Shared.Return(bytes);
                    }
                }

                /// <summary>
                /// Reads a string value of a specified size from the stream without reading a length prefix.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <param name="size">The number of bytes to read for the string.</param>
                /// <returns>The string read from the stream.</returns>
                protected static string ReadStringValue(global::System.IO.Stream stream, int size)
                {
                    byte[] bytes = global::System.Buffers.ArrayPool<byte>.Shared.Rent(size);
                    try
                    {
                        stream.ReadExactly(bytes, 0, size);
                        return global::System.Text.Encoding.UTF8.GetString(bytes, 0, size);
                    }
                    finally
                    {
                        global::System.Buffers.ArrayPool<byte>.Shared.Return(bytes);
                    }
                }

                /// <summary>
                /// Writes a string to the stream, prefixing it with its UTF-8 byte length as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string to write.</param>
                protected static void WriteString(global::System.IO.Stream stream, string str)
                {
                    int stringutf8TotalBytes = global::System.Text.Encoding.UTF8.GetByteCount(str);
                    byte[] bytes = global::System.Buffers.ArrayPool<byte>.Shared.Rent(stringutf8TotalBytes);
                    try
                    {
                        global::System.Span<byte> len = stackalloc byte[sizeof(int)];
                        global::System.BitConverter.TryWriteBytes(len, stringutf8TotalBytes);
                        stream.Write(len);

                        global::System.Text.Encoding.UTF8.GetBytes(str, bytes);
                        stream.Write(bytes, 0, stringutf8TotalBytes);
                    }
                    finally
                    {
                        global::System.Buffers.ArrayPool<byte>.Shared.Return(bytes);
                    }
                }

                /// <summary>
                /// Writes a string value to the stream without writing a length prefix.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string to write.</param>
                protected static void WriteStringValue(global::System.IO.Stream stream, string str)
                {
                    int stringutf8TotalBytes = global::System.Text.Encoding.UTF8.GetByteCount(str);
                    byte[] bytes = global::System.Buffers.ArrayPool<byte>.Shared.Rent(stringutf8TotalBytes);
                    try
                    {
                        global::System.Text.Encoding.UTF8.GetBytes(str, bytes);
                        stream.Write(bytes, 0, stringutf8TotalBytes);
                    }
                    finally
                    {
                        global::System.Buffers.ArrayPool<byte>.Shared.Return(bytes);
                    }
                }

                /// <summary>
                /// Writes only the size (in bytes) of the UTF-8 encoded string to the stream as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string whose size will be written.</param>
                protected static void WriteStringSize(global::System.IO.Stream stream, string str)
                {
                    int stringutf8TotalBytes = global::System.Text.Encoding.UTF8.GetByteCount(str);
                    global::System.Span<byte> len = stackalloc byte[sizeof(int)];

                    global::System.BitConverter.TryWriteBytes(len, stringutf8TotalBytes);

                    stream.Write(len);
                }

                /// <summary>
                /// Writes the size of a struct type as a 4-byte integer to the stream.
                /// </summary>
                /// <typeparam name="T">The struct type whose size will be written.</typeparam>
                /// <param name="stream">The stream to write to.</param>
                protected static void WriteSize<T>(global::System.IO.Stream stream)
                    where T : struct
                {
                    int sizeInBytes = GetSize<T>();
                    global::System.Span<byte> len = stackalloc byte[sizeof(int)];

                    global::System.BitConverter.TryWriteBytes(len, sizeInBytes);

                    stream.Write(len);
                }

                /// <summary>
                /// Writes a 32-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The integer value to write.</param>
                protected static void WriteInt(global::System.IO.Stream stream, int value)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(int)];
                    global::System.BitConverter.TryWriteBytes(bytes, value);

                    stream.Write(bytes);
                }

                /// <summary>
                /// Writes a 64-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The long value to write.</param>
                protected static void WriteLong(global::System.IO.Stream stream, long value)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(long)];
                    global::System.BitConverter.TryWriteBytes(bytes, value);

                    stream.Write(bytes);
                }

                /// <summary>
                /// Writes an unsigned 16-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The unsigned short value to write.</param>
                protected static void WriteUShort(global::System.IO.Stream stream, ushort value)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(ushort)];
                    global::System.BitConverter.TryWriteBytes(bytes, value);

                    stream.Write(bytes);
                }

                /// <summary>
                /// Writes a boolean value to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The boolean value to write.</param>
                protected static void WriteBool(global::System.IO.Stream stream, bool value)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(bool)];
                    global::System.BitConverter.TryWriteBytes(bytes, value);

                    stream.Write(bytes);
                }

                /// <summary>
                /// Reads a 32-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The integer value read from the stream.</returns>
                protected static int ReadInt(global::System.IO.Stream stream)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(int)];
                    stream.ReadExactly(bytes);
                    return global::System.BitConverter.ToInt32(bytes);
                }

                /// <summary>
                /// Reads a 64-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The long value read from the stream.</returns>
                protected static long ReadLong(global::System.IO.Stream stream)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(long)];
                    stream.ReadExactly(bytes);
                    return global::System.BitConverter.ToInt64(bytes);
                }

                /// <summary>
                /// Reads an unsigned 16-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The unsigned short value read from the stream.</returns>
                protected static ushort ReadUShort(global::System.IO.Stream stream)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(ushort)];
                    stream.ReadExactly(bytes);
                    return global::System.BitConverter.ToUInt16(bytes);
                }

                /// <summary>
                /// Reads a boolean value from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The boolean value read from the stream.</returns>
                protected static bool ReadBool(global::System.IO.Stream stream)
                {
                    global::System.Span<byte> bytes = stackalloc byte[sizeof(bool)];
                    stream.ReadExactly(bytes);
                    return global::System.BitConverter.ToBoolean(bytes);
                }

            #else
                /// <summary>
                /// Reads a string from the stream. The string is prefixed with its length as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The string read from the stream.</returns>
                protected static string ReadString(global::System.IO.Stream stream)
                {
                    byte[] len = new byte[sizeof(int)];
                    _ = stream.Read(len, 0, len.Length);
                    int length = global::System.BitConverter.ToInt32(len, 0);
                    byte[] bytes = new byte[length];
                    _ = stream.Read(bytes, 0, bytes.Length);

                    return global::System.Text.Encoding.UTF8.GetString(bytes);
                }

                /// <summary>
                /// Reads a string value of a specified size from the stream without reading a length prefix.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <param name="size">The number of bytes to read for the string.</param>
                /// <returns>The string read from the stream.</returns>
                protected static string ReadStringValue(global::System.IO.Stream stream, int size)
                {
                    byte[] bytes = new byte[size];
                    _ = stream.Read(bytes, 0, bytes.Length);

                    return global::System.Text.Encoding.UTF8.GetString(bytes);
                }

                /// <summary>
                /// Writes a string to the stream, prefixing it with its UTF-8 byte length as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string to write.</param>
                protected static void WriteString(global::System.IO.Stream stream, string str)
                {
                    byte[] bytes = global::System.Text.Encoding.UTF8.GetBytes(str);
                    byte[] len = global::System.BitConverter.GetBytes(bytes.Length);
                    stream.Write(len, 0, len.Length);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Writes a string value to the stream without writing a length prefix.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string to write.</param>
                protected static void WriteStringValue(global::System.IO.Stream stream, string str)
                {
                    byte[] bytes = global::System.Text.Encoding.UTF8.GetBytes(str);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Writes only the size (in bytes) of the UTF-8 encoded string to the stream as a 4-byte integer.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="str">The string whose size will be written.</param>
                protected static void WriteStringSize(global::System.IO.Stream stream, string str)
                {
                    byte[] bytes = global::System.Text.Encoding.UTF8.GetBytes(str);
                    byte[] len = global::System.BitConverter.GetBytes(bytes.Length);
                    stream.Write(len, 0, len.Length);
                }

                /// <summary>
                /// Writes the size of a struct type as a 4-byte integer to the stream.
                /// </summary>
                /// <typeparam name="T">The struct type whose size will be written.</typeparam>
                /// <param name="stream">The stream to write to.</param>
                protected static void WriteSize<T>(global::System.IO.Stream stream)
                    where T : struct
                {
                    int sizeInBytes = GetSize<T>();
                    byte[] len = global::System.BitConverter.GetBytes(sizeInBytes);
                    stream.Write(len, 0, len.Length);
                }

                /// <summary>
                /// Writes a 32-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The integer value to write.</param>
                protected static void WriteInt(global::System.IO.Stream stream, int value)
                {
                    byte[] bytes = global::System.BitConverter.GetBytes(value);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Reads a 32-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The integer value read from the stream.</returns>
                protected static int ReadInt(global::System.IO.Stream stream)
                {
                    byte[] bytes = new byte[sizeof(int)];
                    _ = stream.Read(bytes, 0, bytes.Length);
                    return global::System.BitConverter.ToInt32(bytes, 0);
                }

                /// <summary>
                /// Writes a 64-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The long value to write.</param>
                protected static void WriteLong(global::System.IO.Stream stream, long value)
                {
                    byte[] bytes = global::System.BitConverter.GetBytes(value);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Writes an unsigned 16-bit integer to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The unsigned short value to write.</param>
                protected static void WriteUShort(global::System.IO.Stream stream, ushort value)
                {
                    byte[] bytes = global::System.BitConverter.GetBytes(value);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Reads a 64-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The long value read from the stream.</returns>
                protected static long ReadLong(global::System.IO.Stream stream)
                {
                    byte[] bytes = new byte[sizeof(long)];
                    _ = stream.Read(bytes, 0, bytes.Length);
                    return global::System.BitConverter.ToInt64(bytes, 0);
                }

                /// <summary>
                /// Reads an unsigned 16-bit integer from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The unsigned short value read from the stream.</returns>
                protected static ushort ReadUShort(global::System.IO.Stream stream)
                {
                    byte[] bytes = new byte[sizeof(ushort)];
                    _ = stream.Read(bytes, 0, bytes.Length);
                    return global::System.BitConverter.ToUInt16(bytes, 0);
                }

                /// <summary>
                /// Writes a boolean value to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The boolean value to write.</param>
                protected static void WriteBool(global::System.IO.Stream stream, bool value)
                {
                    byte[] bytes = global::System.BitConverter.GetBytes(value);
                    stream.Write(bytes, 0, bytes.Length);
                }

                /// <summary>
                /// Reads a boolean value from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The boolean value read from the stream.</returns>
                protected static bool ReadBool(global::System.IO.Stream stream)
                {
                    byte[] bytes = new byte[sizeof(bool)];
                    _ = stream.Read(bytes, 0, bytes.Length);
                    return global::System.BitConverter.ToBoolean(bytes, 0);
                }
            #endif

                /// <summary>
                /// Reads a single byte from the stream.
                /// </summary>
                /// <param name="stream">The stream to read from.</param>
                /// <returns>The byte value read from the stream.</returns>
                protected static byte ReadByte(global::System.IO.Stream stream) => (byte)stream.ReadByte();

                /// <summary>
                /// Writes a single byte to the stream.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The byte value to write.</param>
                protected static void WriteByte(global::System.IO.Stream stream, byte value) => stream.WriteByte(value);

                /// <summary>
                /// Writes a field with an identifier and a nullable string value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="id">The field identifier.</param>
                /// <param name="value">The nullable string value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, ushort id, string? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteUShort(stream, id);
                    WriteStringSize(stream, value);
                    WriteStringValue(stream, value);
                }

                /// <summary>
                /// Writes a field with an identifier and a nullable long value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="id">The field identifier.</param>
                /// <param name="value">The nullable long value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, ushort id, long? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteUShort(stream, id);
                    WriteSize<long>(stream);
                    WriteLong(stream, value.Value);
                }

                /// <summary>
                /// Writes a field with an identifier and a nullable int value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="id">The field identifier.</param>
                /// <param name="value">The nullable int value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, ushort id, int? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteUShort(stream, id);
                    WriteSize<int>(stream);
                    WriteInt(stream, value.Value);
                }

                /// <summary>
                /// Writes a nullable string value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The nullable string value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, string? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteString(stream, value);
                }

                /// <summary>
                /// Writes a nullable byte value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The nullable byte value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, byte? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteByte(stream, value.Value);
                }

                /// <summary>
                /// Writes a field with an identifier and a nullable bool value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="id">The field identifier.</param>
                /// <param name="value">The nullable bool value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, ushort id, bool? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteUShort(stream, id);
                    WriteSize<bool>(stream);
                    WriteBool(stream, value.Value);
                }

                /// <summary>
                /// Writes a field with an identifier and a nullable byte value to the stream.
                /// If the value is null, nothing is written.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="id">The field identifier.</param>
                /// <param name="value">The nullable byte value to write.</param>
                protected static void WriteField(global::System.IO.Stream stream, ushort id, byte? value)
                {
                    if (value is null)
                    {
                        return;
                    }

                    WriteUShort(stream, id);
                    WriteSize<byte>(stream);
                    WriteByte(stream, value.Value);
                }

                /// <summary>
                /// Sets the position within the stream.
                /// </summary>
                /// <param name="stream">The stream to set the position for.</param>
                /// <param name="position">The new position within the stream.</param>
                protected static void SetPosition(global::System.IO.Stream stream, long position) => stream.Position = position;

                /// <summary>
                /// Writes an integer value at a specific position in the stream, then restores the original position.
                /// </summary>
                /// <param name="stream">The stream to write to.</param>
                /// <param name="value">The integer value to write.</param>
                /// <param name="position">The position in the stream where the value should be written.</param>
                protected static void WriteAtPosition(global::System.IO.Stream stream, int value, long position)
                {
                    long currentPosition = stream.Position;
                    SetPosition(stream, position);
                    WriteInt(stream, value);
                    SetPosition(stream, currentPosition);
                }

                /// <summary>
                /// Gets the size in bytes of a specified struct type.
                /// </summary>
                /// <typeparam name="T">The struct type to get the size of.</typeparam>
                /// <returns>The size in bytes of the specified type, or 0 if the type is not supported.</returns>
                private static int GetSize<T>() => typeof(T) switch
                {
                    global::System.Type type when type == typeof(int) => sizeof(int),
                    global::System.Type type when type == typeof(long) => sizeof(long),
                    global::System.Type type when type == typeof(short) => sizeof(short),
                    global::System.Type type when type == typeof(bool) => sizeof(bool),
                    global::System.Type type when type == typeof(byte) => sizeof(byte),
                    _ => 0,
                };
            }
            """;
}
