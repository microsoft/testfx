<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" original="../FrameworkMessages.resx" target-language="zh-Hans">
    <body>
      <trans-unit id="AccessStringInvalidSyntax">
        <source>Access string has invalid syntax.</source>
        <target state="translated">访问字符串的语法无效。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ActualHasMismatchedElements">
        <source>The expected collection contains {1} occurrence(s) of &lt;{2}&gt;. The actual collection contains {3} occurrence(s). {0}</source>
        <target state="translated">所需集合包含 &lt;{2}&gt; 的 {1} 个匹配项。实际集合包含 {3} 个匹配项。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AllItemsAreUniqueFailMsg">
        <source>Duplicate item found:&lt;{1}&gt;. {0}</source>
        <target state="translated">找到了重复项: &lt;{1}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualFailMsg">
        <source>Expected:&lt;{1}&gt;. Actual:&lt;{2}&gt;. {0}</source>
        <target state="translated">应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualDeltaFailMsg">
        <source>Expected a difference no greater than &lt;{3}&gt; between expected value &lt;{1}&gt; and actual value &lt;{2}&gt;. {0}</source>
        <target state="translated">预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差不应大于 &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualCaseFailMsg">
        <source>Expected:&lt;{1}&gt;. Case is different for actual value:&lt;{2}&gt;. {0}</source>
        <target state="translated">应为: &lt;{1}&gt;。实际值的大小写有所不同: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualDifferentTypesFailMsg">
        <source>Expected:&lt;{1} ({2})&gt;. Actual:&lt;{3} ({4})&gt;. {0}</source>
        <target state="translated">应为: &lt;{1} ({2})&gt;，实际为: &lt;{3} ({4})&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreNotEqualFailMsg">
        <source>Expected any value except:&lt;{1}&gt;. Actual:&lt;{2}&gt;. {0}</source>
        <target state="translated">应为: &lt;{1}&gt; 以外的任意值，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreNotEqualDeltaFailMsg">
        <source>Expected a difference greater than &lt;{3}&gt; between expected value &lt;{1}&gt; and actual value &lt;{2}&gt;. {0}</source>
        <target state="translated">预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差应大于 &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreSameGivenValues">
        <source>Do not pass value types to AreSame(). Values converted to Object will never be the same. Consider using AreEqual(). {0}</source>
        <target state="translated">不要向 AreSame() 传递值类型。转换为 Object 的值将永远不会相等。请考虑使用 AreEqual()。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsEmpty">
        <source>Both collections are empty. {0}</source>
        <target state="translated">这两个集合都为空。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsSameElements">
        <source>Both collection contain same elements.</source>
        <target state="translated">这两个集合包含相同的元素。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsSameReference">
        <source>Both collection references point to the same collection object. {0}</source>
        <target state="translated">这两个集合引用指向同一个集合对象。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothSameElements">
        <source>Both collections contain the same elements. {0}</source>
        <target state="translated">这两个集合包含相同的元素。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="CollectionEqualReason">
        <source>{0}({1})</source>
        <target state="translated">{0}({1})</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ContainsFail">
        <source>String '{0}' does not contain string '{1}'. {2}.</source>
        <target state="translated">字符串“{0}”不包含字符串“{1}”。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DynamicDataInvalidMethodLayout">
        <source>Dynamic data method '{0}' should be static, parameterless and non-generic.</source>
        <target state="translated">动态数据方法“{0}”应为静态、无参数和非泛型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataInvalidPropertyLayout">
        <source>Dynamic data property '{0}' should be static and have a getter.</source>
        <target state="translated">动态数据属性“{0}”应为静态且具有 getter。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementNumbersDontMatch">
        <source>The number of elements in the collections do not match. Expected:&lt;{1}&gt;. Actual:&lt;{2}&gt;.{0}</source>
        <target state="translated">集合中元素的数量不匹配。应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ElementsAtIndexDontMatch">
        <source>Element at index {0} do not match.</source>
        <target state="translated">索引 {0} 处的元素不匹配。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ElementTypesAtIndexDontMatch">
        <source>Element at index {1} is not of expected type. Expected type:&lt;{2}&gt;. Actual type:&lt;{3}&gt;.{0}</source>
        <target state="translated">索引 {1} 处的元素不是所需类型。所需类型为: &lt;{2}&gt;，实际类型为: &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="EndsWithFail">
        <source>String '{0}' does not end with string '{1}'. {2}.</source>
        <target state="translated">字符串“{0}”不以字符串“{1}”结尾。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AssertionFailed">
        <source>{0} failed. {1}</source>
        <target state="translated">{0} 失败。{1}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsInstanceOfFailMsg">
        <source>{0} Expected type:&lt;{1}&gt;. Actual type:&lt;{2}&gt;.</source>
        <target state="translated">{0} 类型应为: &lt;{1}&gt;。类型实为: &lt;{2}&gt;。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsMatchFail">
        <source>String '{0}' does not match pattern '{1}'. {2}.</source>
        <target state="translated">字符串“{0}”与模式“{1}”不匹配。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsNotInstanceOfFailMsg">
        <source>Wrong Type:&lt;{1}&gt;. Actual type:&lt;{2}&gt;. {0}</source>
        <target state="translated">错误类型为: &lt;{1}&gt;，实际类型为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsNotMatchFail">
        <source>String '{0}' matches pattern '{1}'. {2}.</source>
        <target state="translated">字符串“{0}”与模式“{1}”匹配。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DoNotUseAssertEquals">
        <source>Assert.Equals should not be used for Assertions. Please use Assert.AreEqual &amp; overloads instead.</source>
        <target state="translated">Assert.Equals 不应用于断言。请改用 Assert.AreEqual 和重载。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="PrivateAccessorMemberNotFound">
        <source>
      The member specified ({0}) could not be found. You might need to regenerate your private accessor,
      or the member may be private and defined on a base class. If the latter is true, you need to pass the type
      that defines the member into PrivateObject's constructor.
    </source>
        <target state="translated">
      未能找到指定的成员({0})。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数中。
    </target>
        <note></note>
      </trans-unit>
      <trans-unit id="PrivateAccessorConstructorNotFound">
        <source>
      The constructor with the specified signature could not be found. You might need to regenerate your private accessor,
      or the member may be private and defined on a base class. If the latter is true, you need to pass the type
      that defines the member into PrivateObject's constructor.
    </source>
        <target state="translated">
      未能找到具有指定签名的构造函数。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数。
    </target>
        <note></note>
      </trans-unit>
      <trans-unit id="NullParameterToAssert">
        <source>The parameter '{0}' is invalid. The value cannot be null. {1}.</source>
        <target state="translated">参数“{0}”无效。值不能为 NULL。{1}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NumberOfElementsDiff">
        <source>Different number of elements.</source>
        <target state="translated">不同数量的元素。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="StartsWithFail">
        <source>String '{0}' does not start with string '{1}'. {2}.</source>
        <target state="translated">字符串“{0}”没有以字符串“{1}”开头。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="InvalidPropertyType">
        <source>The property {0} has type {1}; expected type {2}.</source>
        <target state="translated">属性 {0} 的类型为 {1}；类型应为 {2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="Common_NullInMessages">
        <source>(null)</source>
        <target state="translated">(NULL)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="Common_ObjectString">
        <source>(object)</source>
        <target state="translated">(对象)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_ExpectedExceptionTypeMustDeriveFromException">
        <source>The expected exception type must be System.Exception or a type derived from System.Exception.</source>
        <target state="translated">预期的异常类型必须为 System.Exception 或从 System.Exception 派生的类型。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodNoExceptionDefault">
        <source>Test method did not throw an exception. An exception was expected by attribute {0} defined on the test method.</source>
        <target state="translated">测试方法未引发异常。预期会因测试方法上定义的属性 {0} 引发一个异常。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodNoException">
        <source>Test method did not throw expected exception {0}. {1}</source>
        <target state="translated">测试方法未引发预期异常 {0}. {1}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodWrongException">
        <source>Test method threw exception {0}, but exception {1} was expected. Exception message: {2}</source>
        <target state="translated">测试方法引发异常 {0}，但预期异常是 {1}。异常消息: {2}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodWrongExceptionDerivedAllowed">
        <source>Test method threw exception {0}, but exception {1} or a type derived from it was expected. Exception message: {2}</source>
        <target state="translated">测试方法引发异常 {0}，但预期异常是 {1} 或其派生类型。异常消息: {2}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_FailedToGetExceptionMessage">
        <source>(Failed to get the message for an exception of type {0} due to an exception.)</source>
        <target state="translated">(因异常而未能获取类型为 {0} 的异常的消息。)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NoExceptionThrown">
        <source>Expected exception type:&lt;{1}&gt; but no exception was thrown. {0}</source>
        <target state="translated">预期异常类型:&lt;{1}&gt;，但未引发异常。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongExceptionThrown">
        <source>Expected exception type:&lt;{1}&gt;. Actual exception type:&lt;{2}&gt;. {0}</source>
        <target state="translated">预期异常类型:&lt;{1}&gt;。实际异常类型:&lt;{2}&gt;。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DataDrivenResultDisplayName">
        <source>{0} ({1})</source>
        <target state="translated">{0} ({1})</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AsyncUITestMethodNotSupported">
        <source>async TestMethod with UITestMethodAttribute are not supported. Either remove async or use TestMethodAttribute.</source>
        <target state="translated">不支持具有 UITestMethodAttribute 的异步 TestMethod。请删除异步或使用 TestMethodAttribute。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DynamicDataIEnumerableNull">
        <source>Property or method {0} on {1} return type is not assignable to 'IEnumerable&lt;object[]&gt;' (nor 'IEnumerable&lt;ITuple&gt;' for .NET Core).</source>
        <target state="translated">{1} 返回类型上的属性或方法 {0} 不能分配给 "IEnumerable&lt;object[]&gt;" (对于 .NET Core，也不能分配给 "IEnumerable&lt;ITuple&gt;")。</target>
        <note />
      </trans-unit>
      <trans-unit id="DynamicDataValueNull">
        <source>Value returned by property or method {0} shouldn't be null.</source>
        <target state="translated">属性或方法 {0} 返回的值不能为 null。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DynamicDataDisplayName">
        <source>Method {0} must match the expected signature: public static {1} {0}({2}).</source>
        <target state="translated">方法 {0} 必须匹配预期签名: public static {1} {0}({2})。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DynamicDataIEnumerableEmpty">
        <source>Property or method {0} on {1} returns empty IEnumerable&lt;object[]&gt;.</source>
        <target state="translated">{1} 上的属性或方法 {0} 返回空 IEnumerable&lt;object[]&gt;。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AsyncUITestMethodWithNoDispatcherQueue">
        <source>UITestMethodAttribute.DispatcherQueue should not be null. To use UITestMethodAttribute within a WinUI Desktop App, remember to set the static UITestMethodAttribute.DispatcherQueue during the test initialization.</source>
        <target state="translated">UITestMethodAttribute.DispatcherQueue 不应为 null。若要在 WinUI 桌面应用中使用 UITestMethodAttribute，请在测试初始化期间设置静态 UITestMethodAttribute.DispatcherQueue。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ArgumentXMustDeriveFromClassY">
        <source>Type '{0}' is not assignable to '{1}'.</source>
        <target state="translated">类型“{0}”不能分配给“{1}”。</target>
        <note>
      - {0} argument name like "applicationType"
      - {1} fully qualified class name like "Microsoft.UI.Xaml.Application"
    </note>
      </trans-unit>
    </body>
  </file>
</xliff>