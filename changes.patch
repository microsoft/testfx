From 710b16f91c0a8fae8aecd58b72b207da434e2f92 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Fri, 28 Feb 2025 16:04:38 +0100
Subject: [PATCH 01/23] Improve ExecutionContext propagation

---
 .../Execution/TestAssemblyInfo.cs             |  17 +-
 .../Execution/TestClassInfo.cs                |  31 ++-
 .../Execution/TestMethodInfo.cs               |  90 ++++++---
 .../Execution/UnitTestRunner.cs               |   2 +
 .../Helpers/FixtureMethodRunner.cs            |  39 ++--
 .../Services/AssemblyExecutionContextScope.cs |  11 -
 .../Services/ClassExecutionContextScope.cs    |  31 ---
 .../Services/ExecutionContextService.cs       | 189 ------------------
 .../Services/IExecutionContextScope.cs        |   9 -
 .../Services/InstanceExecutionContextScope.cs |  35 ----
 10 files changed, 122 insertions(+), 332 deletions(-)
 delete mode 100644 src/Adapter/MSTestAdapter.PlatformServices/Services/AssemblyExecutionContextScope.cs
 delete mode 100644 src/Adapter/MSTestAdapter.PlatformServices/Services/ClassExecutionContextScope.cs
 delete mode 100644 src/Adapter/MSTestAdapter.PlatformServices/Services/ExecutionContextService.cs
 delete mode 100644 src/Adapter/MSTestAdapter.PlatformServices/Services/IExecutionContextScope.cs
 delete mode 100644 src/Adapter/MSTestAdapter.PlatformServices/Services/InstanceExecutionContextScope.cs

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
index 17eeb16e25..4c9028b8ec 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
@@ -4,7 +4,6 @@
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.ObjectModel;
-using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
 
 using UnitTestOutcome = Microsoft.VisualStudio.TestTools.UnitTesting.UnitTestOutcome;
@@ -107,6 +106,8 @@ internal set
     /// </summary>
     internal Assembly Assembly { get; }
 
+    internal ExecutionContext? ExecutionContext { get; set; }
+
     /// <summary>
     /// Runs assembly initialize method.
     /// </summary>
@@ -143,11 +144,17 @@ public void RunAssemblyInitialize(TestContext testContext)
                     try
                     {
                         AssemblyInitializationException = FixtureMethodRunner.RunWithTimeoutAndCancellation(
-                            () => AssemblyInitializeMethod.InvokeAsSynchronousTask(null, testContext),
+                            () =>
+                            {
+                                AssemblyInitializeMethod.InvokeAsSynchronousTask(null, testContext);
+                                // **After** we have executed the assembly initialize, we save the current context.
+                                // This context will contain async locals set by the assembly initialize method.
+                                ExecutionContext = ExecutionContext.Capture();
+                            },
                             testContext.CancellationTokenSource,
                             AssemblyInitializeMethodTimeoutMilliseconds,
                             AssemblyInitializeMethod,
-                            new AssemblyExecutionContextScope(isCleanup: false),
+                            executionContext: null, // Assembly initialize is the first thing that we run. So just execute on the current execution context.
                             Resource.AssemblyInitializeWasCancelled,
                             Resource.AssemblyInitializeTimedOut);
                     }
@@ -220,7 +227,7 @@ public void RunAssemblyInitialize(TestContext testContext)
                      new CancellationTokenSource(),
                      AssemblyCleanupMethodTimeoutMilliseconds,
                      AssemblyCleanupMethod,
-                     new AssemblyExecutionContextScope(isCleanup: true),
+                     ExecutionContext,
                      Resource.AssemblyCleanupWasCancelled,
                      Resource.AssemblyCleanupTimedOut);
             }
@@ -286,7 +293,7 @@ public void RunAssemblyInitialize(TestContext testContext)
                      testContext.CancellationTokenSource,
                      AssemblyCleanupMethodTimeoutMilliseconds,
                      AssemblyCleanupMethod,
-                     new AssemblyExecutionContextScope(isCleanup: true),
+                     ExecutionContext,
                      Resource.AssemblyCleanupWasCancelled,
                      Resource.AssemblyCleanupTimedOut);
             }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index be18e8d5c8..65d6e7017f 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -4,7 +4,6 @@
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.ObjectModel;
-using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
 
@@ -233,6 +232,8 @@ internal set
         }
     }
 
+    internal ExecutionContext? ExecutionContext { get; set; }
+
     /// <summary>
     /// Gets a queue of test initialize methods to call for this type.
     /// </summary>
@@ -501,11 +502,20 @@ TestResult DoRun()
         }
 
         return FixtureMethodRunner.RunWithTimeoutAndCancellation(
-            () => methodInfo.InvokeAsSynchronousTask(null, testContext),
+            () =>
+            {
+                methodInfo.InvokeAsSynchronousTask(null, testContext);
+                // **After** we have executed the class initialize, we save the current context.
+                // This context will contain async locals set by the class initialize method.
+                ExecutionContext = ExecutionContext.Capture();
+            },
             testContext.CancellationTokenSource,
             timeout,
             methodInfo,
-            new ClassExecutionContextScope(ClassType),
+            // We run the class initialize on a copy of the execution context of the assembly.
+            // That way, async locals set by assembly initialize are visible to class initialize.
+            // But we copy so that async locals set by class initialize are not visible to assembly cleanup.
+            Parent?.ExecutionContext?.CreateCopy(),
             Resource.ClassInitializeWasCancelled,
             Resource.ClassInitializeTimedOut);
     }
@@ -543,12 +553,12 @@ TestResult DoRun()
                 try
                 {
                     classCleanupMethod = ClassCleanupMethod;
-                    ClassCleanupException = classCleanupMethod is not null ? InvokeCleanupMethod(classCleanupMethod, BaseClassCleanupMethods.Count, null!) : null;
+                    ClassCleanupException = classCleanupMethod is not null ? InvokeCleanupMethod(classCleanupMethod, null!) : null;
                     var baseClassCleanupQueue = new Queue<MethodInfo>(BaseClassCleanupMethods);
                     while (baseClassCleanupQueue.Count > 0 && ClassCleanupException is null)
                     {
                         classCleanupMethod = baseClassCleanupQueue.Dequeue();
-                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, baseClassCleanupQueue.Count, null!);
+                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, null!);
                     }
 
                     IsClassCleanupExecuted = ClassCleanupException is null;
@@ -628,7 +638,7 @@ TestResult DoRun()
                 {
                     if (!classCleanupMethod.DeclaringType!.IsIgnored(out _))
                     {
-                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, remainingCleanupCount: BaseClassCleanupMethods.Count, testContext);
+                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext);
                     }
                 }
 
@@ -639,7 +649,7 @@ TestResult DoRun()
                         classCleanupMethod = BaseClassCleanupMethods[i];
                         if (!classCleanupMethod.DeclaringType!.IsIgnored(out _))
                         {
-                            ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, remainingCleanupCount: BaseClassCleanupMethods.Count - 1 - i, testContext);
+                            ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext);
                             if (ClassCleanupException is not null)
                             {
                                 break;
@@ -792,7 +802,7 @@ void DoRun()
         }
     }
 
-    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, int remainingCleanupCount, TestContext testContext)
+    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, TestContext testContext)
     {
         TimeoutInfo? timeout = null;
         if (ClassCleanupMethodTimeoutMilliseconds.TryGetValue(methodInfo, out TimeoutInfo localTimeout))
@@ -815,7 +825,10 @@ void DoRun()
             testContext.CancellationTokenSource,
             timeout,
             methodInfo,
-            new ClassExecutionContextScope(ClassType, remainingCleanupCount),
+            // If we had a class initialize that have set the execution context, we use that.
+            // Otherwise, we still want to use the execution context of the assembly.
+            // Note that if we have a class initialize, its execution context was already a copy of the assembly's context.
+            ExecutionContext ?? Parent.ExecutionContext?.CreateCopy(),
             Resource.ClassCleanupWasCancelled,
             Resource.ClassCleanupTimedOut);
     }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 9ea784dbc4..12beb0821d 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -4,7 +4,6 @@
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.ObjectModel;
-using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
@@ -154,7 +153,8 @@ public virtual TestResult Invoke(object?[]? arguments)
         watch.Start();
         try
         {
-            result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments) : ExecuteInternal(arguments, null);
+            ExecutionContext? executionContext = (Parent.ExecutionContext ?? Parent.Parent.ExecutionContext)?.CreateCopy();
+            result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments, executionContext) : ExecuteInternal(arguments, executionContext, null);
         }
         finally
         {
@@ -373,10 +373,11 @@ private void ThrowMultipleAttributesException(string attributeName)
     /// Execute test without timeout.
     /// </summary>
     /// <param name="arguments">Arguments to be passed to the method.</param>
+    /// <param name="executionContext">The execution context to execute the test method on.</param>
     /// <param name="timeoutTokenSource">The timeout token source.</param>
     /// <returns>The result of the execution.</returns>
     [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
-    private TestResult ExecuteInternal(object?[]? arguments, CancellationTokenSource? timeoutTokenSource)
+    private TestResult ExecuteInternal(object?[]? arguments, ExecutionContext? executionContext, CancellationTokenSource? timeoutTokenSource)
     {
         DebugEx.Assert(TestMethod != null, "UnitTestExecuter.DefaultTestMethodInvoke: testMethod = null.");
 
@@ -398,18 +399,20 @@ private TestResult ExecuteInternal(object?[]? arguments, CancellationTokenSource
                     // For any failure after this point, we must run TestCleanup
                     _isTestContextSet = true;
 
-                    if (RunTestInitializeMethod(_classInstance, result, timeoutTokenSource))
+                    if (RunTestInitializeMethod(_classInstance, result, ref executionContext, timeoutTokenSource))
                     {
                         hasTestInitializePassed = true;
-                        if (IsTimeoutSet)
+                        if (executionContext is null)
                         {
-                            ExecutionContextService.RunActionOnContext(
-                                () => TestMethod.InvokeAsSynchronousTask(_classInstance, arguments),
-                                new InstanceExecutionContextScope(_classInstance, Parent.ClassType));
+                            TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
                         }
                         else
                         {
-                            TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                            ExecutionContext.Run(executionContext, _ =>
+                            {
+                                TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                                executionContext = ExecutionContext.Capture();
+                            }, null);
                         }
 
                         result.Outcome = UTF.UnitTestOutcome.Passed;
@@ -489,7 +492,7 @@ private TestResult ExecuteInternal(object?[]? arguments, CancellationTokenSource
         // Pulling it out so extension writers can abort custom cleanups if need be. Having this in a finally block
         // does not allow a thread abort exception to be raised within the block but throws one after finally is executed
         // crashing the process. This was blocking writing an extension for Dynamic Timeout in VSO.
-        RunTestCleanupMethod(result, timeoutTokenSource);
+        RunTestCleanupMethod(result, executionContext, timeoutTokenSource);
 
         return testRunnerException != null ? throw testRunnerException : result;
     }
@@ -634,9 +637,10 @@ private static TestFailedException HandleMethodException(Exception ex, Exception
     /// Runs TestCleanup methods of parent TestClass and base classes.
     /// </summary>
     /// <param name="result">Instance of TestResult.</param>
+    /// <param name="executionContext">The execution context to execute the test cleanup on.</param>
     /// <param name="timeoutTokenSource">The timeout token source.</param>
     [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
-    private void RunTestCleanupMethod(TestResult result, CancellationTokenSource? timeoutTokenSource)
+    private void RunTestCleanupMethod(TestResult result, ExecutionContext? executionContext, CancellationTokenSource? timeoutTokenSource)
     {
         DebugEx.Assert(result != null, "result != null");
 
@@ -664,17 +668,18 @@ private void RunTestCleanupMethod(TestResult result, CancellationTokenSource? ti
                 // Test cleanups are called in the order of discovery
                 // Current TestClass -> Parent -> Grandparent
                 testCleanupException = testCleanupMethod is not null
-                    ? InvokeCleanupMethod(testCleanupMethod, _classInstance, Parent.BaseTestCleanupMethodsQueue.Count, timeoutTokenSource)
+                    ? InvokeCleanupMethod(testCleanupMethod, _classInstance, ref executionContext, timeoutTokenSource)
                     : null;
                 var baseTestCleanupQueue = new Queue<MethodInfo>(Parent.BaseTestCleanupMethodsQueue);
                 while (baseTestCleanupQueue.Count > 0 && testCleanupException is null)
                 {
                     testCleanupMethod = baseTestCleanupQueue.Dequeue();
-                    testCleanupException = InvokeCleanupMethod(testCleanupMethod, _classInstance, baseTestCleanupQueue.Count, timeoutTokenSource);
+                    testCleanupException = InvokeCleanupMethod(testCleanupMethod, _classInstance, ref executionContext, timeoutTokenSource);
                 }
             }
             finally
             {
+                // TODO: Maybe we should invoke Dispose on the execution context.
 #if NET6_0_OR_GREATER
                 // If you implement IAsyncDisposable without calling the DisposeAsync this would result a resource leak.
                 (_classInstance as IAsyncDisposable)?.DisposeAsync().AsTask().Wait();
@@ -770,10 +775,11 @@ private void RunTestCleanupMethod(TestResult result, CancellationTokenSource? ti
     /// </summary>
     /// <param name="classInstance">Instance of TestClass.</param>
     /// <param name="result">Instance of TestResult.</param>
+    /// <param name="executionContext">The execution context to execute the test initialize on.</param>
     /// <param name="timeoutTokenSource">The timeout token source.</param>
     /// <returns>True if the TestInitialize method(s) did not throw an exception.</returns>
     [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
-    private bool RunTestInitializeMethod(object classInstance, TestResult result, CancellationTokenSource? timeoutTokenSource)
+    private bool RunTestInitializeMethod(object classInstance, TestResult result, ref ExecutionContext? executionContext, CancellationTokenSource? timeoutTokenSource)
     {
         DebugEx.Assert(classInstance != null, "classInstance != null");
         DebugEx.Assert(result != null, "result != null");
@@ -790,7 +796,7 @@ private bool RunTestInitializeMethod(object classInstance, TestResult result, Ca
             {
                 testInitializeMethod = baseTestInitializeStack.Pop();
                 testInitializeException = testInitializeMethod is not null
-                    ? InvokeInitializeMethod(testInitializeMethod, classInstance, timeoutTokenSource)
+                    ? InvokeInitializeMethod(testInitializeMethod, classInstance, ref executionContext, timeoutTokenSource)
                     : null;
                 if (testInitializeException is not null)
                 {
@@ -802,7 +808,7 @@ private bool RunTestInitializeMethod(object classInstance, TestResult result, Ca
             {
                 testInitializeMethod = Parent.TestInitializeMethod;
                 testInitializeException = testInitializeMethod is not null
-                    ? InvokeInitializeMethod(testInitializeMethod, classInstance, timeoutTokenSource)
+                    ? InvokeInitializeMethod(testInitializeMethod, classInstance, ref executionContext, timeoutTokenSource)
                     : null;
             }
         }
@@ -851,7 +857,7 @@ private bool RunTestInitializeMethod(object classInstance, TestResult result, Ca
         return false;
     }
 
-    private TestFailedException? InvokeInitializeMethod(MethodInfo methodInfo, object classInstance, CancellationTokenSource? timeoutTokenSource)
+    private TestFailedException? InvokeInitializeMethod(MethodInfo methodInfo, object classInstance, ref ExecutionContext? executionContext, CancellationTokenSource? timeoutTokenSource)
     {
         TimeoutInfo? timeout = null;
         if (Parent.TestInitializeMethodTimeoutMilliseconds.TryGetValue(methodInfo, out TimeoutInfo localTimeout))
@@ -859,20 +865,31 @@ private bool RunTestInitializeMethod(object classInstance, TestResult result, Ca
             timeout = localTimeout;
         }
 
-        return FixtureMethodRunner.RunWithTimeoutAndCancellation(
-            () => methodInfo.InvokeAsSynchronousTask(classInstance, null),
+        ExecutionContext? updatedExecutionContext = executionContext;
+
+        TestFailedException? result = FixtureMethodRunner.RunWithTimeoutAndCancellation(
+            () =>
+            {
+                methodInfo.InvokeAsSynchronousTask(classInstance, null);
+                // **After** we have executed the current test initialize (it could be from the current class or from base class), we save the current context.
+                // This context will contain async locals set by the test initialize method.
+                updatedExecutionContext = ExecutionContext.Capture();
+            },
             TestContext!.Context.CancellationTokenSource,
             timeout,
             methodInfo,
-            new InstanceExecutionContextScope(classInstance, Parent.ClassType),
+            executionContext,
             Resource.TestInitializeWasCancelled,
             Resource.TestInitializeTimedOut,
             timeoutTokenSource is null
                 ? null
                 : (timeoutTokenSource, TimeoutInfo.Timeout));
+
+        executionContext = updatedExecutionContext;
+        return result;
     }
 
-    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, object classInstance, int remainingCleanupCount, CancellationTokenSource? timeoutTokenSource)
+    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, object classInstance, ref ExecutionContext? executionContext, CancellationTokenSource? timeoutTokenSource)
     {
         TimeoutInfo? timeout = null;
         if (Parent.TestCleanupMethodTimeoutMilliseconds.TryGetValue(methodInfo, out TimeoutInfo localTimeout))
@@ -880,17 +897,27 @@ timeoutTokenSource is null
             timeout = localTimeout;
         }
 
-        return FixtureMethodRunner.RunWithTimeoutAndCancellation(
-            () => methodInfo.InvokeAsSynchronousTask(classInstance, null),
+        ExecutionContext? updatedExecutionContext = executionContext;
+        TestFailedException? result = FixtureMethodRunner.RunWithTimeoutAndCancellation(
+            () =>
+            {
+                methodInfo.InvokeAsSynchronousTask(classInstance, null);
+                // **After** we have executed the current test cleanup (it could be from the current class or from base class), we save the current context.
+                // This context will contain async locals set by the test cleanup method.
+                updatedExecutionContext = ExecutionContext.Capture();
+            },
             TestContext!.Context.CancellationTokenSource,
             timeout,
             methodInfo,
-            new InstanceExecutionContextScope(classInstance, Parent.ClassType, remainingCleanupCount),
+            executionContext,
             Resource.TestCleanupWasCancelled,
             Resource.TestCleanupTimedOut,
             timeoutTokenSource is null
                 ? null
                 : (timeoutTokenSource, TimeoutInfo.Timeout));
+
+        executionContext = updatedExecutionContext;
+        return result;
     }
 
     /// <summary>
@@ -1004,9 +1031,10 @@ private bool SetTestContext(object classInstance, TestResult result)
     /// Execute test with a timeout.
     /// </summary>
     /// <param name="arguments">The arguments to be passed.</param>
+    /// <param name="executionContext">The execution context to execute the test method on.</param>
     /// <returns>The result of execution.</returns>
     [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
-    private TestResult ExecuteInternalWithTimeout(object?[]? arguments)
+    private TestResult ExecuteInternalWithTimeout(object?[]? arguments, ExecutionContext? executionContext)
     {
         DebugEx.Assert(IsTimeoutSet, "Timeout should be set");
 
@@ -1030,7 +1058,7 @@ private TestResult ExecuteInternalWithTimeout(object?[]? arguments)
 
                 try
                 {
-                    return ExecuteInternal(arguments, timeoutTokenSource);
+                    return ExecuteInternal(arguments, executionContext, timeoutTokenSource);
                 }
                 catch (OperationCanceledException)
                 {
@@ -1068,7 +1096,7 @@ private TestResult ExecuteInternalWithTimeout(object?[]? arguments)
 
             // It's possible that some failures happened and that the cleanup wasn't executed, so we need to run it here.
             // The method already checks if the cleanup was already executed.
-            RunTestCleanupMethod(result, null);
+            RunTestCleanupMethod(result, executionContext, null);
             return result;
         }
 
@@ -1086,9 +1114,13 @@ private TestResult ExecuteInternalWithTimeout(object?[]? arguments)
 
         TestResult timeoutResult = new() { Outcome = UTF.UnitTestOutcome.Timeout, TestFailureException = new TestFailedException(UTFUnitTestOutcome.Timeout, errorMessage) };
 
+        // TODO: execution context propagation here may still not be accurate.
+        // if test init was successfully executed by ExecuteAsyncAction, but then the test itself timed out or cancelled,
+        // then at this point we will run the cleanup on an execution context that doesn't have any state set by the test initialize.
+
         // We don't know when the cancellation happened so it's possible that the cleanup wasn't executed, so we need to run it here.
         // The method already checks if the cleanup was already executed.
-        RunTestCleanupMethod(timeoutResult, null);
+        RunTestCleanupMethod(timeoutResult, executionContext, null);
         return timeoutResult;
 
         // Local functions
@@ -1096,7 +1128,7 @@ void ExecuteAsyncAction()
         {
             try
             {
-                result = ExecuteInternal(arguments, null);
+                result = ExecuteInternal(arguments, executionContext, null);
             }
             catch (Exception ex)
             {
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index 553b831523..fb8b348fcd 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -127,6 +127,8 @@ internal FixtureTestResult GetFixtureTestResult(TestMethod testMethod, string fi
         static UnitTestOutcome GetOutcome(Exception? exception) => exception == null ? UnitTestOutcome.Passed : UnitTestOutcome.Failed;
     }
 
+    public static AsyncLocal<string> StringAsyncLocal { get; } = new();
+
     // Task cannot cross app domains.
     // For now, TestExecutionManager will call this sync method which is hacky.
     // If we removed AppDomains in v4, we should use the async method and remove this one.
diff --git a/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs b/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
index 2c9425c3c6..03f9b65a84 100644
--- a/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
@@ -4,7 +4,6 @@
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Execution;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.ObjectModel;
-using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Extensions;
 
 using UnitTestOutcome = Microsoft.VisualStudio.TestTools.UnitTesting.UnitTestOutcome;
@@ -13,9 +12,21 @@ namespace Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 
 internal static class FixtureMethodRunner
 {
+    private static void RunOnContext(ExecutionContext? executionContext, Action action)
+    {
+        if (executionContext is null)
+        {
+            action();
+        }
+        else
+        {
+            ExecutionContext.Run(executionContext, static action => ((Action)action!).Invoke(), action);
+        }
+    }
+
     internal static TestFailedException? RunWithTimeoutAndCancellation(
         Action action, CancellationTokenSource cancellationTokenSource, TimeoutInfo? timeoutInfo, MethodInfo methodInfo,
-        IExecutionContextScope executionContextScope, string methodCanceledMessageFormat, string methodTimedOutMessageFormat,
+        ExecutionContext? executionContext, string methodCanceledMessageFormat, string methodTimedOutMessageFormat,
         // When a test method is marked with [Timeout], this timeout is applied from ctor to destructor, so we need to take
         // that into account when processing the OCE of the action.
         (CancellationTokenSource TokenSource, int Timeout)? testTimeoutInfo = default)
@@ -33,7 +44,7 @@ internal static class FixtureMethodRunner
         {
             try
             {
-                action();
+                RunOnContext(executionContext, action);
                 return null;
             }
             catch (Exception ex)
@@ -62,16 +73,16 @@ internal static class FixtureMethodRunner
 
         if (timeoutInfo.Value.CooperativeCancellation)
         {
-            return RunWithCooperativeCancellation(action, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, methodCanceledMessageFormat, methodTimedOutMessageFormat);
+            return RunWithCooperativeCancellation(action, executionContext, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, methodCanceledMessageFormat, methodTimedOutMessageFormat);
         }
 
         // We need to start a thread to handle "cancellation" and "timeout" scenarios.
         return RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Thread.CurrentThread.GetApartmentState() == ApartmentState.STA
-            ? RunWithTimeoutAndCancellationWithSTAThread(action, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, executionContextScope, methodCanceledMessageFormat, methodTimedOutMessageFormat)
-            : RunWithTimeoutAndCancellationWithThreadPool(action, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, executionContextScope, methodCanceledMessageFormat, methodTimedOutMessageFormat);
+            ? RunWithTimeoutAndCancellationWithSTAThread(action, executionContext, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, methodCanceledMessageFormat, methodTimedOutMessageFormat)
+            : RunWithTimeoutAndCancellationWithThreadPool(action, executionContext, cancellationTokenSource, timeoutInfo.Value.Timeout, methodInfo, methodCanceledMessageFormat, methodTimedOutMessageFormat);
     }
 
-    private static TestFailedException? RunWithCooperativeCancellation(Action action, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo, string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
+    private static TestFailedException? RunWithCooperativeCancellation(Action action, ExecutionContext? executionContext, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo, string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
     {
         CancellationTokenSource? timeoutTokenSource = null;
         try
@@ -92,7 +103,7 @@ internal static class FixtureMethodRunner
 
             try
             {
-                action();
+                RunOnContext(executionContext, action);
                 return null;
             }
             catch (Exception ex) when (ex.IsOperationCanceledExceptionFromToken(cancellationTokenSource.Token))
@@ -122,8 +133,8 @@ internal static class FixtureMethodRunner
     }
 
     private static TestFailedException? RunWithTimeoutAndCancellationWithThreadPool(
-        Action action, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo,
-        IExecutionContextScope executionContextScope, string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
+        Action action, ExecutionContext? executionContext, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo,
+        string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
     {
         Exception? realException = null;
         Task? executionTask;
@@ -134,7 +145,7 @@ internal static class FixtureMethodRunner
                 {
                     try
                     {
-                        ExecutionContextService.RunActionOnContext(action, executionContextScope);
+                        RunOnContext(executionContext, action);
                     }
                     catch (Exception ex)
                     {
@@ -188,15 +199,15 @@ internal static class FixtureMethodRunner
 
     [SupportedOSPlatform("windows")]
     private static TestFailedException? RunWithTimeoutAndCancellationWithSTAThread(
-        Action action, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo,
-        IExecutionContextScope executionContextScope, string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
+        Action action, ExecutionContext? executionContext, CancellationTokenSource cancellationTokenSource, int timeout, MethodInfo methodInfo,
+        string methodCanceledMessageFormat, string methodTimedOutMessageFormat)
     {
         TaskCompletionSource<int> tcs = new();
         Thread executionThread = new(() =>
         {
             try
             {
-                ExecutionContextService.RunActionOnContext(action, executionContextScope);
+                RunOnContext(executionContext, action);
                 tcs.SetResult(0);
             }
             catch (Exception ex)
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/AssemblyExecutionContextScope.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/AssemblyExecutionContextScope.cs
deleted file mode 100644
index 05c06baf34..0000000000
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/AssemblyExecutionContextScope.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-﻿// Copyright (c) Microsoft Corporation. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-namespace Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
-
-internal readonly struct AssemblyExecutionContextScope : IExecutionContextScope
-{
-    public AssemblyExecutionContextScope(bool isCleanup) => IsCleanup = isCleanup;
-
-    public bool IsCleanup { get; }
-}
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/ClassExecutionContextScope.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/ClassExecutionContextScope.cs
deleted file mode 100644
index 4886a77b32..0000000000
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/ClassExecutionContextScope.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-﻿// Copyright (c) Microsoft Corporation. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-namespace Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
-
-internal readonly struct ClassExecutionContextScope : IExecutionContextScope
-{
-    public ClassExecutionContextScope(Type type)
-    {
-        Type = type;
-        IsCleanup = false;
-        RemainingCleanupCount = 0;
-    }
-
-    public ClassExecutionContextScope(Type type, int remainingCleanupCount)
-    {
-        Type = type;
-        IsCleanup = true;
-        RemainingCleanupCount = remainingCleanupCount;
-    }
-
-    public Type Type { get; }
-
-    public bool IsCleanup { get; }
-
-    public int RemainingCleanupCount { get; }
-
-    public override int GetHashCode() => Type.GetHashCode();
-
-    public override bool Equals(object? obj) => Type.Equals(obj);
-}
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/ExecutionContextService.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/ExecutionContextService.cs
deleted file mode 100644
index 9ba8f8c5d1..0000000000
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/ExecutionContextService.cs
+++ /dev/null
@@ -1,189 +0,0 @@
-﻿// Copyright (c) Microsoft Corporation. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-namespace Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
-
-internal static class ExecutionContextService
-{
-    /// <summary>
-    /// The execution context to use by class fixtures (ClassInitialize and ClassCleanup).
-    ///
-    /// The type used as key is the type of the test class and not the type of the method info, this is ensuring that mutations
-    /// done in parent classes are correctly impacting only the current context class.
-    ///
-    /// The logic for the context associated to the key is as follows:
-    /// - Copy and reuse the assembly level context,
-    /// - If not available, capture the current context and use it.
-    /// After each ClassInitialize or ClassCleanup, mutate (recapture) the context for the class.
-    /// </summary>
-    private static readonly ConcurrentDictionary<Type, ExecutionContext?> ClassesExecutionContexts = new();
-
-    /// <summary>
-    /// The execution context to use for instance methods fixtures and tests (TestInitialize, TestMethod, TestCleanup).
-    ///
-    /// The key is the instance of the test class.
-    ///
-    /// The logic for the context associated to the key is as follows:
-    /// - Copy and reuse the class level context,
-    /// - If not available, reuse the assembly level context,
-    /// - If not available, capture the current context and use it.
-    /// After each TestInitialize or TestCleanup, mutate (recapture) the context for the instance.
-    /// </summary>
-    private static readonly ConcurrentDictionary<object, ExecutionContext?> InstancesExecutionContexts = new();
-
-    /// <summary>
-    /// As we only support one assembly level context, we store it here.
-    /// </summary>
-    private static ExecutionContext? s_assemblyExecutionContext;
-
-    /// <summary>
-    /// When we execute the action, we need to ensure we are restoring the execution context that was captured in the logical flow of execution.
-    /// After the action is executed we capture the current execution context and save it for the next action to use based on the current execution context scope.
-    ///
-    /// The logical flow of execution is:
-    /// - AssemblyInitialize execution context is saved at "assembly level" and a copy is flown to each ClassInitialize.
-    /// - ClassInitialize execution context is saved at "class level" and a copy is flown to each TestInitialize/TestMethod/TestCleanup.
-    /// - TestInitialize/TestMethod/TestCleanup execution context is mutating the "instance level"
-    /// - ClassCleanup reuses the "class level" execution context.
-    /// - AssemblyCleanup reuses the "assembly level" execution context.
-    /// </summary>
-    internal static void RunActionOnContext(Action action, IExecutionContextScope executionContextScope)
-    {
-        // TODO: Log (trace/debug) the execution context scope and the current execution context.
-        // This would be particularly useful if we have a strange context issue to understand what is being set or not,
-        // What we manage to capture and what we don't, etc.
-        if (GetScopedExecutionContext(executionContextScope) is not { } executionContext)
-        {
-            // We don't have any execution context (that's usually the case when it is being suppressed), so we can run the action directly.
-            action();
-            return;
-        }
-
-        // We have an execution context, so we need to run the action in that context to ensure the flow of execution is preserved.
-        ExecutionContext.Run(
-            executionContext,
-            _ =>
-            {
-                action();
-
-                if (ShouldCleanup(executionContextScope))
-                {
-                    CleanupExecutionContext(executionContextScope);
-                }
-                else
-                {
-                    // The execution context and synchronization contexts of the calling thread are returned to their previous
-                    // states when the method completes. That's why we need to capture the state and mutate the state before exiting.
-                    SaveExecutionContext(executionContextScope);
-                }
-            },
-            null);
-    }
-
-    /// <summary>
-    /// Capture the new state of the execution context and mutate the right variable/dictionary based on the execution context scope.
-    /// </summary>
-    private static void SaveExecutionContext(IExecutionContextScope executionContextScope)
-    {
-        var capturedContext = ExecutionContext.Capture();
-        switch (executionContextScope)
-        {
-            case AssemblyExecutionContextScope:
-                s_assemblyExecutionContext = capturedContext;
-                break;
-
-            case ClassExecutionContextScope classExecutionContextScope:
-                ClassesExecutionContexts.AddOrUpdate(
-                    classExecutionContextScope.Type,
-                    _ => capturedContext,
-                    (_, _) => capturedContext);
-                break;
-
-            case InstanceExecutionContextScope instanceExecutionContextScope:
-                InstancesExecutionContexts.AddOrUpdate(
-                    instanceExecutionContextScope.Instance,
-                    _ => capturedContext,
-                    (_, _) => capturedContext);
-                break;
-        }
-    }
-
-    /// <summary>
-    /// Clears up the backed up execution state based on the execution context scope.
-    /// </summary>
-    private static void CleanupExecutionContext(IExecutionContextScope executionContextScope)
-    {
-        Debug.Assert(executionContextScope.IsCleanup, "CleanupExecutionContext should be called only in a cleanup scope.");
-
-        switch (executionContextScope)
-        {
-            case AssemblyExecutionContextScope:
-                // When calling the assembly cleanup, we can clear up all the contexts that would not have been cleaned up.
-                foreach (ExecutionContext? context in InstancesExecutionContexts.Values)
-                {
-                    context?.Dispose();
-                }
-
-                foreach (ExecutionContext? context in ClassesExecutionContexts.Values)
-                {
-                    context?.Dispose();
-                }
-
-                InstancesExecutionContexts.Clear();
-                ClassesExecutionContexts.Clear();
-                s_assemblyExecutionContext?.Dispose();
-                s_assemblyExecutionContext = null;
-                break;
-
-            case ClassExecutionContextScope classExecutionContextScope:
-                _ = ClassesExecutionContexts.TryRemove(classExecutionContextScope.Type, out ExecutionContext? classContext);
-                classContext?.Dispose();
-                break;
-
-            case InstanceExecutionContextScope instanceExecutionContextScope:
-                _ = InstancesExecutionContexts.TryRemove(instanceExecutionContextScope.Instance, out ExecutionContext? instanceContext);
-                instanceContext?.Dispose();
-                break;
-        }
-    }
-
-    private static ExecutionContext? GetScopedExecutionContext(IExecutionContextScope executionContextScope)
-    {
-        ExecutionContext? executionContext = executionContextScope switch
-        {
-            // Return the assembly level context or capture and save it if it doesn't exist.
-            AssemblyExecutionContextScope => s_assemblyExecutionContext ??= ExecutionContext.Capture(),
-
-            // Return the class level context or if it doesn't exist do the following steps:
-            // - use the assembly level context if it exists
-            // - or capture and save current context
-            ClassExecutionContextScope classExecutionContextScope => ClassesExecutionContexts.GetOrAdd(
-                classExecutionContextScope.Type,
-                _ => s_assemblyExecutionContext ?? ExecutionContext.Capture()),
-
-            // Return the instance level context or if it doesn't exist do the following steps:
-            // - use the class level context if it exists
-            // - or use the assembly level context if it exists
-            // - or capture and save current context
-            InstanceExecutionContextScope instanceExecutionContextScope => InstancesExecutionContexts.GetOrAdd(
-                instanceExecutionContextScope.Instance,
-                _ => ClassesExecutionContexts.TryGetValue(instanceExecutionContextScope.Type, out ExecutionContext? classExecutionContext)
-                    ? classExecutionContext
-                    : s_assemblyExecutionContext ?? ExecutionContext.Capture()),
-            _ => throw new NotSupportedException($"Unsupported execution context scope: {executionContextScope.GetType()}"),
-        };
-
-        // Always create a copy of the context because running twice on the same context results in an error.
-        return executionContext?.CreateCopy();
-    }
-
-    private static bool ShouldCleanup(this IExecutionContextScope executionContextScope)
-        => executionContextScope.IsCleanup
-        && executionContextScope switch
-        {
-            AssemblyExecutionContextScope => true,
-            ClassExecutionContextScope classExecutionContextScope => classExecutionContextScope.RemainingCleanupCount == 0,
-            InstanceExecutionContextScope instanceExecutionContext => instanceExecutionContext.RemainingCleanupCount == 0,
-            _ => throw new NotSupportedException($"Unsupported execution context scope: {executionContextScope.GetType()}"),
-        };
-}
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/IExecutionContextScope.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/IExecutionContextScope.cs
deleted file mode 100644
index 7119d94a5c..0000000000
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/IExecutionContextScope.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿// Copyright (c) Microsoft Corporation. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-namespace Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
-
-internal interface IExecutionContextScope
-{
-    public bool IsCleanup { get; }
-}
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/InstanceExecutionContextScope.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/InstanceExecutionContextScope.cs
deleted file mode 100644
index 99229a4d7a..0000000000
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/InstanceExecutionContextScope.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿// Copyright (c) Microsoft Corporation. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-namespace Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
-
-internal readonly struct InstanceExecutionContextScope : IExecutionContextScope
-{
-    public InstanceExecutionContextScope(object instance, Type type)
-    {
-        Instance = instance;
-        Type = type;
-        IsCleanup = false;
-        RemainingCleanupCount = 0;
-    }
-
-    public InstanceExecutionContextScope(object instance, Type type, int remainingCleanupCount)
-    {
-        Instance = instance;
-        Type = type;
-        IsCleanup = true;
-        RemainingCleanupCount = remainingCleanupCount;
-    }
-
-    public object Instance { get; }
-
-    public Type Type { get; }
-
-    public bool IsCleanup { get; }
-
-    public int RemainingCleanupCount { get; }
-
-    public override int GetHashCode() => Instance.GetHashCode();
-
-    public override bool Equals(object? obj) => Instance.Equals(obj);
-}

From 754baa5dc5b90547f0749eb33431233e022c0295 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Sun, 2 Mar 2025 10:27:04 +0100
Subject: [PATCH 02/23] Fix tests

---
 .../ThreadContextTests.cs                     | 74 +++----------------
 1 file changed, 11 insertions(+), 63 deletions(-)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
index 1c64b26e18..7d6bf5b7e3 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
@@ -68,10 +68,7 @@ public async Task ThreadingContext_WhenUsingSTAThreadAndTimeout_CurrentCultureFl
     {
         var testHost = TestHost.LocateFrom(AssetFixture.CultureFlowsProjectPath, TestAssetFixture.CultureFlowsProjectName, tfm);
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "sta-timeout.runsettings");
-        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}", environmentVariables: new()
-        {
-            ["MSTEST_TEST_FLOW_CONTEXT"] = "true",
-        });
+        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
         testHostResult.AssertOutputContainsSummary(failed: 0, passed: 1, skipped: 0);
     }
@@ -82,10 +79,7 @@ public async Task ThreadingContext_WhenUsingTimeout_CurrentCultureFlowsBetweenMe
     {
         var testHost = TestHost.LocateFrom(AssetFixture.CultureFlowsProjectPath, TestAssetFixture.CultureFlowsProjectName, tfm);
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "timeout.runsettings");
-        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}", environmentVariables: new()
-        {
-            ["MSTEST_TEST_FLOW_CONTEXT"] = "true",
-        });
+        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
         testHostResult.AssertOutputContainsSummary(failed: 0, passed: 1, skipped: 0);
     }
@@ -117,10 +111,7 @@ public async Task ThreadingContext_Inheritance_WhenUsingSTAThreadAndTimeout_Curr
     {
         var testHost = TestHost.LocateFrom(AssetFixture.CultureFlowsInheritanceProjectPath, TestAssetFixture.CultureFlowsInheritanceProjectName, tfm);
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "sta-timeout.runsettings");
-        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}", environmentVariables: new()
-        {
-            ["MSTEST_TEST_FLOW_CONTEXT"] = "true",
-        });
+        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
         testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
     }
@@ -131,10 +122,7 @@ public async Task ThreadingContext_Inheritance_WhenUsingTimeout_CurrentCultureFl
     {
         var testHost = TestHost.LocateFrom(AssetFixture.CultureFlowsInheritanceProjectPath, TestAssetFixture.CultureFlowsInheritanceProjectName, tfm);
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "timeout.runsettings");
-        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}", environmentVariables: new()
-        {
-            ["MSTEST_TEST_FLOW_CONTEXT"] = "true",
-        });
+        TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
         testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
     }
@@ -332,32 +320,15 @@ public void TestCleanup()
     [ClassCleanup]
     public static void ClassCleanup()
     {
-        if (Environment.GetEnvironmentVariable("MSTEST_TEST_FLOW_CONTEXT") == "true")
-        {
-            Assert.AreEqual(ClassInitCultureCodeName, CultureInfo.CurrentCulture.Name,
-                "ClassCleanup culture should have been the one set by ClassInitialize");
-        }
-        else
-        {
-            Assert.AreEqual(TestCleanupCultureCodeName, CultureInfo.CurrentCulture.Name,
-                "ClassCleanup culture should have been the one set by TestCleanup");
-            CultureInfo.CurrentCulture = new CultureInfo(ClassCleanupCultureCodeName);
-        }
+        Assert.AreEqual(ClassInitCultureCodeName, CultureInfo.CurrentCulture.Name,
+            "ClassCleanup culture should have been the one set by ClassInitialize");
     }
 
     [AssemblyCleanup]
     public static void AssemblyCleanup()
     {
-        if (Environment.GetEnvironmentVariable("MSTEST_TEST_FLOW_CONTEXT") == "true")
-        {
-            Assert.AreEqual(AssemblyInitCultureCodeName, CultureInfo.CurrentCulture.Name,
-                "AssemblyCleanup culture should have been the one set by AssemblyInitialize");
-        }
-        else
-        {
-            Assert.AreEqual(ClassCleanupCultureCodeName, CultureInfo.CurrentCulture.Name,
-                "AssemblyCleanup culture should have been the one set by ClassCleanup");
-        }
+        Assert.AreEqual(AssemblyInitCultureCodeName, CultureInfo.CurrentCulture.Name,
+            "AssemblyCleanup culture should have been the one set by AssemblyInitialize");
     }
 }
 """;
@@ -466,14 +437,7 @@ public static void BaseClassCleanup()
         switch (_testContext.ManagedMethod)
         {
             case "DerivedClassIntermediateClassWithoutInheritanceBaseClassWithInheritanceTestMethod":
-                if (Environment.GetEnvironmentVariable("MSTEST_TEST_FLOW_CONTEXT") == "true")
-                {
-                    Assert.AreEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
-                }
-                else
-                {
-                    Assert.AreEqual(ExpectedCultures.TestMethodCulture, CultureInfo.CurrentCulture.Name);
-                }
+                Assert.AreEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
                 break;
 
             case "DerivedClassIntermediateClassWithInheritanceBaseClassWithInheritanceTestMethod":
@@ -515,15 +479,7 @@ public static void IntermediateClassInitialize(TestContext testContext)
     [ClassCleanup(InheritanceBehavior.BeforeEachDerivedClass, ClassCleanupBehavior.EndOfClass)]
     public static void IntermediateClassCleanup()
     {
-        if (Environment.GetEnvironmentVariable("MSTEST_TEST_FLOW_CONTEXT") == "true")
-        {
-            Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
-        }
-        else
-        {
-            Assert.AreEqual(ExpectedCultures.TestMethodCulture, CultureInfo.CurrentCulture.Name);
-        }
-
+        Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.IntermediateClassCleanupCulture);
     }
 }
@@ -540,15 +496,7 @@ public static void IntermediateClassInitialize(TestContext testContext)
     [ClassCleanup(InheritanceBehavior.BeforeEachDerivedClass, ClassCleanupBehavior.EndOfClass)]
     public static void IntermediateClassCleanup()
     {
-        if (Environment.GetEnvironmentVariable("MSTEST_TEST_FLOW_CONTEXT") == "true")
-        {
-            Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
-        }
-        else
-        {
-            Assert.AreEqual(ExpectedCultures.TestMethodCulture, CultureInfo.CurrentCulture.Name);
-        }
-
+        Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.IntermediateClassCleanupCulture);
     }
 }

From 8d2a202aeed31d26477f8cc23898fa6455e4bb98 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Sun, 2 Mar 2025 17:37:11 +0100
Subject: [PATCH 03/23] Fix for class cleanups

---
 src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 65d6e7017f..458dc21783 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -821,6 +821,11 @@ void DoRun()
                 {
                     methodInfo.InvokeAsSynchronousTask(null, testContext);
                 }
+
+                // **After** we have executed the class cleanup, we save the current context.
+                // This context will contain async locals set by the current class cleanup method.
+                // This is essential to propagate async locals between multiple class cleanup methods.
+                ExecutionContext = ExecutionContext.Capture();
             },
             testContext.CancellationTokenSource,
             timeout,

From c11c4bead75e0985657d8401526bdadae5fc8722 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 08:34:08 +0100
Subject: [PATCH 04/23] Adjust

---
 .../MSTest.TestAdapter/Execution/TestAssemblyInfo.cs   | 10 ++++++++--
 .../MSTest.TestAdapter/Execution/TestClassInfo.cs      |  2 +-
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
index 4c9028b8ec..7a2bf0aff1 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
@@ -154,7 +154,7 @@ public void RunAssemblyInitialize(TestContext testContext)
                             testContext.CancellationTokenSource,
                             AssemblyInitializeMethodTimeoutMilliseconds,
                             AssemblyInitializeMethod,
-                            executionContext: null, // Assembly initialize is the first thing that we run. So just execute on the current execution context.
+                            executionContext: ExecutionContext,
                             Resource.AssemblyInitializeWasCancelled,
                             Resource.AssemblyInitializeTimedOut);
                     }
@@ -223,7 +223,11 @@ public void RunAssemblyInitialize(TestContext testContext)
             try
             {
                 AssemblyCleanupException = FixtureMethodRunner.RunWithTimeoutAndCancellation(
-                     () => AssemblyCleanupMethod.InvokeAsSynchronousTask(null),
+                     () =>
+                     {
+                         AssemblyCleanupMethod.InvokeAsSynchronousTask(null);
+                         ExecutionContext = ExecutionContext.Capture();
+                     },
                      new CancellationTokenSource(),
                      AssemblyCleanupMethodTimeoutMilliseconds,
                      AssemblyCleanupMethod,
@@ -289,6 +293,8 @@ public void RunAssemblyInitialize(TestContext testContext)
                          {
                              AssemblyCleanupMethod.InvokeAsSynchronousTask(null, testContext);
                          }
+
+                         ExecutionContext = ExecutionContext.Capture();
                      },
                      testContext.CancellationTokenSource,
                      AssemblyCleanupMethodTimeoutMilliseconds,
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 458dc21783..7d2d86d49f 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -515,7 +515,7 @@ TestResult DoRun()
             // We run the class initialize on a copy of the execution context of the assembly.
             // That way, async locals set by assembly initialize are visible to class initialize.
             // But we copy so that async locals set by class initialize are not visible to assembly cleanup.
-            Parent?.ExecutionContext?.CreateCopy(),
+            ExecutionContext ?? Parent?.ExecutionContext?.CreateCopy(),
             Resource.ClassInitializeWasCancelled,
             Resource.ClassInitializeTimedOut);
     }

From 30da828ac7413036aacd55148a4fb68bc8aacf04 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 10:27:36 +0100
Subject: [PATCH 05/23] Adjust for netfx

---
 .../Execution/TestMethodInfo.cs               | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 12beb0821d..675d372166 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -404,14 +404,27 @@ private TestResult ExecuteInternal(object?[]? arguments, ExecutionContext? execu
                         hasTestInitializePassed = true;
                         if (executionContext is null)
                         {
-                            TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                            try
+                            {
+                                TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                            }
+                            finally
+                            {
+                                executionContext = ExecutionContext.Capture();
+                            }
                         }
                         else
                         {
                             ExecutionContext.Run(executionContext, _ =>
                             {
-                                TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
-                                executionContext = ExecutionContext.Capture();
+                                try
+                                {
+                                    TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                                }
+                                finally
+                                {
+                                    executionContext = ExecutionContext.Capture();
+                                }
                             }, null);
                         }
 

From 2729257ff8c708b0563eb3d482102b0b3626d1f8 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 11:36:26 +0100
Subject: [PATCH 06/23] Adjust

---
 .../Execution/TestClassInfo.cs                |  4 +--
 .../Execution/TestMethodInfo.cs               | 30 ++++---------------
 .../Helpers/FixtureMethodRunner.cs            |  8 ++++-
 3 files changed, 14 insertions(+), 28 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 7d2d86d49f..56a3819f1c 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -515,7 +515,7 @@ TestResult DoRun()
             // We run the class initialize on a copy of the execution context of the assembly.
             // That way, async locals set by assembly initialize are visible to class initialize.
             // But we copy so that async locals set by class initialize are not visible to assembly cleanup.
-            ExecutionContext ?? Parent?.ExecutionContext?.CreateCopy(),
+            ExecutionContext ?? Parent?.ExecutionContext,
             Resource.ClassInitializeWasCancelled,
             Resource.ClassInitializeTimedOut);
     }
@@ -833,7 +833,7 @@ void DoRun()
             // If we had a class initialize that have set the execution context, we use that.
             // Otherwise, we still want to use the execution context of the assembly.
             // Note that if we have a class initialize, its execution context was already a copy of the assembly's context.
-            ExecutionContext ?? Parent.ExecutionContext?.CreateCopy(),
+            ExecutionContext ?? Parent.ExecutionContext,
             Resource.ClassCleanupWasCancelled,
             Resource.ClassCleanupTimedOut);
     }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 675d372166..b6162c87c5 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -153,7 +153,7 @@ public virtual TestResult Invoke(object?[]? arguments)
         watch.Start();
         try
         {
-            ExecutionContext? executionContext = (Parent.ExecutionContext ?? Parent.Parent.ExecutionContext)?.CreateCopy();
+            ExecutionContext? executionContext = Parent.ExecutionContext ?? Parent.Parent.ExecutionContext;
             result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments, executionContext) : ExecuteInternal(arguments, executionContext, null);
         }
         finally
@@ -402,31 +402,11 @@ private TestResult ExecuteInternal(object?[]? arguments, ExecutionContext? execu
                     if (RunTestInitializeMethod(_classInstance, result, ref executionContext, timeoutTokenSource))
                     {
                         hasTestInitializePassed = true;
-                        if (executionContext is null)
+                        FixtureMethodRunner.RunOnContext(executionContext, () =>
                         {
-                            try
-                            {
-                                TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
-                            }
-                            finally
-                            {
-                                executionContext = ExecutionContext.Capture();
-                            }
-                        }
-                        else
-                        {
-                            ExecutionContext.Run(executionContext, _ =>
-                            {
-                                try
-                                {
-                                    TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
-                                }
-                                finally
-                                {
-                                    executionContext = ExecutionContext.Capture();
-                                }
-                            }, null);
-                        }
+                            TestMethod.InvokeAsSynchronousTask(_classInstance, arguments);
+                            executionContext = ExecutionContext.Capture();
+                        });
 
                         result.Outcome = UTF.UnitTestOutcome.Passed;
                     }
diff --git a/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs b/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
index 03f9b65a84..c887f103a2 100644
--- a/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Helpers/FixtureMethodRunner.cs
@@ -12,7 +12,7 @@ namespace Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 
 internal static class FixtureMethodRunner
 {
-    private static void RunOnContext(ExecutionContext? executionContext, Action action)
+    internal static void RunOnContext(ExecutionContext? executionContext, Action action)
     {
         if (executionContext is null)
         {
@@ -20,6 +20,12 @@ private static void RunOnContext(ExecutionContext? executionContext, Action acti
         }
         else
         {
+            // CreateCopy doesn't do anything on .NET Core as ExecutionContexts are immutable.
+            // But it's important on .NET Framework.
+            // On .NET Framework, ExecutionContext.Run cannot be called twice with the same ExecutionContext.
+            // Otherwise, it will throw InvalidOperationException with message:
+            // Cannot apply a context that has been marshaled across AppDomains, that was not acquired through a Capture operation or that has already been the argument to a Set call.
+            executionContext = executionContext.CreateCopy();
             ExecutionContext.Run(executionContext, static action => ((Action)action!).Invoke(), action);
         }
     }

From 19f0457c3ffe794a6c75042b2418b41126ed5517 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 11:42:04 +0100
Subject: [PATCH 07/23] Delete wrong comment

---
 src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 56a3819f1c..75521a68ac 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -512,9 +512,6 @@ TestResult DoRun()
             testContext.CancellationTokenSource,
             timeout,
             methodInfo,
-            // We run the class initialize on a copy of the execution context of the assembly.
-            // That way, async locals set by assembly initialize are visible to class initialize.
-            // But we copy so that async locals set by class initialize are not visible to assembly cleanup.
             ExecutionContext ?? Parent?.ExecutionContext,
             Resource.ClassInitializeWasCancelled,
             Resource.ClassInitializeTimedOut);

From 48019ff5ffd4c7489e3b7f914aa4887b5b60b225 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 11:42:40 +0100
Subject: [PATCH 08/23] Remove misleading comment

---
 src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 75521a68ac..e41bc4bb3f 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -827,9 +827,6 @@ void DoRun()
             testContext.CancellationTokenSource,
             timeout,
             methodInfo,
-            // If we had a class initialize that have set the execution context, we use that.
-            // Otherwise, we still want to use the execution context of the assembly.
-            // Note that if we have a class initialize, its execution context was already a copy of the assembly's context.
             ExecutionContext ?? Parent.ExecutionContext,
             Resource.ClassCleanupWasCancelled,
             Resource.ClassCleanupTimedOut);

From 203443f27fd5ab6078ec39a2f369cb8477fb86f3 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 11:54:10 +0100
Subject: [PATCH 09/23] Enhance tests

---
 .../ThreadContextTests.cs                     | 71 +++++++++++++++++++
 1 file changed, 71 insertions(+)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
index 7d6bf5b7e3..e7cbf39b06 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
@@ -163,6 +163,11 @@ public class UnitTest1
 {
     private const string CultureCodeName = "th-TH";
 
+    // Test methods should execute on the class context, and should be isolated.
+    // Changes in one shouldn't affect the other.
+    // This also makes the behavior of parallelizing and non-parallelizing tests consistent.
+    private const string CultureToBeSetInTestMethodAndNotObservedInAnother = "fr-FR";
+
     [AssemblyInitialize]
     public static void AssemblyInitialize(TestContext context)
     {
@@ -194,6 +199,14 @@ public void TestInitialize()
     public void TestMethod1()
     {
         Assert.AreEqual(CultureCodeName, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(CultureToBeSetInTestMethodAndNotObservedInAnother);
+    }
+
+    [TestMethod]
+    public void TestMethod2()
+    {
+        Assert.AreEqual(CultureCodeName, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(CultureToBeSetInTestMethodAndNotObservedInAnother);
     }
 }
 """;
@@ -540,6 +553,13 @@ public void DerivedClassIntermediateClassWithInheritanceBaseClassWithInheritance
         Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithInheritanceBaseClassWithInheritanceTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 [TestClass]
@@ -551,6 +571,13 @@ public void DerivedClassIntermediateClassWithInheritanceBaseClassWithoutInherita
         Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithInheritanceBaseClassWithoutInheritanceTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 [TestClass]
@@ -562,6 +589,13 @@ public void DerivedClassIntermediateClassWithoutInheritanceBaseClassWithInherita
         Assert.AreEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithoutInheritanceBaseClassWithInheritanceTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 [TestClass]
@@ -574,6 +608,14 @@ public void DerivedClassIntermediateClassWithoutInheritanceBaseClassWithoutInher
         Assert.AreNotEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithoutInheritanceBaseClassWithoutInheritanceTestMethod2()
+    {
+        Assert.AreNotEqual(ExpectedCultures.IntermediateClassInitCulture, CultureInfo.CurrentCulture.Name);
+        Assert.AreNotEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 public class BaseClassWithTestInitCleanup
@@ -660,6 +702,13 @@ public void DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithTestIni
         Assert.AreEqual(ExpectedCultures.IntermediateTestInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithTestInitCleanupTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.IntermediateTestInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 
@@ -672,6 +721,13 @@ public void DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithoutTest
         Assert.AreEqual(ExpectedCultures.IntermediateTestInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithoutTestInitCleanupTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.IntermediateTestInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 [TestClass]
@@ -683,6 +739,13 @@ public void DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithTest
         Assert.AreEqual(ExpectedCultures.BaseTestInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithTestInitCleanupTestMethod2()
+    {
+        Assert.AreEqual(ExpectedCultures.BaseTestInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 
 [TestClass]
@@ -695,6 +758,14 @@ public void DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithoutT
         Assert.AreNotEqual(ExpectedCultures.BaseTestInitCulture, CultureInfo.CurrentCulture.Name);
         CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
     }
+
+    [TestMethod]
+    public void DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithoutTestInitCleanupTestMethod2()
+    {
+        Assert.AreNotEqual(ExpectedCultures.IntermediateTestInitCulture, CultureInfo.CurrentCulture.Name);
+        Assert.AreNotEqual(ExpectedCultures.BaseTestInitCulture, CultureInfo.CurrentCulture.Name);
+        CultureInfo.CurrentCulture = new CultureInfo(ExpectedCultures.TestMethodCulture);
+    }
 }
 """;
 

From 724b297f0a77f742199788610387afa08132e354 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 13:29:35 +0100
Subject: [PATCH 10/23] Fix test

---
 .../MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs  | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
index e7cbf39b06..2d8a5a30cc 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
@@ -450,10 +450,12 @@ public static void BaseClassCleanup()
         switch (_testContext.ManagedMethod)
         {
             case "DerivedClassIntermediateClassWithoutInheritanceBaseClassWithInheritanceTestMethod":
+            case "DerivedClassIntermediateClassWithoutInheritanceBaseClassWithInheritanceTestMethod2":
                 Assert.AreEqual(ExpectedCultures.BaseClassInitCulture, CultureInfo.CurrentCulture.Name);
                 break;
 
             case "DerivedClassIntermediateClassWithInheritanceBaseClassWithInheritanceTestMethod":
+            case "DerivedClassIntermediateClassWithInheritanceBaseClassWithInheritanceTestMethod2":
                 Assert.AreEqual(ExpectedCultures.IntermediateClassCleanupCulture, CultureInfo.CurrentCulture.Name);
                 break;
 
@@ -634,10 +636,12 @@ public void BaseTestCleanup()
         switch (TestContext.ManagedMethod)
         {
             case "DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithTestInitCleanupTestMethod":
+            case "DerivedClassIntermediateClassWithTestInitCleanupBaseClassWithTestInitCleanupTestMethod2":
                 Assert.AreEqual(ExpectedCultures.IntermediateTestCleanupCulture, CultureInfo.CurrentCulture.Name);
                 break;
 
             case "DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithTestInitCleanupTestMethod":
+            case "DerivedClassIntermediateClassWithoutTestInitCleanupBaseClassWithTestInitCleanupTestMethod2":
                 Assert.AreEqual(ExpectedCultures.TestMethodCulture, CultureInfo.CurrentCulture.Name);
                 break;
 

From 56168008ec5f4bfcddc0802380638d2afb2941e0 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 13:33:33 +0100
Subject: [PATCH 11/23] More test fixes

---
 .../MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs  | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
index 2d8a5a30cc..0f86c29949 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
@@ -15,7 +15,7 @@ public async Task ThreadingContext_WhenCultureIsNotSet_TestMethodFails(string tf
     {
         var testHost = TestHost.LocateFrom(AssetFixture.InitToTestProjectPath, TestAssetFixture.InitToTestProjectName, tfm);
         TestHostResult testHostResult = await testHost.ExecuteAsync();
-        testHostResult.AssertOutputContainsSummary(failed: 1, passed: 0, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 2, passed: 0, skipped: 0);
     }
 
     [TestMethod]
@@ -38,7 +38,7 @@ private static async Task SetCultureInFixtureMethodAndRunTests(string tfm, strin
         var testHost = TestHost.LocateFrom(AssetFixture.InitToTestProjectPath, TestAssetFixture.InitToTestProjectName, tfm);
         TestHostResult testHostResult = await testHost.ExecuteAsync(environmentVariables: new() { [envVarKey] = "true" });
         testHostResult.AssertExitCodeIs(0);
-        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 1, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 2, skipped: 0);
     }
 
     [TestMethod]

From 3a0a7be892f6cdf1fc466eff9a4cccaece8f39c6 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Mon, 3 Mar 2025 13:58:40 +0100
Subject: [PATCH 12/23] Fix tests

---
 .../ThreadContextTests.cs                                 | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
index 0f86c29949..37ced12466 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/ThreadContextTests.cs
@@ -91,7 +91,7 @@ public async Task ThreadingContext_Inheritance_CurrentCultureFlowsBetweenMethods
         var testHost = TestHost.LocateFrom(AssetFixture.CultureFlowsInheritanceProjectPath, TestAssetFixture.CultureFlowsInheritanceProjectName, tfm);
         TestHostResult testHostResult = await testHost.ExecuteAsync();
         testHostResult.AssertExitCodeIs(0);
-        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 16, skipped: 0);
     }
 
     [TestMethod]
@@ -102,7 +102,7 @@ public async Task ThreadingContext_Inheritance_WhenUsingSTAThread_CurrentCulture
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "sta.runsettings");
         TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
-        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 16, skipped: 0);
     }
 
     [TestMethod]
@@ -113,7 +113,7 @@ public async Task ThreadingContext_Inheritance_WhenUsingSTAThreadAndTimeout_Curr
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "sta-timeout.runsettings");
         TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
-        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 16, skipped: 0);
     }
 
     [TestMethod]
@@ -124,7 +124,7 @@ public async Task ThreadingContext_Inheritance_WhenUsingTimeout_CurrentCultureFl
         string runSettingsFilePath = Path.Combine(testHost.DirectoryName, "timeout.runsettings");
         TestHostResult testHostResult = await testHost.ExecuteAsync($"--settings {runSettingsFilePath}");
         testHostResult.AssertExitCodeIs(0);
-        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 8, skipped: 0);
+        testHostResult.AssertOutputContainsSummary(failed: 0, passed: 16, skipped: 0);
     }
 
     public sealed class TestAssetFixture() : TestAssetFixtureBase(AcceptanceFixture.NuGetGlobalPackagesFolder)

From 1abd43d508225ad60f1605c208a7711f63496b1e Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Tue, 4 Mar 2025 15:25:07 +0100
Subject: [PATCH 13/23] Delete unintentionally committed code

---
 src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index fb8b348fcd..553b831523 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -127,8 +127,6 @@ internal FixtureTestResult GetFixtureTestResult(TestMethod testMethod, string fi
         static UnitTestOutcome GetOutcome(Exception? exception) => exception == null ? UnitTestOutcome.Passed : UnitTestOutcome.Failed;
     }
 
-    public static AsyncLocal<string> StringAsyncLocal { get; } = new();
-
     // Task cannot cross app domains.
     // For now, TestExecutionManager will call this sync method which is hacky.
     // If we removed AppDomains in v4, we should use the async method and remove this one.

From 8e5c7a279cd2246fc4356c1e680dd1fd7d70e5fc Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Wed, 5 Mar 2025 11:26:32 +0100
Subject: [PATCH 14/23] Create LogMessageListener on the correct execution
 context

---
 .../Execution/TestAssemblyInfo.cs             | 11 ++-
 .../Execution/TestClassInfo.cs                | 74 +++++++++++++------
 .../Execution/TestMethodInfo.cs               | 19 +++--
 .../Execution/UnitTestRunner.cs               | 32 +++++---
 4 files changed, 92 insertions(+), 44 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
index 7a2bf0aff1..23db5aef07 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
@@ -113,9 +113,14 @@ internal set
     /// </summary>
     /// <param name="testContext"> The test context. </param>
     /// <exception cref="TestFailedException"> Throws a test failed exception if the initialization method throws an exception. </exception>
-    [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
     public void RunAssemblyInitialize(TestContext testContext)
+        => RunAssemblyInitialize(testContext, out _);
+
+    [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
+    internal void RunAssemblyInitialize(TestContext testContext, out LogMessageListener? logListener)
     {
+        logListener = null;
+
         // No assembly initialize => nothing to do.
         if (AssemblyInitializeMethod == null)
         {
@@ -141,11 +146,14 @@ public void RunAssemblyInitialize(TestContext testContext)
                 // Perform a check again.
                 if (!IsAssemblyInitializeExecuted)
                 {
+                    LogMessageListener? logMessageListener = null;
+
                     try
                     {
                         AssemblyInitializationException = FixtureMethodRunner.RunWithTimeoutAndCancellation(
                             () =>
                             {
+                                logMessageListener = new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces);
                                 AssemblyInitializeMethod.InvokeAsSynchronousTask(null, testContext);
                                 // **After** we have executed the assembly initialize, we save the current context.
                                 // This context will contain async locals set by the assembly initialize method.
@@ -165,6 +173,7 @@ public void RunAssemblyInitialize(TestContext testContext)
                     finally
                     {
                         IsAssemblyInitializeExecuted = true;
+                        logListener = logMessageListener;
                     }
                 }
             }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index e41bc4bb3f..519eb94810 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -249,9 +249,14 @@ internal set
     /// </summary>
     /// <param name="testContext"> The test context. </param>
     /// <exception cref="TestFailedException"> Throws a test failed exception if the initialization method throws an exception. </exception>
-    [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
     public void RunClassInitialize(TestContext testContext)
+        => RunClassInitialize(testContext, out _);
+
+    [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Requirement is to handle all kinds of user exceptions and message appropriately.")]
+    internal void RunClassInitialize(TestContext testContext, out LogMessageListener? logListener)
     {
+        logListener = null;
+
         // If no class initialize and no base class initialize, return
         if (ClassInitializeMethod is null && BaseClassInitMethods.Count == 0)
         {
@@ -282,7 +287,7 @@ public void RunClassInitialize(TestContext testContext)
                 for (int i = BaseClassInitMethods.Count - 1; i >= 0; i--)
                 {
                     initializeMethod = BaseClassInitMethods[i];
-                    ClassInitializationException = InvokeInitializeMethod(initializeMethod, testContext);
+                    ClassInitializationException = InvokeInitializeMethod(initializeMethod, testContext, ref logListener);
                     if (ClassInitializationException is not null)
                     {
                         break;
@@ -292,7 +297,7 @@ public void RunClassInitialize(TestContext testContext)
                 if (ClassInitializationException is null)
                 {
                     initializeMethod = ClassInitializeMethod;
-                    ClassInitializationException = InvokeInitializeMethod(ClassInitializeMethod, testContext);
+                    ClassInitializationException = InvokeInitializeMethod(ClassInitializeMethod, testContext, ref logListener);
                 }
             }
             catch (Exception ex)
@@ -452,18 +457,22 @@ TestResult DoRun()
 
             try
             {
-                using LogMessageListener logListener = new(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+                LogMessageListener? logListener = null;
                 try
                 {
                     // This runs the ClassInitialize methods only once but saves the
-                    RunClassInitialize(testContext.Context);
+                    RunClassInitialize(testContext.Context, out logListener);
                 }
                 finally
                 {
-                    initializationLogs += logListener.GetAndClearStandardOutput();
-                    initializationTrace += logListener.GetAndClearDebugTrace();
-                    initializationErrorLogs += logListener.GetAndClearStandardError();
-                    initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
+                    if (logListener is not null)
+                    {
+                        initializationLogs += logListener.GetAndClearStandardOutput();
+                        initializationTrace += logListener.GetAndClearDebugTrace();
+                        initializationErrorLogs += logListener.GetAndClearStandardError();
+                        initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
+                        logListener?.Dispose();
+                    }
                 }
             }
             catch (TestFailedException ex)
@@ -488,7 +497,7 @@ TestResult DoRun()
         }
     }
 
-    private TestFailedException? InvokeInitializeMethod(MethodInfo? methodInfo, TestContext testContext)
+    private TestFailedException? InvokeInitializeMethod(MethodInfo? methodInfo, TestContext testContext, ref LogMessageListener? logListener)
     {
         if (methodInfo is null)
         {
@@ -501,9 +510,11 @@ TestResult DoRun()
             timeout = localTimeout;
         }
 
-        return FixtureMethodRunner.RunWithTimeoutAndCancellation(
+        LogMessageListener? logMessageListener = logListener;
+        TestFailedException? result = FixtureMethodRunner.RunWithTimeoutAndCancellation(
             () =>
             {
+                logMessageListener ??= new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces);
                 methodInfo.InvokeAsSynchronousTask(null, testContext);
                 // **After** we have executed the class initialize, we save the current context.
                 // This context will contain async locals set by the class initialize method.
@@ -515,6 +526,8 @@ TestResult DoRun()
             ExecutionContext ?? Parent?.ExecutionContext,
             Resource.ClassInitializeWasCancelled,
             Resource.ClassInitializeTimedOut);
+        logListener = logMessageListener;
+        return result;
     }
 
     /// <summary>
@@ -550,12 +563,13 @@ TestResult DoRun()
                 try
                 {
                     classCleanupMethod = ClassCleanupMethod;
-                    ClassCleanupException = classCleanupMethod is not null ? InvokeCleanupMethod(classCleanupMethod, null!) : null;
+                    LogMessageListener? listener = null;
+                    ClassCleanupException = classCleanupMethod is not null ? InvokeCleanupMethod(classCleanupMethod, null!, ref listener) : null;
                     var baseClassCleanupQueue = new Queue<MethodInfo>(BaseClassCleanupMethods);
                     while (baseClassCleanupQueue.Count > 0 && ClassCleanupException is null)
                     {
                         classCleanupMethod = baseClassCleanupQueue.Dequeue();
-                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, null!);
+                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, null!, ref listener);
                     }
 
                     IsClassCleanupExecuted = ClassCleanupException is null;
@@ -607,8 +621,10 @@ TestResult DoRun()
     /// This is a replacement for RunClassCleanup but as we are on a bug fix version, we do not want to change
     /// the public API, hence this method.
     /// </remarks>
-    internal TestFailedException? ExecuteClassCleanup(TestContext testContext)
+    internal TestFailedException? ExecuteClassCleanup(TestContext testContext, out LogMessageListener? logListener)
     {
+        logListener = null;
+
         if ((ClassCleanupMethod is null && BaseClassCleanupMethods.Count == 0)
             || IsClassCleanupExecuted)
         {
@@ -635,7 +651,7 @@ TestResult DoRun()
                 {
                     if (!classCleanupMethod.DeclaringType!.IsIgnored(out _))
                     {
-                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext);
+                        ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext, ref logListener);
                     }
                 }
 
@@ -646,7 +662,7 @@ TestResult DoRun()
                         classCleanupMethod = BaseClassCleanupMethods[i];
                         if (!classCleanupMethod.DeclaringType!.IsIgnored(out _))
                         {
-                            ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext);
+                            ClassCleanupException = InvokeCleanupMethod(classCleanupMethod, testContext, ref logListener);
                             if (ClassCleanupException is not null)
                             {
                                 break;
@@ -762,10 +778,10 @@ void DoRun()
             string? initializationTestContextMessages = string.Empty;
             try
             {
-                using LogMessageListener logListener = new(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+                LogMessageListener? logListener = null;
                 try
                 {
-                    TestFailedException? ex = ExecuteClassCleanup(testContext.Context);
+                    TestFailedException? ex = ExecuteClassCleanup(testContext.Context, out logListener);
                     if (ex is not null && results.Length > 0)
                     {
 #pragma warning disable IDE0056 // Use index operator
@@ -777,10 +793,14 @@ void DoRun()
                 }
                 finally
                 {
-                    initializationLogs = logListener.GetAndClearStandardOutput();
-                    initializationErrorLogs = logListener.GetAndClearStandardError();
-                    initializationTrace = logListener.GetAndClearDebugTrace();
-                    initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                    if (logListener is not null)
+                    {
+                        initializationLogs = logListener.GetAndClearStandardOutput();
+                        initializationErrorLogs = logListener.GetAndClearStandardError();
+                        initializationTrace = logListener.GetAndClearDebugTrace();
+                        initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                        logListener.Dispose();
+                    }
                 }
             }
             finally
@@ -799,7 +819,7 @@ void DoRun()
         }
     }
 
-    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, TestContext testContext)
+    private TestFailedException? InvokeCleanupMethod(MethodInfo methodInfo, TestContext testContext, ref LogMessageListener? logListener)
     {
         TimeoutInfo? timeout = null;
         if (ClassCleanupMethodTimeoutMilliseconds.TryGetValue(methodInfo, out TimeoutInfo localTimeout))
@@ -807,9 +827,12 @@ void DoRun()
             timeout = localTimeout;
         }
 
-        return FixtureMethodRunner.RunWithTimeoutAndCancellation(
+        LogMessageListener? logMessageListener = logListener;
+        TestFailedException? result = FixtureMethodRunner.RunWithTimeoutAndCancellation(
             () =>
             {
+                logMessageListener ??= new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+
                 if (methodInfo.GetParameters().Length == 0)
                 {
                     methodInfo.InvokeAsSynchronousTask(null);
@@ -830,6 +853,9 @@ void DoRun()
             ExecutionContext ?? Parent.ExecutionContext,
             Resource.ClassCleanupWasCancelled,
             Resource.ClassCleanupTimedOut);
+
+        logListener = logMessageListener;
+        return result;
     }
 
     /// <summary>
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index b6162c87c5..06ce879814 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -149,11 +149,12 @@ public virtual TestResult Invoke(object?[]? arguments)
         // check if arguments are set for data driven tests
         arguments ??= Arguments;
 
-        using LogMessageListener listener = new(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+        LogMessageListener? listener = null;
         watch.Start();
         try
         {
             ExecutionContext? executionContext = Parent.ExecutionContext ?? Parent.Parent.ExecutionContext;
+            FixtureMethodRunner.RunOnContext(executionContext, () => listener = new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces));
             result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments, executionContext) : ExecuteInternal(arguments, executionContext, null);
         }
         finally
@@ -164,11 +165,15 @@ public virtual TestResult Invoke(object?[]? arguments)
             if (result != null)
             {
                 result.Duration = watch.Elapsed;
-                result.DebugTrace = listener.GetAndClearDebugTrace();
-                result.LogOutput = listener.GetAndClearStandardOutput();
-                result.LogError = listener.GetAndClearStandardError();
-                result.TestContextMessages = TestContext?.GetAndClearDiagnosticMessages();
-                result.ResultFiles = TestContext?.GetResultFiles();
+                if (listener is not null)
+                {
+                    result.DebugTrace = listener.GetAndClearDebugTrace();
+                    result.LogOutput = listener.GetAndClearStandardOutput();
+                    result.LogError = listener.GetAndClearStandardError();
+                    result.TestContextMessages = TestContext?.GetAndClearDiagnosticMessages();
+                    result.ResultFiles = TestContext?.GetResultFiles();
+                    listener.Dispose();
+                }
             }
         }
 
@@ -384,7 +389,7 @@ private TestResult ExecuteInternal(object?[]? arguments, ExecutionContext? execu
         var result = new TestResult();
 
         // TODO remove dry violation with TestMethodRunner
-        _classInstance = CreateTestClassInstance(result);
+        FixtureMethodRunner.RunOnContext(executionContext, () => _classInstance = CreateTestClassInstance(result));
         bool isExceptionThrown = false;
         bool hasTestInitializePassed = false;
         Exception? testRunnerException = null;
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index 553b831523..d33e533be7 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -245,17 +245,21 @@ private static TestResult RunAssemblyInitializeIfNeeded(TestMethodInfo testMetho
 
         try
         {
-            using LogMessageListener logListener = new(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+            LogMessageListener? logListener = null;
             try
             {
-                testMethodInfo.Parent.Parent.RunAssemblyInitialize(testContext.Context);
+                testMethodInfo.Parent.Parent.RunAssemblyInitialize(testContext.Context, out logListener);
             }
             finally
             {
-                initializationLogs = logListener.GetAndClearStandardOutput();
-                initializationErrorLogs = logListener.GetAndClearStandardError();
-                initializationTrace = logListener.GetAndClearDebugTrace();
-                initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                if (logListener is not null)
+                {
+                    initializationLogs = logListener.GetAndClearStandardOutput();
+                    initializationErrorLogs = logListener.GetAndClearStandardError();
+                    initializationTrace = logListener.GetAndClearDebugTrace();
+                    initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                    logListener.Dispose();
+                }
             }
         }
         catch (TestFailedException ex)
@@ -291,7 +295,7 @@ private static void RunAssemblyCleanupIfNeeded(ITestContext testContext, ClassCl
         string? initializationTestContextMessages = string.Empty;
         try
         {
-            using LogMessageListener logListener = new(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+            LogMessageListener? logListener = null;
             try
             {
                 // TODO: We are using the same TestContext here for ClassCleanup and AssemblyCleanup.
@@ -299,7 +303,7 @@ private static void RunAssemblyCleanupIfNeeded(ITestContext testContext, ClassCl
                 IEnumerable<TestClassInfo> classInfoCache = typeCache.ClassInfoListWithExecutableCleanupMethods;
                 foreach (TestClassInfo classInfo in classInfoCache)
                 {
-                    TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext.Context);
+                    TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext.Context, out logListener);
                     if (ex is not null && results.Length > 0)
                     {
 #pragma warning disable IDE0056 // Use index operator
@@ -328,10 +332,14 @@ private static void RunAssemblyCleanupIfNeeded(ITestContext testContext, ClassCl
             }
             finally
             {
-                initializationLogs = logListener.GetAndClearStandardOutput();
-                initializationErrorLogs = logListener.GetAndClearStandardError();
-                initializationTrace = logListener.GetAndClearDebugTrace();
-                initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                if (logListener is not null)
+                {
+                    initializationLogs = logListener.GetAndClearStandardOutput();
+                    initializationErrorLogs = logListener.GetAndClearStandardError();
+                    initializationTrace = logListener.GetAndClearDebugTrace();
+                    initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                    logListener.Dispose();
+                }
             }
         }
         finally

From 1894f39de9e0fe03f434de2f256a63fa01f7e3c8 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Wed, 5 Mar 2025 11:39:17 +0100
Subject: [PATCH 15/23] Fix build errors

---
 .../Execution/ClassCleanupManager.cs          |  5 ++--
 .../Execution/TestAssemblyInfo.cs             |  8 +++++-
 .../Execution/UnitTestRunner.cs               |  2 +-
 .../Execution/TestClassInfoTests.cs           | 26 +++++++++----------
 4 files changed, 24 insertions(+), 17 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/ClassCleanupManager.cs b/src/Adapter/MSTest.TestAdapter/Execution/ClassCleanupManager.cs
index d5ad0463d2..fca58e95d8 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/ClassCleanupManager.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/ClassCleanupManager.cs
@@ -68,9 +68,10 @@ internal static void ForceCleanup(TypeCache typeCache, IDictionary<string, objec
         using var writer = new ThreadSafeStringWriter(CultureInfo.InvariantCulture, "context");
         TestContext testContext = new TestContextImplementation(null, writer, sourceLevelParameters, logger);
         IEnumerable<TestClassInfo> classInfoCache = typeCache.ClassInfoListWithExecutableCleanupMethods;
+        LogMessageListener? listener = null;
         foreach (TestClassInfo classInfo in classInfoCache)
         {
-            TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext);
+            TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext, out listener);
             if (ex is not null)
             {
                 throw ex;
@@ -80,7 +81,7 @@ internal static void ForceCleanup(TypeCache typeCache, IDictionary<string, objec
         IEnumerable<TestAssemblyInfo> assemblyInfoCache = typeCache.AssemblyInfoListWithExecutableCleanupMethods;
         foreach (TestAssemblyInfo assemblyInfo in assemblyInfoCache)
         {
-            TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext);
+            TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext, ref listener);
             if (ex is not null)
             {
                 throw ex;
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
index 23db5aef07..38e2fea27b 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestAssemblyInfo.cs
@@ -280,7 +280,7 @@ internal void RunAssemblyInitialize(TestContext testContext, out LogMessageListe
     /// It is a replacement for RunAssemblyCleanup but as we are in a bug-fix version, we do not want to touch
     /// public API and so we introduced this method.
     /// </remarks>
-    internal TestFailedException? ExecuteAssemblyCleanup(TestContext testContext)
+    internal TestFailedException? ExecuteAssemblyCleanup(TestContext testContext, ref LogMessageListener? logListener)
     {
         if (AssemblyCleanupMethod == null)
         {
@@ -289,11 +289,13 @@ internal void RunAssemblyInitialize(TestContext testContext, out LogMessageListe
 
         lock (_assemblyInfoExecuteSyncObject)
         {
+            LogMessageListener? logMessageListener = logListener;
             try
             {
                 AssemblyCleanupException = FixtureMethodRunner.RunWithTimeoutAndCancellation(
                      () =>
                      {
+                         logMessageListener ??= new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces);
                          if (AssemblyCleanupMethod.GetParameters().Length == 0)
                          {
                              AssemblyCleanupMethod.InvokeAsSynchronousTask(null);
@@ -316,6 +318,10 @@ internal void RunAssemblyInitialize(TestContext testContext, out LogMessageListe
             {
                 AssemblyCleanupException = ex;
             }
+            finally
+            {
+                logListener = logMessageListener;
+            }
         }
 
         // If assemblyCleanup was successful, then don't do anything
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index d33e533be7..f56fe72b13 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -318,7 +318,7 @@ private static void RunAssemblyCleanupIfNeeded(ITestContext testContext, ClassCl
                 IEnumerable<TestAssemblyInfo> assemblyInfoCache = typeCache.AssemblyInfoListWithExecutableCleanupMethods;
                 foreach (TestAssemblyInfo assemblyInfo in assemblyInfoCache)
                 {
-                    TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext.Context);
+                    TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext.Context, ref logListener);
                     if (ex is not null && results.Length > 0)
                     {
 #pragma warning disable IDE0056 // Use index operator
diff --git a/test/UnitTests/MSTestAdapter.UnitTests/Execution/TestClassInfoTests.cs b/test/UnitTests/MSTestAdapter.UnitTests/Execution/TestClassInfoTests.cs
index ec14bf84d0..4194631f96 100644
--- a/test/UnitTests/MSTestAdapter.UnitTests/Execution/TestClassInfoTests.cs
+++ b/test/UnitTests/MSTestAdapter.UnitTests/Execution/TestClassInfoTests.cs
@@ -132,7 +132,7 @@ public void TestClassInfoClassCleanupMethodShouldNotInvokeWhenNoTestClassInitial
         _testClassInfo.ClassCleanupMethod = typeof(DummyTestClass).GetMethod("ClassCleanupMethod")!;
         _testClassInfo.ClassInitializeMethod = typeof(DummyTestClass).GetMethod("ClassInitializeMethod")!;
 
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>())); // call cleanup without calling init
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _); // call cleanup without calling init
         Verify(ex is null);
         Verify(classCleanupCallCount == 0);
     }
@@ -146,7 +146,7 @@ public void TestClassInfoClassCleanupMethodShouldInvokeWhenTestClassInitializedI
         _testClassInfo.ClassInitializeMethod = typeof(DummyTestClass).GetMethod("ClassInitializeMethod")!;
 
         GetResultOrRunClassInitialize();
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>())); // call cleanup without calling init
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _); // call cleanup without calling init
 
         Verify(ex is null);
         Verify(classCleanupCallCount == 1);
@@ -161,7 +161,7 @@ public void TestClassInfoClassCleanupMethodShouldInvokeBaseClassCleanupMethodWhe
         _testClassInfo.BaseClassCleanupMethods.Add(typeof(DummyBaseTestClass).GetMethod("CleanupClassMethod")!);
 
         GetResultOrRunClassInitialize();
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         Verify(ex is null);
         Verify(classCleanupCallCount == 1);
@@ -465,7 +465,7 @@ public void RunClassCleanupShouldInvokeIfClassCleanupMethod()
 
         // Act
         GetResultOrRunClassInitialize(null);
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(ex is null);
@@ -480,7 +480,7 @@ public void RunClassCleanupShouldNotInvokeIfClassCleanupIsNull()
         _testClassInfo.ClassCleanupMethod = null;
 
         // Act
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(ex is null);
@@ -495,7 +495,7 @@ public void RunClassCleanupShouldReturnAssertFailureExceptionDetails()
 
         // Act
         GetResultOrRunClassInitialize(null);
-        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(classCleanupException is not null);
@@ -517,7 +517,7 @@ public void RunClassCleanupShouldReturnAssertInconclusiveExceptionDetails()
 
         // Act
         GetResultOrRunClassInitialize(null);
-        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(classCleanupException is not null);
@@ -538,7 +538,7 @@ public void RunClassCleanupShouldReturnExceptionDetailsOfNonAssertExceptions()
 
         // Act
         GetResultOrRunClassInitialize(null);
-        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(classCleanupException is not null);
@@ -557,7 +557,7 @@ public void RunBaseClassCleanupWithNoDerivedClassCleanupShouldReturnExceptionDet
 
         // Act
         GetResultOrRunClassInitialize(null);
-        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(classCleanupException is not null);
@@ -576,7 +576,7 @@ public void RunBaseClassCleanupEvenIfThereIsNoDerivedClassCleanup()
         _testClassInfo.BaseClassCleanupMethods.Add(baseClassCleanupMethod);
 
         // Act
-        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert
         Verify(ex is null);
@@ -585,7 +585,7 @@ public void RunBaseClassCleanupEvenIfThereIsNoDerivedClassCleanup()
 
         // Act 2
         GetResultOrRunClassInitialize(null);
-        ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert 2
         Verify(ex is null);
@@ -594,7 +594,7 @@ public void RunBaseClassCleanupEvenIfThereIsNoDerivedClassCleanup()
         Verify(classCleanupCallCount == 1, "DummyBaseTestClass.CleanupClassMethod call count");
 
         // Act 3
-        ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        ex = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         // Assert 3
         Verify(ex is null);
@@ -611,7 +611,7 @@ public void RunClassCleanupShouldThrowTheInnerMostExceptionWhenThereAreMultipleN
         _testClassInfo.ClassCleanupMethod = typeof(DummyTestClass).GetMethod("ClassCleanupMethod")!;
 
         GetResultOrRunClassInitialize(null);
-        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()));
+        TestFailedException? classCleanupException = _testClassInfo.ExecuteClassCleanup(new TestContextImplementation(null, new StringWriter(), new Dictionary<string, object?>()), out _);
 
         Verify(classCleanupException is not null);
         Verify(classCleanupException.Message.StartsWith("Class Cleanup method DummyTestClass.ClassCleanupMethod failed. Error Message: System.InvalidOperationException: I fail..", StringComparison.Ordinal));

From a9d3f13ba9be4721e8c7457317d8c781685da650 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Wed, 5 Mar 2025 13:08:26 +0100
Subject: [PATCH 16/23] Run more of test lifecycle on correct execution context

---
 .../MSTest.TestAdapter/Execution/TestMethodInfo.cs  | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 06ce879814..ae8c3fca2f 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -677,12 +677,17 @@ private void RunTestCleanupMethod(TestResult result, ExecutionContext? execution
             }
             finally
             {
-                // TODO: Maybe we should invoke Dispose on the execution context.
 #if NET6_0_OR_GREATER
-                // If you implement IAsyncDisposable without calling the DisposeAsync this would result a resource leak.
-                (_classInstance as IAsyncDisposable)?.DisposeAsync().AsTask().Wait();
+                if (_classInstance is IAsyncDisposable classInstanceAsAsyncDisposable)
+                {
+                    // If you implement IAsyncDisposable without calling the DisposeAsync this would result a resource leak.
+                    FixtureMethodRunner.RunOnContext(executionContext, () => classInstanceAsAsyncDisposable.DisposeAsync().AsTask().Wait());
+                }
 #endif
-                (_classInstance as IDisposable)?.Dispose();
+                if (_classInstance is IDisposable classInstanceAsDisposable)
+                {
+                    FixtureMethodRunner.RunOnContext(executionContext, classInstanceAsDisposable.Dispose);
+                }
             }
         }
         catch (Exception ex)

From 9daa1a7d5b068af9e279824ae76aa5314ad375e3 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Wed, 5 Mar 2025 16:15:16 +0100
Subject: [PATCH 17/23] Progress

---
 .../Execution/TestClassInfo.cs                | 31 +++++++++++++------
 .../Execution/TestMethodInfo.cs               | 19 +++++++-----
 .../Execution/UnitTestRunner.cs               | 13 +++++---
 3 files changed, 41 insertions(+), 22 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 519eb94810..0737cb89fd 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -455,6 +455,11 @@ TestResult DoRun()
                 Outcome = TestTools.UnitTesting.UnitTestOutcome.Passed,
             };
 
+            if (this.ClassType.Name == "LifeCycleClassCleanupEndOfAssembly")
+            {
+
+            }
+
             try
             {
                 LogMessageListener? logListener = null;
@@ -467,11 +472,14 @@ TestResult DoRun()
                 {
                     if (logListener is not null)
                     {
-                        initializationLogs += logListener.GetAndClearStandardOutput();
-                        initializationTrace += logListener.GetAndClearDebugTrace();
-                        initializationErrorLogs += logListener.GetAndClearStandardError();
-                        initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
-                        logListener?.Dispose();
+                        FixtureMethodRunner.RunOnContext(ExecutionContext, () =>
+                        {
+                            initializationLogs += logListener.GetAndClearStandardOutput();
+                            initializationTrace += logListener.GetAndClearDebugTrace();
+                            initializationErrorLogs += logListener.GetAndClearStandardError();
+                            initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
+                            logListener?.Dispose();
+                        });
                     }
                 }
             }
@@ -795,11 +803,14 @@ void DoRun()
                 {
                     if (logListener is not null)
                     {
-                        initializationLogs = logListener.GetAndClearStandardOutput();
-                        initializationErrorLogs = logListener.GetAndClearStandardError();
-                        initializationTrace = logListener.GetAndClearDebugTrace();
-                        initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
-                        logListener.Dispose();
+                        FixtureMethodRunner.RunOnContext(ExecutionContext, () =>
+                        {
+                            initializationLogs = logListener.GetAndClearStandardOutput();
+                            initializationErrorLogs = logListener.GetAndClearStandardError();
+                            initializationTrace = logListener.GetAndClearDebugTrace();
+                            initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                            logListener.Dispose();
+                        });
                     }
                 }
             }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index ae8c3fca2f..564cfc4515 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -151,9 +151,11 @@ public virtual TestResult Invoke(object?[]? arguments)
 
         LogMessageListener? listener = null;
         watch.Start();
+
+        ExecutionContext? executionContext = Parent.ExecutionContext ?? Parent.Parent.ExecutionContext;
+
         try
         {
-            ExecutionContext? executionContext = Parent.ExecutionContext ?? Parent.Parent.ExecutionContext;
             FixtureMethodRunner.RunOnContext(executionContext, () => listener = new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces));
             result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments, executionContext) : ExecuteInternal(arguments, executionContext, null);
         }
@@ -167,12 +169,15 @@ public virtual TestResult Invoke(object?[]? arguments)
                 result.Duration = watch.Elapsed;
                 if (listener is not null)
                 {
-                    result.DebugTrace = listener.GetAndClearDebugTrace();
-                    result.LogOutput = listener.GetAndClearStandardOutput();
-                    result.LogError = listener.GetAndClearStandardError();
-                    result.TestContextMessages = TestContext?.GetAndClearDiagnosticMessages();
-                    result.ResultFiles = TestContext?.GetResultFiles();
-                    listener.Dispose();
+                    FixtureMethodRunner.RunOnContext(executionContext, () =>
+                    {
+                        result.DebugTrace = listener.GetAndClearDebugTrace();
+                        result.LogOutput = listener.GetAndClearStandardOutput();
+                        result.LogError = listener.GetAndClearStandardError();
+                        result.TestContextMessages = TestContext?.GetAndClearDiagnosticMessages();
+                        result.ResultFiles = TestContext?.GetResultFiles();
+                        listener.Dispose();
+                    });
                 }
             }
         }
diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index f56fe72b13..bdf9ae3a5e 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -254,11 +254,14 @@ private static TestResult RunAssemblyInitializeIfNeeded(TestMethodInfo testMetho
             {
                 if (logListener is not null)
                 {
-                    initializationLogs = logListener.GetAndClearStandardOutput();
-                    initializationErrorLogs = logListener.GetAndClearStandardError();
-                    initializationTrace = logListener.GetAndClearDebugTrace();
-                    initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
-                    logListener.Dispose();
+                    FixtureMethodRunner.RunOnContext(testMethodInfo.Parent.Parent.ExecutionContext, () =>
+                    {
+                        initializationLogs = logListener.GetAndClearStandardOutput();
+                        initializationErrorLogs = logListener.GetAndClearStandardError();
+                        initializationTrace = logListener.GetAndClearDebugTrace();
+                        initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
+                        logListener.Dispose();
+                    });
                 }
             }
         }

From 1ac9212d688bd4761c82b559e23ef44d15ec820f Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Wed, 5 Mar 2025 16:15:56 +0100
Subject: [PATCH 18/23] Remove code that was for debugging purposes

---
 src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
index 0737cb89fd..1f84833a0e 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestClassInfo.cs
@@ -455,11 +455,6 @@ TestResult DoRun()
                 Outcome = TestTools.UnitTesting.UnitTestOutcome.Passed,
             };
 
-            if (this.ClassType.Name == "LifeCycleClassCleanupEndOfAssembly")
-            {
-
-            }
-
             try
             {
                 LogMessageListener? logListener = null;

From 97590a1fc2b60bd8c6ad49e9019c02713bbff6ed Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Thu, 6 Mar 2025 08:44:24 +0100
Subject: [PATCH 19/23] Adjust

---
 .../Execution/UnitTestRunner.cs               | 72 +++++++++++--------
 1 file changed, 42 insertions(+), 30 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
index bdf9ae3a5e..bf1fcd0feb 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/UnitTestRunner.cs
@@ -299,49 +299,61 @@ private static void RunAssemblyCleanupIfNeeded(ITestContext testContext, ClassCl
         try
         {
             LogMessageListener? logListener = null;
-            try
+            // TODO: We are using the same TestContext here for ClassCleanup and AssemblyCleanup.
+            // They should be different.
+            IEnumerable<TestClassInfo> classInfoCache = typeCache.ClassInfoListWithExecutableCleanupMethods;
+            foreach (TestClassInfo classInfo in classInfoCache)
             {
-                // TODO: We are using the same TestContext here for ClassCleanup and AssemblyCleanup.
-                // They should be different.
-                IEnumerable<TestClassInfo> classInfoCache = typeCache.ClassInfoListWithExecutableCleanupMethods;
-                foreach (TestClassInfo classInfo in classInfoCache)
+                TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext.Context, out logListener);
+                if (logListener is not null)
                 {
-                    TestFailedException? ex = classInfo.ExecuteClassCleanup(testContext.Context, out logListener);
-                    if (ex is not null && results.Length > 0)
+                    FixtureMethodRunner.RunOnContext(classInfo.ExecutionContext, () =>
                     {
-#pragma warning disable IDE0056 // Use index operator
-                        TestResult lastResult = results[results.Length - 1];
-#pragma warning restore IDE0056 // Use index operator
-                        lastResult.Outcome = UTF.UnitTestOutcome.Error;
-                        lastResult.TestFailureException = ex;
-                        return;
-                    }
+                        initializationLogs += logListener.GetAndClearStandardOutput();
+                        initializationErrorLogs += logListener.GetAndClearStandardError();
+                        initializationTrace += logListener.GetAndClearDebugTrace();
+                        initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
+                        logListener.Dispose();
+                        logListener = null;
+                    });
                 }
 
-                IEnumerable<TestAssemblyInfo> assemblyInfoCache = typeCache.AssemblyInfoListWithExecutableCleanupMethods;
-                foreach (TestAssemblyInfo assemblyInfo in assemblyInfoCache)
+                if (ex is not null && results.Length > 0)
                 {
-                    TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext.Context, ref logListener);
-                    if (ex is not null && results.Length > 0)
-                    {
 #pragma warning disable IDE0056 // Use index operator
-                        TestResult lastResult = results[results.Length - 1];
+                    TestResult lastResult = results[results.Length - 1];
 #pragma warning restore IDE0056 // Use index operator
-                        lastResult.Outcome = UTF.UnitTestOutcome.Error;
-                        lastResult.TestFailureException = ex;
-                        return;
-                    }
+                    lastResult.Outcome = UTF.UnitTestOutcome.Error;
+                    lastResult.TestFailureException = ex;
+                    return;
                 }
             }
-            finally
+
+            IEnumerable<TestAssemblyInfo> assemblyInfoCache = typeCache.AssemblyInfoListWithExecutableCleanupMethods;
+            foreach (TestAssemblyInfo assemblyInfo in assemblyInfoCache)
             {
+                TestFailedException? ex = assemblyInfo.ExecuteAssemblyCleanup(testContext.Context, ref logListener);
                 if (logListener is not null)
                 {
-                    initializationLogs = logListener.GetAndClearStandardOutput();
-                    initializationErrorLogs = logListener.GetAndClearStandardError();
-                    initializationTrace = logListener.GetAndClearDebugTrace();
-                    initializationTestContextMessages = testContext.GetAndClearDiagnosticMessages();
-                    logListener.Dispose();
+                    FixtureMethodRunner.RunOnContext(assemblyInfo.ExecutionContext, () =>
+                    {
+                        initializationLogs += logListener.GetAndClearStandardOutput();
+                        initializationErrorLogs += logListener.GetAndClearStandardError();
+                        initializationTrace += logListener.GetAndClearDebugTrace();
+                        initializationTestContextMessages += testContext.GetAndClearDiagnosticMessages();
+                        logListener.Dispose();
+                        logListener = null;
+                    });
+                }
+
+                if (ex is not null && results.Length > 0)
+                {
+#pragma warning disable IDE0056 // Use index operator
+                    TestResult lastResult = results[results.Length - 1];
+#pragma warning restore IDE0056 // Use index operator
+                    lastResult.Outcome = UTF.UnitTestOutcome.Error;
+                    lastResult.TestFailureException = ex;
+                    return;
                 }
             }
         }

From 8771de9ca4f7f0818733e3f93ebbaaaa65d9e9df Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Thu, 6 Mar 2025 10:40:06 +0100
Subject: [PATCH 20/23] Proper capture

---
 .../Execution/TestMethodInfo.cs                | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 564cfc4515..05faca6b32 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -394,7 +394,11 @@ private TestResult ExecuteInternal(object?[]? arguments, ExecutionContext? execu
         var result = new TestResult();
 
         // TODO remove dry violation with TestMethodRunner
-        FixtureMethodRunner.RunOnContext(executionContext, () => _classInstance = CreateTestClassInstance(result));
+        FixtureMethodRunner.RunOnContext(executionContext, () =>
+        {
+            _classInstance = CreateTestClassInstance(result);
+            executionContext = ExecutionContext.Capture();
+        });
         bool isExceptionThrown = false;
         bool hasTestInitializePassed = false;
         Exception? testRunnerException = null;
@@ -686,12 +690,20 @@ private void RunTestCleanupMethod(TestResult result, ExecutionContext? execution
                 if (_classInstance is IAsyncDisposable classInstanceAsAsyncDisposable)
                 {
                     // If you implement IAsyncDisposable without calling the DisposeAsync this would result a resource leak.
-                    FixtureMethodRunner.RunOnContext(executionContext, () => classInstanceAsAsyncDisposable.DisposeAsync().AsTask().Wait());
+                    FixtureMethodRunner.RunOnContext(executionContext, () =>
+                    {
+                        classInstanceAsAsyncDisposable.DisposeAsync().AsTask().Wait();
+                        executionContext = ExecutionContext.Capture();
+                    });
                 }
 #endif
                 if (_classInstance is IDisposable classInstanceAsDisposable)
                 {
-                    FixtureMethodRunner.RunOnContext(executionContext, classInstanceAsDisposable.Dispose);
+                    FixtureMethodRunner.RunOnContext(executionContext, () =>
+                    {
+                        classInstanceAsDisposable.Dispose();
+                        executionContext = ExecutionContext.Capture();
+                    });
                 }
             }
         }

From d092687af2181610be0e87e1cad174451a5913e4 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Thu, 6 Mar 2025 10:55:50 +0100
Subject: [PATCH 21/23] Ensure separation between test methods

---
 .../MSTest.TestAdapter/Execution/TestMethodInfo.cs        | 8 +++++++-
 .../Services/ThreadSafeStringWriter.cs                    | 8 ++++++++
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
index 05faca6b32..c92ef52ef7 100644
--- a/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
+++ b/src/Adapter/MSTest.TestAdapter/Execution/TestMethodInfo.cs
@@ -4,6 +4,7 @@
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.Helpers;
 using Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter.ObjectModel;
+using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Extensions;
 using Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices.Interface;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
@@ -156,7 +157,12 @@ public virtual TestResult Invoke(object?[]? arguments)
 
         try
         {
-            FixtureMethodRunner.RunOnContext(executionContext, () => listener = new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces));
+            FixtureMethodRunner.RunOnContext(executionContext, () =>
+            {
+                ThreadSafeStringWriter.CleanState();
+                listener = new LogMessageListener(MSTestSettings.CurrentSettings.CaptureDebugTraces);
+                executionContext = ExecutionContext.Capture();
+            });
             result = IsTimeoutSet ? ExecuteInternalWithTimeout(arguments, executionContext) : ExecuteInternal(arguments, executionContext, null);
         }
         finally
diff --git a/src/Adapter/MSTestAdapter.PlatformServices/Services/ThreadSafeStringWriter.cs b/src/Adapter/MSTestAdapter.PlatformServices/Services/ThreadSafeStringWriter.cs
index 4a266d11b8..acfc70a4c8 100644
--- a/src/Adapter/MSTestAdapter.PlatformServices/Services/ThreadSafeStringWriter.cs
+++ b/src/Adapter/MSTestAdapter.PlatformServices/Services/ThreadSafeStringWriter.cs
@@ -181,6 +181,14 @@ private ThreadSafeStringBuilder GetOrAddStringBuilder()
         }
     }
 
+    internal static void CleanState()
+    {
+        lock (StaticLockObject)
+        {
+            State.Value = new();
+        }
+    }
+
     /// <summary>
     /// This StringBuilder puts locks around all the methods to avoid conflicts when writing or reading from multiple threads.
     /// </summary>

From 26c7aaa41e7e1e5e4fa9935798001ad5ddd61b5b Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Thu, 6 Mar 2025 12:31:49 +0100
Subject: [PATCH 22/23] Fix test

---
 .../GenericTestMethodTests.cs                                 | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
index 9d6053447e..9a242a8ab7 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
@@ -38,18 +38,22 @@ at .+?
             failed ParameterizedMethodSimple \(null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodSimple threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T' could not be inferred\.
+              at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(1,"Hello world",2,3\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: Found two conflicting types for generic parameter 'T2'\. The conflicting types are 'System\.Byte' and 'System\.Int32'\.
+              at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(null,"Hello world","Hello again",3\) \(\d+ms\)
               Assert\.Fail failed\. Test method 'ParameterizedMethodTwoGenericParametersAndFourMethodParameters' did run with parameters '<null>', 'Hello world', 'Hello again', '3' and generic types 'System\.Int32', 'System\.String'\.
                 at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \("Hello hello","Hello world",null,null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T1' could not be inferred\.
+              at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(null,null,null,null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T1' could not be inferred\.
+              at .+?
             failed ParameterizedMethodSimpleParams \(1\) \(\d+ms\)
               Cannot create an instance of T\[] because Type\.ContainsGenericParameters is true\.
                 at .+?

From 561fc17a59aaa0c081c74e0493f7d9b0318f92b9 Mon Sep 17 00:00:00 2001
From: Youssef1313 <youssefvictor00@gmail.com>
Date: Thu, 6 Mar 2025 12:49:51 +0100
Subject: [PATCH 23/23] Fix test

---
 .../GenericTestMethodTests.cs                             | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
index 9a242a8ab7..93e37d209b 100644
--- a/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
+++ b/test/IntegrationTests/MSTest.Acceptance.IntegrationTests/GenericTestMethodTests.cs
@@ -38,22 +38,22 @@ at .+?
             failed ParameterizedMethodSimple \(null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodSimple threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T' could not be inferred\.
-              at .+?
+                at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(1,"Hello world",2,3\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: Found two conflicting types for generic parameter 'T2'\. The conflicting types are 'System\.Byte' and 'System\.Int32'\.
-              at .+?
+                at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(null,"Hello world","Hello again",3\) \(\d+ms\)
               Assert\.Fail failed\. Test method 'ParameterizedMethodTwoGenericParametersAndFourMethodParameters' did run with parameters '<null>', 'Hello world', 'Hello again', '3' and generic types 'System\.Int32', 'System\.String'\.
                 at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \("Hello hello","Hello world",null,null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T1' could not be inferred\.
-              at .+?
+                at .+?
             failed ParameterizedMethodTwoGenericParametersAndFourMethodParameters \(null,null,null,null\) \(\d+ms\)
               Test method TestClass\.ParameterizedMethodTwoGenericParametersAndFourMethodParameters threw exception: 
               System\.InvalidOperationException: The type of the generic parameter 'T1' could not be inferred\.
-              at .+?
+                at .+?
             failed ParameterizedMethodSimpleParams \(1\) \(\d+ms\)
               Cannot create an instance of T\[] because Type\.ContainsGenericParameters is true\.
                 at .+?
